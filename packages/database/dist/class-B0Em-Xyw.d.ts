import * as runtime from '@prisma/client/runtime/client';
import { A as AppointmentStatus, D as DoctorApplicationStatus, a as DoctorType, H as HospitalType, c as ScheduleType, b as ScheduleStatus, S as SchedulePeriod, d as SlotStatus, R as Role } from './enums-CHmCo_GR.js';

/**
 * Model Appointment
 *
 */
type AppointmentModel = runtime.Types.Result.DefaultSelection<$AppointmentPayload>;
type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null;
    _min: AppointmentMinAggregateOutputType | null;
    _max: AppointmentMaxAggregateOutputType | null;
};
type AppointmentMinAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    doctorId: string | null;
    scheduleId: string | null;
    slotId: string | null;
    status: AppointmentStatus | null;
    approvedSlotStart: Date | null;
    approvedSlotEnd: Date | null;
    notes: string | null;
    approvedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    tx_ref: string | null;
    hospitalId: string | null;
    isPaid: boolean | null;
};
type AppointmentMaxAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    doctorId: string | null;
    scheduleId: string | null;
    slotId: string | null;
    status: AppointmentStatus | null;
    approvedSlotStart: Date | null;
    approvedSlotEnd: Date | null;
    notes: string | null;
    approvedBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    tx_ref: string | null;
    hospitalId: string | null;
    isPaid: boolean | null;
};
type AppointmentCountAggregateOutputType = {
    id: number;
    customerId: number;
    doctorId: number;
    scheduleId: number;
    slotId: number;
    status: number;
    approvedSlotStart: number;
    approvedSlotEnd: number;
    notes: number;
    approvedBy: number;
    createdAt: number;
    updatedAt: number;
    tx_ref: number;
    hospitalId: number;
    isPaid: number;
    _all: number;
};
type AppointmentMinAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    scheduleId?: true;
    slotId?: true;
    status?: true;
    approvedSlotStart?: true;
    approvedSlotEnd?: true;
    notes?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    tx_ref?: true;
    hospitalId?: true;
    isPaid?: true;
};
type AppointmentMaxAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    scheduleId?: true;
    slotId?: true;
    status?: true;
    approvedSlotStart?: true;
    approvedSlotEnd?: true;
    notes?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    tx_ref?: true;
    hospitalId?: true;
    isPaid?: true;
};
type AppointmentCountAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    scheduleId?: true;
    slotId?: true;
    status?: true;
    approvedSlotStart?: true;
    approvedSlotEnd?: true;
    notes?: true;
    approvedBy?: true;
    createdAt?: true;
    updatedAt?: true;
    tx_ref?: true;
    hospitalId?: true;
    isPaid?: true;
    _all?: true;
};
type AppointmentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Appointments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Appointments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType;
};
type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
    [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateAppointment[P]> : GetScalarType<T[P], AggregateAppointment[P]>;
};
type AppointmentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[];
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum;
    having?: AppointmentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AppointmentCountAggregateInputType | true;
    _min?: AppointmentMinAggregateInputType;
    _max?: AppointmentMaxAggregateInputType;
};
type AppointmentGroupByOutputType = {
    id: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status: AppointmentStatus;
    approvedSlotStart: Date;
    approvedSlotEnd: Date;
    notes: string | null;
    approvedBy: string | null;
    createdAt: Date;
    updatedAt: Date;
    tx_ref: string;
    hospitalId: string;
    isPaid: boolean;
    _count: AppointmentCountAggregateOutputType | null;
    _min: AppointmentMinAggregateOutputType | null;
    _max: AppointmentMaxAggregateOutputType | null;
};
type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = PrismaPromise<Array<PickEnumerable<AppointmentGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], AppointmentGroupByOutputType[P]> : GetScalarType<T[P], AppointmentGroupByOutputType[P]>;
}>>;
type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[];
    OR?: AppointmentWhereInput[];
    NOT?: AppointmentWhereInput | AppointmentWhereInput[];
    id?: StringFilter<"Appointment"> | string;
    customerId?: StringFilter<"Appointment"> | string;
    doctorId?: StringFilter<"Appointment"> | string;
    scheduleId?: StringFilter<"Appointment"> | string;
    slotId?: StringFilter<"Appointment"> | string;
    status?: EnumAppointmentStatusFilter<"Appointment"> | AppointmentStatus;
    approvedSlotStart?: DateTimeFilter<"Appointment"> | Date | string;
    approvedSlotEnd?: DateTimeFilter<"Appointment"> | Date | string;
    notes?: StringNullableFilter<"Appointment"> | string | null;
    approvedBy?: StringNullableFilter<"Appointment"> | string | null;
    createdAt?: DateTimeFilter<"Appointment"> | Date | string;
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string;
    tx_ref?: StringFilter<"Appointment"> | string;
    hospitalId?: StringFilter<"Appointment"> | string;
    isPaid?: BoolFilter<"Appointment"> | boolean;
    User_Appointment_approvedByToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    User_Appointment_customerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>;
    Payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null;
    Slot?: XOR<SlotNullableScalarRelationFilter, SlotWhereInput> | null;
};
type AppointmentOrderByWithRelationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    scheduleId?: SortOrder;
    slotId?: SortOrder;
    status?: SortOrder;
    approvedSlotStart?: SortOrder;
    approvedSlotEnd?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tx_ref?: SortOrder;
    hospitalId?: SortOrder;
    isPaid?: SortOrder;
    User_Appointment_approvedByToUser?: UserOrderByWithRelationInput;
    User_Appointment_customerIdToUser?: UserOrderByWithRelationInput;
    Doctor?: DoctorOrderByWithRelationInput;
    Hospital?: HospitalOrderByWithRelationInput;
    Schedule?: ScheduleOrderByWithRelationInput;
    Payment?: PaymentOrderByWithRelationInput;
    Slot?: SlotOrderByWithRelationInput;
};
type AppointmentWhereUniqueInput = AtLeast<{
    id?: string;
    slotId?: string;
    tx_ref?: string;
    AND?: AppointmentWhereInput | AppointmentWhereInput[];
    OR?: AppointmentWhereInput[];
    NOT?: AppointmentWhereInput | AppointmentWhereInput[];
    customerId?: StringFilter<"Appointment"> | string;
    doctorId?: StringFilter<"Appointment"> | string;
    scheduleId?: StringFilter<"Appointment"> | string;
    status?: EnumAppointmentStatusFilter<"Appointment"> | AppointmentStatus;
    approvedSlotStart?: DateTimeFilter<"Appointment"> | Date | string;
    approvedSlotEnd?: DateTimeFilter<"Appointment"> | Date | string;
    notes?: StringNullableFilter<"Appointment"> | string | null;
    approvedBy?: StringNullableFilter<"Appointment"> | string | null;
    createdAt?: DateTimeFilter<"Appointment"> | Date | string;
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string;
    hospitalId?: StringFilter<"Appointment"> | string;
    isPaid?: BoolFilter<"Appointment"> | boolean;
    User_Appointment_approvedByToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    User_Appointment_customerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>;
    Payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null;
    Slot?: XOR<SlotNullableScalarRelationFilter, SlotWhereInput> | null;
}, "id" | "slotId" | "tx_ref">;
type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    scheduleId?: SortOrder;
    slotId?: SortOrder;
    status?: SortOrder;
    approvedSlotStart?: SortOrder;
    approvedSlotEnd?: SortOrder;
    notes?: SortOrderInput | SortOrder;
    approvedBy?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tx_ref?: SortOrder;
    hospitalId?: SortOrder;
    isPaid?: SortOrder;
    _count?: AppointmentCountOrderByAggregateInput;
    _max?: AppointmentMaxOrderByAggregateInput;
    _min?: AppointmentMinOrderByAggregateInput;
};
type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[];
    OR?: AppointmentScalarWhereWithAggregatesInput[];
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Appointment"> | string;
    customerId?: StringWithAggregatesFilter<"Appointment"> | string;
    doctorId?: StringWithAggregatesFilter<"Appointment"> | string;
    scheduleId?: StringWithAggregatesFilter<"Appointment"> | string;
    slotId?: StringWithAggregatesFilter<"Appointment"> | string;
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | AppointmentStatus;
    approvedSlotStart?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string;
    approvedSlotEnd?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string;
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null;
    approvedBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string;
    tx_ref?: StringWithAggregatesFilter<"Appointment"> | string;
    hospitalId?: StringWithAggregatesFilter<"Appointment"> | string;
    isPaid?: BoolWithAggregatesFilter<"Appointment"> | boolean;
};
type AppointmentCreateInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentCreateManyInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
};
type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    scheduleId?: SortOrder;
    slotId?: SortOrder;
    status?: SortOrder;
    approvedSlotStart?: SortOrder;
    approvedSlotEnd?: SortOrder;
    notes?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tx_ref?: SortOrder;
    hospitalId?: SortOrder;
    isPaid?: SortOrder;
};
type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    scheduleId?: SortOrder;
    slotId?: SortOrder;
    status?: SortOrder;
    approvedSlotStart?: SortOrder;
    approvedSlotEnd?: SortOrder;
    notes?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tx_ref?: SortOrder;
    hospitalId?: SortOrder;
    isPaid?: SortOrder;
};
type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    scheduleId?: SortOrder;
    slotId?: SortOrder;
    status?: SortOrder;
    approvedSlotStart?: SortOrder;
    approvedSlotEnd?: SortOrder;
    notes?: SortOrder;
    approvedBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tx_ref?: SortOrder;
    hospitalId?: SortOrder;
    isPaid?: SortOrder;
};
type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput;
    some?: AppointmentWhereInput;
    none?: AppointmentWhereInput;
};
type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput;
    isNot?: AppointmentWhereInput;
};
type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null;
    isNot?: AppointmentWhereInput | null;
};
type StringFieldUpdateOperationsInput = {
    set?: string;
};
type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: AppointmentStatus;
};
type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
};
type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
};
type BoolFieldUpdateOperationsInput = {
    set?: boolean;
};
type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[];
    createMany?: AppointmentCreateManyDoctorInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[];
    createMany?: AppointmentCreateManyDoctorInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: AppointmentCreateManyDoctorInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: AppointmentCreateManyDoctorInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentCreateNestedManyWithoutHospitalInput = {
    create?: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput> | AppointmentCreateWithoutHospitalInput[] | AppointmentUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutHospitalInput | AppointmentCreateOrConnectWithoutHospitalInput[];
    createMany?: AppointmentCreateManyHospitalInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput> | AppointmentCreateWithoutHospitalInput[] | AppointmentUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutHospitalInput | AppointmentCreateOrConnectWithoutHospitalInput[];
    createMany?: AppointmentCreateManyHospitalInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput> | AppointmentCreateWithoutHospitalInput[] | AppointmentUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutHospitalInput | AppointmentCreateOrConnectWithoutHospitalInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutHospitalInput | AppointmentUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: AppointmentCreateManyHospitalInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutHospitalInput | AppointmentUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutHospitalInput | AppointmentUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput> | AppointmentCreateWithoutHospitalInput[] | AppointmentUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutHospitalInput | AppointmentCreateOrConnectWithoutHospitalInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutHospitalInput | AppointmentUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: AppointmentCreateManyHospitalInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutHospitalInput | AppointmentUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutHospitalInput | AppointmentUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentCreateNestedOneWithoutPaymentInput = {
    create?: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: AppointmentCreateOrConnectWithoutPaymentInput;
    connect?: AppointmentWhereUniqueInput;
};
type AppointmentUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: AppointmentCreateOrConnectWithoutPaymentInput;
    upsert?: AppointmentUpsertWithoutPaymentInput;
    connect?: AppointmentWhereUniqueInput;
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutPaymentInput, AppointmentUpdateWithoutPaymentInput>, AppointmentUncheckedUpdateWithoutPaymentInput>;
};
type AppointmentCreateNestedManyWithoutScheduleInput = {
    create?: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput> | AppointmentCreateWithoutScheduleInput[] | AppointmentUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutScheduleInput | AppointmentCreateOrConnectWithoutScheduleInput[];
    createMany?: AppointmentCreateManyScheduleInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput> | AppointmentCreateWithoutScheduleInput[] | AppointmentUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutScheduleInput | AppointmentCreateOrConnectWithoutScheduleInput[];
    createMany?: AppointmentCreateManyScheduleInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput> | AppointmentCreateWithoutScheduleInput[] | AppointmentUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutScheduleInput | AppointmentCreateOrConnectWithoutScheduleInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutScheduleInput | AppointmentUpsertWithWhereUniqueWithoutScheduleInput[];
    createMany?: AppointmentCreateManyScheduleInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutScheduleInput | AppointmentUpdateWithWhereUniqueWithoutScheduleInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutScheduleInput | AppointmentUpdateManyWithWhereWithoutScheduleInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput> | AppointmentCreateWithoutScheduleInput[] | AppointmentUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutScheduleInput | AppointmentCreateOrConnectWithoutScheduleInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutScheduleInput | AppointmentUpsertWithWhereUniqueWithoutScheduleInput[];
    createMany?: AppointmentCreateManyScheduleInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutScheduleInput | AppointmentUpdateWithWhereUniqueWithoutScheduleInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutScheduleInput | AppointmentUpdateManyWithWhereWithoutScheduleInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentCreateNestedOneWithoutSlotInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>;
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput;
    connect?: AppointmentWhereUniqueInput;
};
type AppointmentUpdateOneWithoutSlotNestedInput = {
    create?: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>;
    connectOrCreate?: AppointmentCreateOrConnectWithoutSlotInput;
    upsert?: AppointmentUpsertWithoutSlotInput;
    disconnect?: AppointmentWhereInput | boolean;
    delete?: AppointmentWhereInput | boolean;
    connect?: AppointmentWhereUniqueInput;
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutSlotInput, AppointmentUpdateWithoutSlotInput>, AppointmentUncheckedUpdateWithoutSlotInput>;
};
type AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput> | AppointmentCreateWithoutUser_Appointment_approvedByToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput> | AppointmentCreateWithoutUser_Appointment_customerIdToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput> | AppointmentCreateWithoutUser_Appointment_approvedByToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput> | AppointmentCreateWithoutUser_Appointment_customerIdToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope;
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
};
type AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput> | AppointmentCreateWithoutUser_Appointment_approvedByToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput | AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput | AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput | AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput> | AppointmentCreateWithoutUser_Appointment_customerIdToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput | AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput | AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput | AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput> | AppointmentCreateWithoutUser_Appointment_approvedByToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput | AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput | AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput | AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput> | AppointmentCreateWithoutUser_Appointment_customerIdToUserInput[] | AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput[];
    connectOrCreate?: AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput | AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput[];
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput | AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput[];
    createMany?: AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope;
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[];
    update?: AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput | AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput[];
    updateMany?: AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput | AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput[];
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
};
type AppointmentCreateWithoutDoctorInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: string;
    customerId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>;
};
type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput;
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>;
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>;
};
type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput;
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>;
};
type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput;
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>;
};
type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
    OR?: AppointmentScalarWhereInput[];
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[];
    id?: StringFilter<"Appointment"> | string;
    customerId?: StringFilter<"Appointment"> | string;
    doctorId?: StringFilter<"Appointment"> | string;
    scheduleId?: StringFilter<"Appointment"> | string;
    slotId?: StringFilter<"Appointment"> | string;
    status?: EnumAppointmentStatusFilter<"Appointment"> | AppointmentStatus;
    approvedSlotStart?: DateTimeFilter<"Appointment"> | Date | string;
    approvedSlotEnd?: DateTimeFilter<"Appointment"> | Date | string;
    notes?: StringNullableFilter<"Appointment"> | string | null;
    approvedBy?: StringNullableFilter<"Appointment"> | string | null;
    createdAt?: DateTimeFilter<"Appointment"> | Date | string;
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string;
    tx_ref?: StringFilter<"Appointment"> | string;
    hospitalId?: StringFilter<"Appointment"> | string;
    isPaid?: BoolFilter<"Appointment"> | boolean;
};
type AppointmentCreateWithoutHospitalInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutHospitalInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutHospitalInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput>;
};
type AppointmentCreateManyHospitalInputEnvelope = {
    data: AppointmentCreateManyHospitalInput | AppointmentCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type AppointmentUpsertWithWhereUniqueWithoutHospitalInput = {
    where: AppointmentWhereUniqueInput;
    update: XOR<AppointmentUpdateWithoutHospitalInput, AppointmentUncheckedUpdateWithoutHospitalInput>;
    create: XOR<AppointmentCreateWithoutHospitalInput, AppointmentUncheckedCreateWithoutHospitalInput>;
};
type AppointmentUpdateWithWhereUniqueWithoutHospitalInput = {
    where: AppointmentWhereUniqueInput;
    data: XOR<AppointmentUpdateWithoutHospitalInput, AppointmentUncheckedUpdateWithoutHospitalInput>;
};
type AppointmentUpdateManyWithWhereWithoutHospitalInput = {
    where: AppointmentScalarWhereInput;
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutHospitalInput>;
};
type AppointmentCreateWithoutPaymentInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutPaymentInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutPaymentInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>;
};
type AppointmentUpsertWithoutPaymentInput = {
    update: XOR<AppointmentUpdateWithoutPaymentInput, AppointmentUncheckedUpdateWithoutPaymentInput>;
    create: XOR<AppointmentCreateWithoutPaymentInput, AppointmentUncheckedCreateWithoutPaymentInput>;
    where?: AppointmentWhereInput;
};
type AppointmentUpdateToOneWithWhereWithoutPaymentInput = {
    where?: AppointmentWhereInput;
    data: XOR<AppointmentUpdateWithoutPaymentInput, AppointmentUncheckedUpdateWithoutPaymentInput>;
};
type AppointmentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentCreateWithoutScheduleInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutScheduleInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutScheduleInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput>;
};
type AppointmentCreateManyScheduleInputEnvelope = {
    data: AppointmentCreateManyScheduleInput | AppointmentCreateManyScheduleInput[];
    skipDuplicates?: boolean;
};
type AppointmentUpsertWithWhereUniqueWithoutScheduleInput = {
    where: AppointmentWhereUniqueInput;
    update: XOR<AppointmentUpdateWithoutScheduleInput, AppointmentUncheckedUpdateWithoutScheduleInput>;
    create: XOR<AppointmentCreateWithoutScheduleInput, AppointmentUncheckedCreateWithoutScheduleInput>;
};
type AppointmentUpdateWithWhereUniqueWithoutScheduleInput = {
    where: AppointmentWhereUniqueInput;
    data: XOR<AppointmentUpdateWithoutScheduleInput, AppointmentUncheckedUpdateWithoutScheduleInput>;
};
type AppointmentUpdateManyWithWhereWithoutScheduleInput = {
    where: AppointmentScalarWhereInput;
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutScheduleInput>;
};
type AppointmentCreateWithoutSlotInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutSlotInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutSlotInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>;
};
type AppointmentUpsertWithoutSlotInput = {
    update: XOR<AppointmentUpdateWithoutSlotInput, AppointmentUncheckedUpdateWithoutSlotInput>;
    create: XOR<AppointmentCreateWithoutSlotInput, AppointmentUncheckedCreateWithoutSlotInput>;
    where?: AppointmentWhereInput;
};
type AppointmentUpdateToOneWithWhereWithoutSlotInput = {
    where?: AppointmentWhereInput;
    data: XOR<AppointmentUpdateWithoutSlotInput, AppointmentUncheckedUpdateWithoutSlotInput>;
};
type AppointmentUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentCreateWithoutUser_Appointment_approvedByToUserInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_customerIdToUser: UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput>;
};
type AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope = {
    data: AppointmentCreateManyUser_Appointment_approvedByToUserInput | AppointmentCreateManyUser_Appointment_approvedByToUserInput[];
    skipDuplicates?: boolean;
};
type AppointmentCreateWithoutUser_Appointment_customerIdToUserInput = {
    id?: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
    Doctor: DoctorCreateNestedOneWithoutAppointmentInput;
    Hospital: HospitalCreateNestedOneWithoutAppointmentInput;
    Schedule: ScheduleCreateNestedOneWithoutAppointmentInput;
    Payment?: PaymentCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotCreateNestedOneWithoutAppointmentInput;
};
type AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput = {
    id?: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
    Payment?: PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
    Slot?: SlotUncheckedCreateNestedOneWithoutAppointmentInput;
};
type AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput = {
    where: AppointmentWhereUniqueInput;
    create: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput>;
};
type AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope = {
    data: AppointmentCreateManyUser_Appointment_customerIdToUserInput | AppointmentCreateManyUser_Appointment_customerIdToUserInput[];
    skipDuplicates?: boolean;
};
type AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput = {
    where: AppointmentWhereUniqueInput;
    update: XOR<AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput>;
    create: XOR<AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput>;
};
type AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput = {
    where: AppointmentWhereUniqueInput;
    data: XOR<AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput, AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput>;
};
type AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput = {
    where: AppointmentScalarWhereInput;
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput>;
};
type AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput = {
    where: AppointmentWhereUniqueInput;
    update: XOR<AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput>;
    create: XOR<AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput>;
};
type AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput = {
    where: AppointmentWhereUniqueInput;
    data: XOR<AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput, AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput>;
};
type AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput = {
    where: AppointmentScalarWhereInput;
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput>;
};
type AppointmentCreateManyDoctorInput = {
    id?: string;
    customerId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
};
type AppointmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentCreateManyHospitalInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    isPaid?: boolean;
};
type AppointmentUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentCreateManyScheduleInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
};
type AppointmentUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentCreateManyUser_Appointment_approvedByToUserInput = {
    id?: string;
    customerId: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
};
type AppointmentCreateManyUser_Appointment_customerIdToUserInput = {
    id?: string;
    doctorId: string;
    scheduleId: string;
    slotId: string;
    status?: AppointmentStatus;
    approvedSlotStart: Date | string;
    approvedSlotEnd: Date | string;
    notes?: string | null;
    approvedBy?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tx_ref: string;
    hospitalId: string;
    isPaid?: boolean;
};
type AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_customerIdToUser?: UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    User_Appointment_approvedByToUser?: UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
    Payment?: PaymentUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
    Payment?: PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
    Slot?: SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
};
type AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotId?: StringFieldUpdateOperationsInput | string;
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus;
    approvedSlotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedSlotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tx_ref?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    isPaid?: BoolFieldUpdateOperationsInput | boolean;
};
type AppointmentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    scheduleId?: boolean;
    slotId?: boolean;
    status?: boolean;
    approvedSlotStart?: boolean;
    approvedSlotEnd?: boolean;
    notes?: boolean;
    approvedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    tx_ref?: boolean;
    hospitalId?: boolean;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
    Payment?: boolean | Appointment$PaymentArgs<ExtArgs>;
    Slot?: boolean | Appointment$SlotArgs<ExtArgs>;
}, ExtArgs["result"]["appointment"]>;
type AppointmentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    scheduleId?: boolean;
    slotId?: boolean;
    status?: boolean;
    approvedSlotStart?: boolean;
    approvedSlotEnd?: boolean;
    notes?: boolean;
    approvedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    tx_ref?: boolean;
    hospitalId?: boolean;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["appointment"]>;
type AppointmentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    scheduleId?: boolean;
    slotId?: boolean;
    status?: boolean;
    approvedSlotStart?: boolean;
    approvedSlotEnd?: boolean;
    notes?: boolean;
    approvedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    tx_ref?: boolean;
    hospitalId?: boolean;
    isPaid?: boolean;
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["appointment"]>;
type AppointmentSelectScalar = {
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    scheduleId?: boolean;
    slotId?: boolean;
    status?: boolean;
    approvedSlotStart?: boolean;
    approvedSlotEnd?: boolean;
    notes?: boolean;
    approvedBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    tx_ref?: boolean;
    hospitalId?: boolean;
    isPaid?: boolean;
};
type AppointmentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "customerId" | "doctorId" | "scheduleId" | "slotId" | "status" | "approvedSlotStart" | "approvedSlotEnd" | "notes" | "approvedBy" | "createdAt" | "updatedAt" | "tx_ref" | "hospitalId" | "isPaid", ExtArgs["result"]["appointment"]>;
type AppointmentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
    Payment?: boolean | Appointment$PaymentArgs<ExtArgs>;
    Slot?: boolean | Appointment$SlotArgs<ExtArgs>;
};
type AppointmentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
};
type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User_Appointment_approvedByToUser?: boolean | Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
    User_Appointment_customerIdToUser?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
};
type $AppointmentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Appointment";
    objects: {
        User_Appointment_approvedByToUser: $UserPayload<ExtArgs> | null;
        User_Appointment_customerIdToUser: $UserPayload<ExtArgs>;
        Doctor: $DoctorPayload<ExtArgs>;
        Hospital: $HospitalPayload<ExtArgs>;
        Schedule: $SchedulePayload<ExtArgs>;
        Payment: $PaymentPayload<ExtArgs> | null;
        Slot: $SlotPayload<ExtArgs> | null;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        customerId: string;
        doctorId: string;
        scheduleId: string;
        slotId: string;
        status: AppointmentStatus;
        approvedSlotStart: Date;
        approvedSlotEnd: Date;
        notes: string | null;
        approvedBy: string | null;
        createdAt: Date;
        updatedAt: Date;
        tx_ref: string;
        hospitalId: string;
        isPaid: boolean;
    }, ExtArgs["result"]["appointment"]>;
    composites: {};
};
type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = runtime.Types.Result.GetResult<$AppointmentPayload, S>;
type AppointmentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AppointmentCountAggregateInputType | true;
};
interface AppointmentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Appointment'];
        meta: {
            name: 'Appointment';
        };
    };
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     *
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     *
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     *
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(args?: Subset<T, AppointmentCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], AppointmentCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): PrismaPromise<GetAppointmentAggregateType<T>>;
    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends AppointmentGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: AppointmentGroupByArgs['orderBy'];
    } : {
        orderBy?: AppointmentGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Appointment model
     */
    readonly fields: AppointmentFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Appointment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User_Appointment_approvedByToUser<T extends Appointment$User_Appointment_approvedByToUserArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    User_Appointment_customerIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Payment<T extends Appointment$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$PaymentArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    Slot<T extends Appointment$SlotArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$SlotArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Appointment model
 */
interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>;
    readonly customerId: FieldRef<"Appointment", 'String'>;
    readonly doctorId: FieldRef<"Appointment", 'String'>;
    readonly scheduleId: FieldRef<"Appointment", 'String'>;
    readonly slotId: FieldRef<"Appointment", 'String'>;
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>;
    readonly approvedSlotStart: FieldRef<"Appointment", 'DateTime'>;
    readonly approvedSlotEnd: FieldRef<"Appointment", 'DateTime'>;
    readonly notes: FieldRef<"Appointment", 'String'>;
    readonly approvedBy: FieldRef<"Appointment", 'String'>;
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>;
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>;
    readonly tx_ref: FieldRef<"Appointment", 'String'>;
    readonly hospitalId: FieldRef<"Appointment", 'String'>;
    readonly isPaid: FieldRef<"Appointment", 'Boolean'>;
}
/**
 * Appointment findUnique
 */
type AppointmentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput;
};
/**
 * Appointment findUniqueOrThrow
 */
type AppointmentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput;
};
/**
 * Appointment findFirst
 */
type AppointmentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Appointments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Appointments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Appointment findFirstOrThrow
 */
type AppointmentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Appointments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Appointments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Appointment findMany
 */
type AppointmentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Appointments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Appointments.
     */
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Appointment create
 */
type AppointmentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>;
};
/**
 * Appointment createMany
 */
type AppointmentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Appointment createManyAndReturn
 */
type AppointmentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Appointment update
 */
type AppointmentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>;
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput;
};
/**
 * Appointment updateMany
 */
type AppointmentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>;
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput;
    /**
     * Limit how many Appointments to update.
     */
    limit?: number;
};
/**
 * Appointment updateManyAndReturn
 */
type AppointmentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>;
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput;
    /**
     * Limit how many Appointments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Appointment upsert
 */
type AppointmentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput;
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>;
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>;
};
/**
 * Appointment delete
 */
type AppointmentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput;
};
/**
 * Appointment deleteMany
 */
type AppointmentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput;
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number;
};
/**
 * Appointment.User_Appointment_approvedByToUser
 */
type Appointment$User_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
};
/**
 * Appointment.Payment
 */
type Appointment$PaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
};
/**
 * Appointment.Slot
 */
type Appointment$SlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    where?: SlotWhereInput;
};
/**
 * Appointment without action
 */
type AppointmentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
};

/**
 * Model AuditLog
 *
 */
type AuditLogModel = runtime.Types.Result.DefaultSelection<$AuditLogPayload>;
type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
};
type AuditLogMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type AuditLogMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type AuditLogCountAggregateOutputType = {
    id: number;
    userId: number;
    action: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type AuditLogMinAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    createdAt?: true;
    updatedAt?: true;
};
type AuditLogMaxAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    createdAt?: true;
    updatedAt?: true;
};
type AuditLogCountAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type AuditLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType;
};
type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateAuditLog[P]> : GetScalarType<T[P], AggregateAuditLog[P]>;
};
type AuditLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
};
type AuditLogGroupByOutputType = {
    id: string;
    userId: string;
    action: string;
    metadata: runtime.JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
};
type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = PrismaPromise<Array<PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], AuditLogGroupByOutputType[P]> : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
}>>;
type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<"AuditLog"> | string;
    userId?: StringFilter<"AuditLog"> | string;
    action?: StringFilter<"AuditLog"> | string;
    metadata?: JsonNullableFilter<"AuditLog">;
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
    updatedAt?: DateTimeFilter<"AuditLog"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    User?: UserOrderByWithRelationInput;
};
type AuditLogWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    userId?: StringFilter<"AuditLog"> | string;
    action?: StringFilter<"AuditLog"> | string;
    metadata?: JsonNullableFilter<"AuditLog">;
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
    updatedAt?: DateTimeFilter<"AuditLog"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id">;
type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
};
type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"AuditLog"> | string;
    userId?: StringWithAggregatesFilter<"AuditLog"> | string;
    action?: StringWithAggregatesFilter<"AuditLog"> | string;
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">;
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string;
};
type AuditLogCreateInput = {
    id?: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutAuditLogInput;
};
type AuditLogUncheckedCreateInput = {
    id?: string;
    userId: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutAuditLogNestedInput;
};
type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogCreateManyInput = {
    id?: string;
    userId: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
};
type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
};
type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
};
type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
};
type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
};
type AuditLogCreateWithoutUserInput = {
    id?: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
};
type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
};
type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
};
type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>;
};
type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<"AuditLog"> | string;
    userId?: StringFilter<"AuditLog"> | string;
    action?: StringFilter<"AuditLog"> | string;
    metadata?: JsonNullableFilter<"AuditLog">;
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string;
    updatedAt?: DateTimeFilter<"AuditLog"> | Date | string;
};
type AuditLogCreateManyUserInput = {
    id?: string;
    action: string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    metadata?: NullableJsonNullValueInput | runtime.InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AuditLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["auditLog"]>;
type AuditLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["auditLog"]>;
type AuditLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["auditLog"]>;
type AuditLogSelectScalar = {
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type AuditLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "action" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["auditLog"]>;
type AuditLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type AuditLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $AuditLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "AuditLog";
    objects: {
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        userId: string;
        action: string;
        metadata: runtime.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["auditLog"]>;
    composites: {};
};
type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = runtime.Types.Result.GetResult<$AuditLogPayload, S>;
type AuditLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AuditLogCountAggregateInputType | true;
};
interface AuditLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['AuditLog'];
        meta: {
            name: 'AuditLog';
        };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(args?: Subset<T, AuditLogCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], AuditLogCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): PrismaPromise<GetAuditLogAggregateType<T>>;
    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends AuditLogGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: AuditLogGroupByArgs['orderBy'];
    } : {
        orderBy?: AuditLogGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for AuditLog.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the AuditLog model
 */
interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>;
    readonly userId: FieldRef<"AuditLog", 'String'>;
    readonly action: FieldRef<"AuditLog", 'String'>;
    readonly metadata: FieldRef<"AuditLog", 'Json'>;
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>;
    readonly updatedAt: FieldRef<"AuditLog", 'DateTime'>;
}
/**
 * AuditLog findUnique
 */
type AuditLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
};
/**
 * AuditLog findUniqueOrThrow
 */
type AuditLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
};
/**
 * AuditLog findFirst
 */
type AuditLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
};
/**
 * AuditLog findFirstOrThrow
 */
type AuditLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
};
/**
 * AuditLog findMany
 */
type AuditLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
};
/**
 * AuditLog create
 */
type AuditLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
};
/**
 * AuditLog createMany
 */
type AuditLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * AuditLog createManyAndReturn
 */
type AuditLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * AuditLog update
 */
type AuditLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
};
/**
 * AuditLog updateMany
 */
type AuditLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
};
/**
 * AuditLog updateManyAndReturn
 */
type AuditLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * AuditLog upsert
 */
type AuditLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
};
/**
 * AuditLog delete
 */
type AuditLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
};
/**
 * AuditLog deleteMany
 */
type AuditLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number;
};
/**
 * AuditLog without action
 */
type AuditLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
};

/**
 * Model Doctor
 *
 */
type DoctorModel = runtime.Types.Result.DefaultSelection<$DoctorPayload>;
type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null;
    _avg: DoctorAvgAggregateOutputType | null;
    _sum: DoctorSumAggregateOutputType | null;
    _min: DoctorMinAggregateOutputType | null;
    _max: DoctorMaxAggregateOutputType | null;
};
type DoctorAvgAggregateOutputType = {
    yearsOfExperience: number | null;
};
type DoctorSumAggregateOutputType = {
    yearsOfExperience: number | null;
};
type DoctorMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    yearsOfExperience: number | null;
    bio: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isDeactivated: boolean | null;
};
type DoctorMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    yearsOfExperience: number | null;
    bio: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isDeactivated: boolean | null;
};
type DoctorCountAggregateOutputType = {
    id: number;
    userId: number;
    yearsOfExperience: number;
    bio: number;
    createdAt: number;
    updatedAt: number;
    isDeactivated: number;
    _all: number;
};
type DoctorAvgAggregateInputType = {
    yearsOfExperience?: true;
};
type DoctorSumAggregateInputType = {
    yearsOfExperience?: true;
};
type DoctorMinAggregateInputType = {
    id?: true;
    userId?: true;
    yearsOfExperience?: true;
    bio?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
};
type DoctorMaxAggregateInputType = {
    id?: true;
    userId?: true;
    yearsOfExperience?: true;
    bio?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
};
type DoctorCountAggregateInputType = {
    id?: true;
    userId?: true;
    yearsOfExperience?: true;
    bio?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
    _all?: true;
};
type DoctorAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Doctors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Doctors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType;
};
type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
    [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateDoctor[P]> : GetScalarType<T[P], AggregateDoctor[P]>;
};
type DoctorGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[];
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum;
    having?: DoctorScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DoctorCountAggregateInputType | true;
    _avg?: DoctorAvgAggregateInputType;
    _sum?: DoctorSumAggregateInputType;
    _min?: DoctorMinAggregateInputType;
    _max?: DoctorMaxAggregateInputType;
};
type DoctorGroupByOutputType = {
    id: string;
    userId: string;
    yearsOfExperience: number | null;
    bio: string | null;
    createdAt: Date;
    updatedAt: Date;
    isDeactivated: boolean;
    _count: DoctorCountAggregateOutputType | null;
    _avg: DoctorAvgAggregateOutputType | null;
    _sum: DoctorSumAggregateOutputType | null;
    _min: DoctorMinAggregateOutputType | null;
    _max: DoctorMaxAggregateOutputType | null;
};
type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = PrismaPromise<Array<PickEnumerable<DoctorGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], DoctorGroupByOutputType[P]> : GetScalarType<T[P], DoctorGroupByOutputType[P]>;
}>>;
type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[];
    OR?: DoctorWhereInput[];
    NOT?: DoctorWhereInput | DoctorWhereInput[];
    id?: StringFilter<"Doctor"> | string;
    userId?: StringFilter<"Doctor"> | string;
    yearsOfExperience?: IntNullableFilter<"Doctor"> | number | null;
    bio?: StringNullableFilter<"Doctor"> | string | null;
    createdAt?: DateTimeFilter<"Doctor"> | Date | string;
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string;
    isDeactivated?: BoolFilter<"Doctor"> | boolean;
    Appointment?: AppointmentListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    DoctorHospitalProfile?: DoctorHospitalProfileListRelationFilter;
    DoctorSpecialization?: DoctorSpecializationListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
};
type DoctorOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    Appointment?: AppointmentOrderByRelationAggregateInput;
    User?: UserOrderByWithRelationInput;
    DoctorHospitalProfile?: DoctorHospitalProfileOrderByRelationAggregateInput;
    DoctorSpecialization?: DoctorSpecializationOrderByRelationAggregateInput;
    Review?: ReviewOrderByRelationAggregateInput;
    SavedDoctorHospital?: SavedDoctorHospitalOrderByRelationAggregateInput;
    Schedule?: ScheduleOrderByRelationAggregateInput;
};
type DoctorWhereUniqueInput = AtLeast<{
    id?: string;
    userId?: string;
    AND?: DoctorWhereInput | DoctorWhereInput[];
    OR?: DoctorWhereInput[];
    NOT?: DoctorWhereInput | DoctorWhereInput[];
    yearsOfExperience?: IntNullableFilter<"Doctor"> | number | null;
    bio?: StringNullableFilter<"Doctor"> | string | null;
    createdAt?: DateTimeFilter<"Doctor"> | Date | string;
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string;
    isDeactivated?: BoolFilter<"Doctor"> | boolean;
    Appointment?: AppointmentListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    DoctorHospitalProfile?: DoctorHospitalProfileListRelationFilter;
    DoctorSpecialization?: DoctorSpecializationListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
}, "id" | "userId">;
type DoctorOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    _count?: DoctorCountOrderByAggregateInput;
    _avg?: DoctorAvgOrderByAggregateInput;
    _max?: DoctorMaxOrderByAggregateInput;
    _min?: DoctorMinOrderByAggregateInput;
    _sum?: DoctorSumOrderByAggregateInput;
};
type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[];
    OR?: DoctorScalarWhereWithAggregatesInput[];
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Doctor"> | string;
    userId?: StringWithAggregatesFilter<"Doctor"> | string;
    yearsOfExperience?: IntNullableWithAggregatesFilter<"Doctor"> | number | null;
    bio?: StringNullableWithAggregatesFilter<"Doctor"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string;
    isDeactivated?: BoolWithAggregatesFilter<"Doctor"> | boolean;
};
type DoctorCreateInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateManyInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
};
type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
};
type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
};
type DoctorScalarRelationFilter = {
    is?: DoctorWhereInput;
    isNot?: DoctorWhereInput;
};
type DoctorCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
};
type DoctorAvgOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
};
type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
};
type DoctorMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
};
type DoctorSumOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
};
type DoctorNullableScalarRelationFilter = {
    is?: DoctorWhereInput | null;
    isNot?: DoctorWhereInput | null;
};
type DoctorCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<DoctorCreateWithoutAppointmentInput, DoctorUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentInput, DoctorUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentInput;
    upsert?: DoctorUpsertWithoutAppointmentInput;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAppointmentInput, DoctorUpdateWithoutAppointmentInput>, DoctorUncheckedUpdateWithoutAppointmentInput>;
};
type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
};
type DoctorCreateNestedOneWithoutDoctorHospitalProfileInput = {
    create?: XOR<DoctorCreateWithoutDoctorHospitalProfileInput, DoctorUncheckedCreateWithoutDoctorHospitalProfileInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorHospitalProfileInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput = {
    create?: XOR<DoctorCreateWithoutDoctorHospitalProfileInput, DoctorUncheckedCreateWithoutDoctorHospitalProfileInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorHospitalProfileInput;
    upsert?: DoctorUpsertWithoutDoctorHospitalProfileInput;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput, DoctorUpdateWithoutDoctorHospitalProfileInput>, DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput>;
};
type DoctorCreateNestedOneWithoutDoctorSpecializationInput = {
    create?: XOR<DoctorCreateWithoutDoctorSpecializationInput, DoctorUncheckedCreateWithoutDoctorSpecializationInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorSpecializationInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput = {
    create?: XOR<DoctorCreateWithoutDoctorSpecializationInput, DoctorUncheckedCreateWithoutDoctorSpecializationInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorSpecializationInput;
    upsert?: DoctorUpsertWithoutDoctorSpecializationInput;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput, DoctorUpdateWithoutDoctorSpecializationInput>, DoctorUncheckedUpdateWithoutDoctorSpecializationInput>;
};
type DoctorCreateNestedOneWithoutReviewInput = {
    create?: XOR<DoctorCreateWithoutReviewInput, DoctorUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutReviewInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneWithoutReviewNestedInput = {
    create?: XOR<DoctorCreateWithoutReviewInput, DoctorUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutReviewInput;
    upsert?: DoctorUpsertWithoutReviewInput;
    disconnect?: DoctorWhereInput | boolean;
    delete?: DoctorWhereInput | boolean;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutReviewInput, DoctorUpdateWithoutReviewInput>, DoctorUncheckedUpdateWithoutReviewInput>;
};
type DoctorCreateNestedOneWithoutSavedDoctorHospitalInput = {
    create?: XOR<DoctorCreateWithoutSavedDoctorHospitalInput, DoctorUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutSavedDoctorHospitalInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput = {
    create?: XOR<DoctorCreateWithoutSavedDoctorHospitalInput, DoctorUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutSavedDoctorHospitalInput;
    upsert?: DoctorUpsertWithoutSavedDoctorHospitalInput;
    disconnect?: DoctorWhereInput | boolean;
    delete?: DoctorWhereInput | boolean;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, DoctorUpdateWithoutSavedDoctorHospitalInput>, DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type DoctorCreateNestedOneWithoutScheduleInput = {
    create?: XOR<DoctorCreateWithoutScheduleInput, DoctorUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutScheduleInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<DoctorCreateWithoutScheduleInput, DoctorUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutScheduleInput;
    upsert?: DoctorUpsertWithoutScheduleInput;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutScheduleInput, DoctorUpdateWithoutScheduleInput>, DoctorUncheckedUpdateWithoutScheduleInput>;
};
type DoctorCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput;
    connect?: DoctorWhereUniqueInput;
};
type DoctorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput;
    upsert?: DoctorUpsertWithoutUserInput;
    disconnect?: DoctorWhereInput | boolean;
    delete?: DoctorWhereInput | boolean;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>;
};
type DoctorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput;
    upsert?: DoctorUpsertWithoutUserInput;
    disconnect?: DoctorWhereInput | boolean;
    delete?: DoctorWhereInput | boolean;
    connect?: DoctorWhereUniqueInput;
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>;
};
type DoctorCreateWithoutAppointmentInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutAppointmentInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutAppointmentInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutAppointmentInput, DoctorUncheckedCreateWithoutAppointmentInput>;
};
type DoctorUpsertWithoutAppointmentInput = {
    update: XOR<DoctorUpdateWithoutAppointmentInput, DoctorUncheckedUpdateWithoutAppointmentInput>;
    create: XOR<DoctorCreateWithoutAppointmentInput, DoctorUncheckedCreateWithoutAppointmentInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutAppointmentInput, DoctorUncheckedUpdateWithoutAppointmentInput>;
};
type DoctorUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutDoctorHospitalProfileInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutDoctorHospitalProfileInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutDoctorHospitalProfileInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutDoctorHospitalProfileInput, DoctorUncheckedCreateWithoutDoctorHospitalProfileInput>;
};
type DoctorUpsertWithoutDoctorHospitalProfileInput = {
    update: XOR<DoctorUpdateWithoutDoctorHospitalProfileInput, DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput>;
    create: XOR<DoctorCreateWithoutDoctorHospitalProfileInput, DoctorUncheckedCreateWithoutDoctorHospitalProfileInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutDoctorHospitalProfileInput, DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput>;
};
type DoctorUpdateWithoutDoctorHospitalProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutDoctorSpecializationInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutDoctorSpecializationInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutDoctorSpecializationInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutDoctorSpecializationInput, DoctorUncheckedCreateWithoutDoctorSpecializationInput>;
};
type DoctorUpsertWithoutDoctorSpecializationInput = {
    update: XOR<DoctorUpdateWithoutDoctorSpecializationInput, DoctorUncheckedUpdateWithoutDoctorSpecializationInput>;
    create: XOR<DoctorCreateWithoutDoctorSpecializationInput, DoctorUncheckedCreateWithoutDoctorSpecializationInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutDoctorSpecializationInput, DoctorUncheckedUpdateWithoutDoctorSpecializationInput>;
};
type DoctorUpdateWithoutDoctorSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutDoctorSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutReviewInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutReviewInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutReviewInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutReviewInput, DoctorUncheckedCreateWithoutReviewInput>;
};
type DoctorUpsertWithoutReviewInput = {
    update: XOR<DoctorUpdateWithoutReviewInput, DoctorUncheckedUpdateWithoutReviewInput>;
    create: XOR<DoctorCreateWithoutReviewInput, DoctorUncheckedCreateWithoutReviewInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutReviewInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutReviewInput, DoctorUncheckedUpdateWithoutReviewInput>;
};
type DoctorUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutSavedDoctorHospitalInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutSavedDoctorHospitalInput, DoctorUncheckedCreateWithoutSavedDoctorHospitalInput>;
};
type DoctorUpsertWithoutSavedDoctorHospitalInput = {
    update: XOR<DoctorUpdateWithoutSavedDoctorHospitalInput, DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput>;
    create: XOR<DoctorCreateWithoutSavedDoctorHospitalInput, DoctorUncheckedCreateWithoutSavedDoctorHospitalInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutSavedDoctorHospitalInput, DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type DoctorUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutScheduleInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    User: UserCreateNestedOneWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutScheduleInput = {
    id?: string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutScheduleInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutScheduleInput, DoctorUncheckedCreateWithoutScheduleInput>;
};
type DoctorUpsertWithoutScheduleInput = {
    update: XOR<DoctorUpdateWithoutScheduleInput, DoctorUncheckedUpdateWithoutScheduleInput>;
    create: XOR<DoctorCreateWithoutScheduleInput, DoctorUncheckedCreateWithoutScheduleInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutScheduleInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutScheduleInput, DoctorUncheckedUpdateWithoutScheduleInput>;
};
type DoctorUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
};
type DoctorCreateWithoutUserInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutDoctorInput;
    Review?: ReviewCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleCreateNestedManyWithoutDoctorInput;
};
type DoctorUncheckedCreateWithoutUserInput = {
    id?: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutDoctorInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
};
type DoctorCreateOrConnectWithoutUserInput = {
    where: DoctorWhereUniqueInput;
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
};
type DoctorUpsertWithoutUserInput = {
    update: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>;
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>;
    where?: DoctorWhereInput;
};
type DoctorUpdateToOneWithWhereWithoutUserInput = {
    where?: DoctorWhereInput;
    data: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>;
};
type DoctorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUpdateManyWithoutDoctorNestedInput;
};
type DoctorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    Appointment?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
};
/**
 * Count Type DoctorCountOutputType
 */
type DoctorCountOutputType = {
    Appointment: number;
    DoctorHospitalProfile: number;
    DoctorSpecialization: number;
    Review: number;
    SavedDoctorHospital: number;
    Schedule: number;
};
type DoctorCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | DoctorCountOutputTypeCountAppointmentArgs;
    DoctorHospitalProfile?: boolean | DoctorCountOutputTypeCountDoctorHospitalProfileArgs;
    DoctorSpecialization?: boolean | DoctorCountOutputTypeCountDoctorSpecializationArgs;
    Review?: boolean | DoctorCountOutputTypeCountReviewArgs;
    SavedDoctorHospital?: boolean | DoctorCountOutputTypeCountSavedDoctorHospitalArgs;
    Schedule?: boolean | DoctorCountOutputTypeCountScheduleArgs;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorHospitalProfileWhereInput;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountDoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorSpecializationWhereInput;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ReviewWhereInput;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SavedDoctorHospitalWhereInput;
};
/**
 * DoctorCountOutputType without action
 */
type DoctorCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput;
};
type DoctorSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    Appointment?: boolean | Doctor$AppointmentArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    DoctorHospitalProfile?: boolean | Doctor$DoctorHospitalProfileArgs<ExtArgs>;
    DoctorSpecialization?: boolean | Doctor$DoctorSpecializationArgs<ExtArgs>;
    Review?: boolean | Doctor$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | Doctor$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | Doctor$ScheduleArgs<ExtArgs>;
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctor"]>;
type DoctorSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctor"]>;
type DoctorSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctor"]>;
type DoctorSelectScalar = {
    id?: boolean;
    userId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
};
type DoctorOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "yearsOfExperience" | "bio" | "createdAt" | "updatedAt" | "isDeactivated", ExtArgs["result"]["doctor"]>;
type DoctorInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Doctor$AppointmentArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    DoctorHospitalProfile?: boolean | Doctor$DoctorHospitalProfileArgs<ExtArgs>;
    DoctorSpecialization?: boolean | Doctor$DoctorSpecializationArgs<ExtArgs>;
    Review?: boolean | Doctor$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | Doctor$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | Doctor$ScheduleArgs<ExtArgs>;
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>;
};
type DoctorIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type DoctorIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $DoctorPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Doctor";
    objects: {
        Appointment: $AppointmentPayload<ExtArgs>[];
        User: $UserPayload<ExtArgs>;
        DoctorHospitalProfile: $DoctorHospitalProfilePayload<ExtArgs>[];
        DoctorSpecialization: $DoctorSpecializationPayload<ExtArgs>[];
        Review: $ReviewPayload<ExtArgs>[];
        SavedDoctorHospital: $SavedDoctorHospitalPayload<ExtArgs>[];
        Schedule: $SchedulePayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        userId: string;
        yearsOfExperience: number | null;
        bio: string | null;
        createdAt: Date;
        updatedAt: Date;
        isDeactivated: boolean;
    }, ExtArgs["result"]["doctor"]>;
    composites: {};
};
type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = runtime.Types.Result.GetResult<$DoctorPayload, S>;
type DoctorCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DoctorCountAggregateInputType | true;
};
interface DoctorDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Doctor'];
        meta: {
            name: 'Doctor';
        };
    };
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     *
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     *
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     *
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Doctors and returns the data updated in the database.
     * @param {DoctorUpdateManyAndReturnArgs} args - Arguments to update many Doctors.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DoctorUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(args?: Subset<T, DoctorCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], DoctorCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): PrismaPromise<GetDoctorAggregateType<T>>;
    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends DoctorGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: DoctorGroupByArgs['orderBy'];
    } : {
        orderBy?: DoctorGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Doctor model
     */
    readonly fields: DoctorFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Doctor.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__DoctorClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment<T extends Doctor$AppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$AppointmentArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    DoctorHospitalProfile<T extends Doctor$DoctorHospitalProfileArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$DoctorHospitalProfileArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    DoctorSpecialization<T extends Doctor$DoctorSpecializationArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$DoctorSpecializationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Review<T extends Doctor$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$ReviewArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    SavedDoctorHospital<T extends Doctor$SavedDoctorHospitalArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$SavedDoctorHospitalArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Schedule<T extends Doctor$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$ScheduleArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Doctor model
 */
interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'String'>;
    readonly userId: FieldRef<"Doctor", 'String'>;
    readonly yearsOfExperience: FieldRef<"Doctor", 'Int'>;
    readonly bio: FieldRef<"Doctor", 'String'>;
    readonly createdAt: FieldRef<"Doctor", 'DateTime'>;
    readonly updatedAt: FieldRef<"Doctor", 'DateTime'>;
    readonly isDeactivated: FieldRef<"Doctor", 'Boolean'>;
}
/**
 * Doctor findUnique
 */
type DoctorFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput;
};
/**
 * Doctor findUniqueOrThrow
 */
type DoctorFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput;
};
/**
 * Doctor findFirst
 */
type DoctorFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Doctors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Doctors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[];
};
/**
 * Doctor findFirstOrThrow
 */
type DoctorFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Doctors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Doctors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[];
};
/**
 * Doctor findMany
 */
type DoctorFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Doctors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Doctors.
     */
    skip?: number;
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[];
};
/**
 * Doctor create
 */
type DoctorCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>;
};
/**
 * Doctor createMany
 */
type DoctorCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Doctor createManyAndReturn
 */
type DoctorCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Doctor update
 */
type DoctorUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>;
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput;
};
/**
 * Doctor updateMany
 */
type DoctorUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>;
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput;
    /**
     * Limit how many Doctors to update.
     */
    limit?: number;
};
/**
 * Doctor updateManyAndReturn
 */
type DoctorUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>;
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput;
    /**
     * Limit how many Doctors to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Doctor upsert
 */
type DoctorUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput;
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>;
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>;
};
/**
 * Doctor delete
 */
type DoctorDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput;
};
/**
 * Doctor deleteMany
 */
type DoctorDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput;
    /**
     * Limit how many Doctors to delete.
     */
    limit?: number;
};
/**
 * Doctor.Appointment
 */
type Doctor$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    cursor?: AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Doctor.DoctorHospitalProfile
 */
type Doctor$DoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    where?: DoctorHospitalProfileWhereInput;
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorHospitalProfileScalarFieldEnum | DoctorHospitalProfileScalarFieldEnum[];
};
/**
 * Doctor.DoctorSpecialization
 */
type Doctor$DoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    where?: DoctorSpecializationWhereInput;
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    cursor?: DoctorSpecializationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorSpecializationScalarFieldEnum | DoctorSpecializationScalarFieldEnum[];
};
/**
 * Doctor.Review
 */
type Doctor$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * Doctor.SavedDoctorHospital
 */
type Doctor$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    where?: SavedDoctorHospitalWhereInput;
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * Doctor.Schedule
 */
type Doctor$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    cursor?: ScheduleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * Doctor without action
 */
type DoctorDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
};

/**
 * Model DoctorApplication
 *
 */
type DoctorApplicationModel = runtime.Types.Result.DefaultSelection<$DoctorApplicationPayload>;
type AggregateDoctorApplication = {
    _count: DoctorApplicationCountAggregateOutputType | null;
    _avg: DoctorApplicationAvgAggregateOutputType | null;
    _sum: DoctorApplicationSumAggregateOutputType | null;
    _min: DoctorApplicationMinAggregateOutputType | null;
    _max: DoctorApplicationMaxAggregateOutputType | null;
};
type DoctorApplicationAvgAggregateOutputType = {
    yearsOfExperience: number | null;
};
type DoctorApplicationSumAggregateOutputType = {
    yearsOfExperience: number | null;
};
type DoctorApplicationMinAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
    hospitalId: string | null;
    yearsOfExperience: number | null;
    bio: string | null;
    status: DoctorApplicationStatus | null;
};
type DoctorApplicationMaxAggregateOutputType = {
    id: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
    hospitalId: string | null;
    yearsOfExperience: number | null;
    bio: string | null;
    status: DoctorApplicationStatus | null;
};
type DoctorApplicationCountAggregateOutputType = {
    id: number;
    createdAt: number;
    updatedAt: number;
    userId: number;
    hospitalId: number;
    yearsOfExperience: number;
    bio: number;
    status: number;
    specializationIds: number;
    _all: number;
};
type DoctorApplicationAvgAggregateInputType = {
    yearsOfExperience?: true;
};
type DoctorApplicationSumAggregateInputType = {
    yearsOfExperience?: true;
};
type DoctorApplicationMinAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
    hospitalId?: true;
    yearsOfExperience?: true;
    bio?: true;
    status?: true;
};
type DoctorApplicationMaxAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
    hospitalId?: true;
    yearsOfExperience?: true;
    bio?: true;
    status?: true;
};
type DoctorApplicationCountAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
    hospitalId?: true;
    yearsOfExperience?: true;
    bio?: true;
    status?: true;
    specializationIds?: true;
    _all?: true;
};
type DoctorApplicationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorApplication to aggregate.
     */
    where?: DoctorApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorApplications to fetch.
     */
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DoctorApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorApplications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorApplications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DoctorApplications
    **/
    _count?: true | DoctorApplicationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: DoctorApplicationAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: DoctorApplicationSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DoctorApplicationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DoctorApplicationMaxAggregateInputType;
};
type GetDoctorApplicationAggregateType<T extends DoctorApplicationAggregateArgs> = {
    [P in keyof T & keyof AggregateDoctorApplication]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateDoctorApplication[P]> : GetScalarType<T[P], AggregateDoctorApplication[P]>;
};
type DoctorApplicationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorApplicationWhereInput;
    orderBy?: DoctorApplicationOrderByWithAggregationInput | DoctorApplicationOrderByWithAggregationInput[];
    by: DoctorApplicationScalarFieldEnum[] | DoctorApplicationScalarFieldEnum;
    having?: DoctorApplicationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DoctorApplicationCountAggregateInputType | true;
    _avg?: DoctorApplicationAvgAggregateInputType;
    _sum?: DoctorApplicationSumAggregateInputType;
    _min?: DoctorApplicationMinAggregateInputType;
    _max?: DoctorApplicationMaxAggregateInputType;
};
type DoctorApplicationGroupByOutputType = {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    userId: string;
    hospitalId: string;
    yearsOfExperience: number | null;
    bio: string | null;
    status: DoctorApplicationStatus;
    specializationIds: string[];
    _count: DoctorApplicationCountAggregateOutputType | null;
    _avg: DoctorApplicationAvgAggregateOutputType | null;
    _sum: DoctorApplicationSumAggregateOutputType | null;
    _min: DoctorApplicationMinAggregateOutputType | null;
    _max: DoctorApplicationMaxAggregateOutputType | null;
};
type GetDoctorApplicationGroupByPayload<T extends DoctorApplicationGroupByArgs> = PrismaPromise<Array<PickEnumerable<DoctorApplicationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof DoctorApplicationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], DoctorApplicationGroupByOutputType[P]> : GetScalarType<T[P], DoctorApplicationGroupByOutputType[P]>;
}>>;
type DoctorApplicationWhereInput = {
    AND?: DoctorApplicationWhereInput | DoctorApplicationWhereInput[];
    OR?: DoctorApplicationWhereInput[];
    NOT?: DoctorApplicationWhereInput | DoctorApplicationWhereInput[];
    id?: StringFilter<"DoctorApplication"> | string;
    createdAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    userId?: StringFilter<"DoctorApplication"> | string;
    hospitalId?: StringFilter<"DoctorApplication"> | string;
    yearsOfExperience?: IntNullableFilter<"DoctorApplication"> | number | null;
    bio?: StringNullableFilter<"DoctorApplication"> | string | null;
    status?: EnumDoctorApplicationStatusFilter<"DoctorApplication"> | DoctorApplicationStatus;
    specializationIds?: StringNullableListFilter<"DoctorApplication">;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type DoctorApplicationOrderByWithRelationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    hospitalId?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    status?: SortOrder;
    specializationIds?: SortOrder;
    Hospital?: HospitalOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
};
type DoctorApplicationWhereUniqueInput = AtLeast<{
    id?: string;
    userId_hospitalId?: DoctorApplicationUserIdHospitalIdCompoundUniqueInput;
    AND?: DoctorApplicationWhereInput | DoctorApplicationWhereInput[];
    OR?: DoctorApplicationWhereInput[];
    NOT?: DoctorApplicationWhereInput | DoctorApplicationWhereInput[];
    createdAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    userId?: StringFilter<"DoctorApplication"> | string;
    hospitalId?: StringFilter<"DoctorApplication"> | string;
    yearsOfExperience?: IntNullableFilter<"DoctorApplication"> | number | null;
    bio?: StringNullableFilter<"DoctorApplication"> | string | null;
    status?: EnumDoctorApplicationStatusFilter<"DoctorApplication"> | DoctorApplicationStatus;
    specializationIds?: StringNullableListFilter<"DoctorApplication">;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id" | "userId_hospitalId">;
type DoctorApplicationOrderByWithAggregationInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    hospitalId?: SortOrder;
    yearsOfExperience?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    status?: SortOrder;
    specializationIds?: SortOrder;
    _count?: DoctorApplicationCountOrderByAggregateInput;
    _avg?: DoctorApplicationAvgOrderByAggregateInput;
    _max?: DoctorApplicationMaxOrderByAggregateInput;
    _min?: DoctorApplicationMinOrderByAggregateInput;
    _sum?: DoctorApplicationSumOrderByAggregateInput;
};
type DoctorApplicationScalarWhereWithAggregatesInput = {
    AND?: DoctorApplicationScalarWhereWithAggregatesInput | DoctorApplicationScalarWhereWithAggregatesInput[];
    OR?: DoctorApplicationScalarWhereWithAggregatesInput[];
    NOT?: DoctorApplicationScalarWhereWithAggregatesInput | DoctorApplicationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"DoctorApplication"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"DoctorApplication"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"DoctorApplication"> | Date | string;
    userId?: StringWithAggregatesFilter<"DoctorApplication"> | string;
    hospitalId?: StringWithAggregatesFilter<"DoctorApplication"> | string;
    yearsOfExperience?: IntNullableWithAggregatesFilter<"DoctorApplication"> | number | null;
    bio?: StringNullableWithAggregatesFilter<"DoctorApplication"> | string | null;
    status?: EnumDoctorApplicationStatusWithAggregatesFilter<"DoctorApplication"> | DoctorApplicationStatus;
    specializationIds?: StringNullableListFilter<"DoctorApplication">;
};
type DoctorApplicationCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
    Hospital: HospitalCreateNestedOneWithoutDoctorApplicationInput;
    User: UserCreateNestedOneWithoutDoctorApplicationInput;
};
type DoctorApplicationUncheckedCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
    hospitalId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
    Hospital?: HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput;
    User?: UserUpdateOneRequiredWithoutDoctorApplicationNestedInput;
};
type DoctorApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationCreateManyInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
    hospitalId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
};
type DoctorApplicationUserIdHospitalIdCompoundUniqueInput = {
    userId: string;
    hospitalId: string;
};
type DoctorApplicationCountOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    hospitalId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    status?: SortOrder;
    specializationIds?: SortOrder;
};
type DoctorApplicationAvgOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
};
type DoctorApplicationMaxOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    hospitalId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    status?: SortOrder;
};
type DoctorApplicationMinOrderByAggregateInput = {
    id?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    hospitalId?: SortOrder;
    yearsOfExperience?: SortOrder;
    bio?: SortOrder;
    status?: SortOrder;
};
type DoctorApplicationSumOrderByAggregateInput = {
    yearsOfExperience?: SortOrder;
};
type DoctorApplicationListRelationFilter = {
    every?: DoctorApplicationWhereInput;
    some?: DoctorApplicationWhereInput;
    none?: DoctorApplicationWhereInput;
};
type DoctorApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type DoctorApplicationCreatespecializationIdsInput = {
    set: string[];
};
type EnumDoctorApplicationStatusFieldUpdateOperationsInput = {
    set?: DoctorApplicationStatus;
};
type DoctorApplicationUpdatespecializationIdsInput = {
    set?: string[];
    push?: string | string[];
};
type DoctorApplicationCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput> | DoctorApplicationCreateWithoutHospitalInput[] | DoctorApplicationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutHospitalInput | DoctorApplicationCreateOrConnectWithoutHospitalInput[];
    createMany?: DoctorApplicationCreateManyHospitalInputEnvelope;
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
};
type DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput> | DoctorApplicationCreateWithoutHospitalInput[] | DoctorApplicationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutHospitalInput | DoctorApplicationCreateOrConnectWithoutHospitalInput[];
    createMany?: DoctorApplicationCreateManyHospitalInputEnvelope;
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
};
type DoctorApplicationUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput> | DoctorApplicationCreateWithoutHospitalInput[] | DoctorApplicationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutHospitalInput | DoctorApplicationCreateOrConnectWithoutHospitalInput[];
    upsert?: DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput | DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: DoctorApplicationCreateManyHospitalInputEnvelope;
    set?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    disconnect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    delete?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    update?: DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput | DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: DoctorApplicationUpdateManyWithWhereWithoutHospitalInput | DoctorApplicationUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
};
type DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput> | DoctorApplicationCreateWithoutHospitalInput[] | DoctorApplicationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutHospitalInput | DoctorApplicationCreateOrConnectWithoutHospitalInput[];
    upsert?: DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput | DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: DoctorApplicationCreateManyHospitalInputEnvelope;
    set?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    disconnect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    delete?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    update?: DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput | DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: DoctorApplicationUpdateManyWithWhereWithoutHospitalInput | DoctorApplicationUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
};
type DoctorApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput> | DoctorApplicationCreateWithoutUserInput[] | DoctorApplicationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutUserInput | DoctorApplicationCreateOrConnectWithoutUserInput[];
    createMany?: DoctorApplicationCreateManyUserInputEnvelope;
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
};
type DoctorApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput> | DoctorApplicationCreateWithoutUserInput[] | DoctorApplicationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutUserInput | DoctorApplicationCreateOrConnectWithoutUserInput[];
    createMany?: DoctorApplicationCreateManyUserInputEnvelope;
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
};
type DoctorApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput> | DoctorApplicationCreateWithoutUserInput[] | DoctorApplicationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutUserInput | DoctorApplicationCreateOrConnectWithoutUserInput[];
    upsert?: DoctorApplicationUpsertWithWhereUniqueWithoutUserInput | DoctorApplicationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DoctorApplicationCreateManyUserInputEnvelope;
    set?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    disconnect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    delete?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    update?: DoctorApplicationUpdateWithWhereUniqueWithoutUserInput | DoctorApplicationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: DoctorApplicationUpdateManyWithWhereWithoutUserInput | DoctorApplicationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
};
type DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput> | DoctorApplicationCreateWithoutUserInput[] | DoctorApplicationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: DoctorApplicationCreateOrConnectWithoutUserInput | DoctorApplicationCreateOrConnectWithoutUserInput[];
    upsert?: DoctorApplicationUpsertWithWhereUniqueWithoutUserInput | DoctorApplicationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DoctorApplicationCreateManyUserInputEnvelope;
    set?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    disconnect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    delete?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    connect?: DoctorApplicationWhereUniqueInput | DoctorApplicationWhereUniqueInput[];
    update?: DoctorApplicationUpdateWithWhereUniqueWithoutUserInput | DoctorApplicationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: DoctorApplicationUpdateManyWithWhereWithoutUserInput | DoctorApplicationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
};
type DoctorApplicationCreateWithoutHospitalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
    User: UserCreateNestedOneWithoutDoctorApplicationInput;
};
type DoctorApplicationUncheckedCreateWithoutHospitalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationCreateOrConnectWithoutHospitalInput = {
    where: DoctorApplicationWhereUniqueInput;
    create: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput>;
};
type DoctorApplicationCreateManyHospitalInputEnvelope = {
    data: DoctorApplicationCreateManyHospitalInput | DoctorApplicationCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput = {
    where: DoctorApplicationWhereUniqueInput;
    update: XOR<DoctorApplicationUpdateWithoutHospitalInput, DoctorApplicationUncheckedUpdateWithoutHospitalInput>;
    create: XOR<DoctorApplicationCreateWithoutHospitalInput, DoctorApplicationUncheckedCreateWithoutHospitalInput>;
};
type DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput = {
    where: DoctorApplicationWhereUniqueInput;
    data: XOR<DoctorApplicationUpdateWithoutHospitalInput, DoctorApplicationUncheckedUpdateWithoutHospitalInput>;
};
type DoctorApplicationUpdateManyWithWhereWithoutHospitalInput = {
    where: DoctorApplicationScalarWhereInput;
    data: XOR<DoctorApplicationUpdateManyMutationInput, DoctorApplicationUncheckedUpdateManyWithoutHospitalInput>;
};
type DoctorApplicationScalarWhereInput = {
    AND?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
    OR?: DoctorApplicationScalarWhereInput[];
    NOT?: DoctorApplicationScalarWhereInput | DoctorApplicationScalarWhereInput[];
    id?: StringFilter<"DoctorApplication"> | string;
    createdAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorApplication"> | Date | string;
    userId?: StringFilter<"DoctorApplication"> | string;
    hospitalId?: StringFilter<"DoctorApplication"> | string;
    yearsOfExperience?: IntNullableFilter<"DoctorApplication"> | number | null;
    bio?: StringNullableFilter<"DoctorApplication"> | string | null;
    status?: EnumDoctorApplicationStatusFilter<"DoctorApplication"> | DoctorApplicationStatus;
    specializationIds?: StringNullableListFilter<"DoctorApplication">;
};
type DoctorApplicationCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
    Hospital: HospitalCreateNestedOneWithoutDoctorApplicationInput;
};
type DoctorApplicationUncheckedCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hospitalId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationCreateOrConnectWithoutUserInput = {
    where: DoctorApplicationWhereUniqueInput;
    create: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput>;
};
type DoctorApplicationCreateManyUserInputEnvelope = {
    data: DoctorApplicationCreateManyUserInput | DoctorApplicationCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type DoctorApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: DoctorApplicationWhereUniqueInput;
    update: XOR<DoctorApplicationUpdateWithoutUserInput, DoctorApplicationUncheckedUpdateWithoutUserInput>;
    create: XOR<DoctorApplicationCreateWithoutUserInput, DoctorApplicationUncheckedCreateWithoutUserInput>;
};
type DoctorApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: DoctorApplicationWhereUniqueInput;
    data: XOR<DoctorApplicationUpdateWithoutUserInput, DoctorApplicationUncheckedUpdateWithoutUserInput>;
};
type DoctorApplicationUpdateManyWithWhereWithoutUserInput = {
    where: DoctorApplicationScalarWhereInput;
    data: XOR<DoctorApplicationUpdateManyMutationInput, DoctorApplicationUncheckedUpdateManyWithoutUserInput>;
};
type DoctorApplicationCreateManyHospitalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
    User?: UserUpdateOneRequiredWithoutDoctorApplicationNestedInput;
};
type DoctorApplicationUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationCreateManyUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hospitalId: string;
    yearsOfExperience?: number | null;
    bio?: string | null;
    status?: DoctorApplicationStatus;
    specializationIds?: DoctorApplicationCreatespecializationIdsInput | string[];
};
type DoctorApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
    Hospital?: HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput;
};
type DoctorApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    yearsOfExperience?: NullableIntFieldUpdateOperationsInput | number | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumDoctorApplicationStatusFieldUpdateOperationsInput | DoctorApplicationStatus;
    specializationIds?: DoctorApplicationUpdatespecializationIdsInput | string[];
};
type DoctorApplicationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
    hospitalId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    status?: boolean;
    specializationIds?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorApplication"]>;
type DoctorApplicationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
    hospitalId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    status?: boolean;
    specializationIds?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorApplication"]>;
type DoctorApplicationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
    hospitalId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    status?: boolean;
    specializationIds?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorApplication"]>;
type DoctorApplicationSelectScalar = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
    hospitalId?: boolean;
    yearsOfExperience?: boolean;
    bio?: boolean;
    status?: boolean;
    specializationIds?: boolean;
};
type DoctorApplicationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "hospitalId" | "yearsOfExperience" | "bio" | "status" | "specializationIds", ExtArgs["result"]["doctorApplication"]>;
type DoctorApplicationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type DoctorApplicationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type DoctorApplicationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $DoctorApplicationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "DoctorApplication";
    objects: {
        Hospital: $HospitalPayload<ExtArgs>;
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        userId: string;
        hospitalId: string;
        yearsOfExperience: number | null;
        bio: string | null;
        status: DoctorApplicationStatus;
        specializationIds: string[];
    }, ExtArgs["result"]["doctorApplication"]>;
    composites: {};
};
type DoctorApplicationGetPayload<S extends boolean | null | undefined | DoctorApplicationDefaultArgs> = runtime.Types.Result.GetResult<$DoctorApplicationPayload, S>;
type DoctorApplicationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<DoctorApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DoctorApplicationCountAggregateInputType | true;
};
interface DoctorApplicationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['DoctorApplication'];
        meta: {
            name: 'DoctorApplication';
        };
    };
    /**
     * Find zero or one DoctorApplication that matches the filter.
     * @param {DoctorApplicationFindUniqueArgs} args - Arguments to find a DoctorApplication
     * @example
     * // Get one DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorApplicationFindUniqueArgs>(args: SelectSubset<T, DoctorApplicationFindUniqueArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one DoctorApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorApplicationFindUniqueOrThrowArgs} args - Arguments to find a DoctorApplication
     * @example
     * // Get one DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationFindFirstArgs} args - Arguments to find a DoctorApplication
     * @example
     * // Get one DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorApplicationFindFirstArgs>(args?: SelectSubset<T, DoctorApplicationFindFirstArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationFindFirstOrThrowArgs} args - Arguments to find a DoctorApplication
     * @example
     * // Get one DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more DoctorApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorApplications
     * const doctorApplications = await prisma.doctorApplication.findMany()
     *
     * // Get first 10 DoctorApplications
     * const doctorApplications = await prisma.doctorApplication.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const doctorApplicationWithIdOnly = await prisma.doctorApplication.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DoctorApplicationFindManyArgs>(args?: SelectSubset<T, DoctorApplicationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a DoctorApplication.
     * @param {DoctorApplicationCreateArgs} args - Arguments to create a DoctorApplication.
     * @example
     * // Create one DoctorApplication
     * const DoctorApplication = await prisma.doctorApplication.create({
     *   data: {
     *     // ... data to create a DoctorApplication
     *   }
     * })
     *
     */
    create<T extends DoctorApplicationCreateArgs>(args: SelectSubset<T, DoctorApplicationCreateArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many DoctorApplications.
     * @param {DoctorApplicationCreateManyArgs} args - Arguments to create many DoctorApplications.
     * @example
     * // Create many DoctorApplications
     * const doctorApplication = await prisma.doctorApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DoctorApplicationCreateManyArgs>(args?: SelectSubset<T, DoctorApplicationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many DoctorApplications and returns the data saved in the database.
     * @param {DoctorApplicationCreateManyAndReturnArgs} args - Arguments to create many DoctorApplications.
     * @example
     * // Create many DoctorApplications
     * const doctorApplication = await prisma.doctorApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DoctorApplications and only return the `id`
     * const doctorApplicationWithIdOnly = await prisma.doctorApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DoctorApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorApplicationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a DoctorApplication.
     * @param {DoctorApplicationDeleteArgs} args - Arguments to delete one DoctorApplication.
     * @example
     * // Delete one DoctorApplication
     * const DoctorApplication = await prisma.doctorApplication.delete({
     *   where: {
     *     // ... filter to delete one DoctorApplication
     *   }
     * })
     *
     */
    delete<T extends DoctorApplicationDeleteArgs>(args: SelectSubset<T, DoctorApplicationDeleteArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one DoctorApplication.
     * @param {DoctorApplicationUpdateArgs} args - Arguments to update one DoctorApplication.
     * @example
     * // Update one DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DoctorApplicationUpdateArgs>(args: SelectSubset<T, DoctorApplicationUpdateArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more DoctorApplications.
     * @param {DoctorApplicationDeleteManyArgs} args - Arguments to filter DoctorApplications to delete.
     * @example
     * // Delete a few DoctorApplications
     * const { count } = await prisma.doctorApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DoctorApplicationDeleteManyArgs>(args?: SelectSubset<T, DoctorApplicationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorApplications
     * const doctorApplication = await prisma.doctorApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DoctorApplicationUpdateManyArgs>(args: SelectSubset<T, DoctorApplicationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorApplications and returns the data updated in the database.
     * @param {DoctorApplicationUpdateManyAndReturnArgs} args - Arguments to update many DoctorApplications.
     * @example
     * // Update many DoctorApplications
     * const doctorApplication = await prisma.doctorApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DoctorApplications and only return the `id`
     * const doctorApplicationWithIdOnly = await prisma.doctorApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DoctorApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorApplicationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one DoctorApplication.
     * @param {DoctorApplicationUpsertArgs} args - Arguments to update or create a DoctorApplication.
     * @example
     * // Update or create a DoctorApplication
     * const doctorApplication = await prisma.doctorApplication.upsert({
     *   create: {
     *     // ... data to create a DoctorApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorApplication we want to update
     *   }
     * })
     */
    upsert<T extends DoctorApplicationUpsertArgs>(args: SelectSubset<T, DoctorApplicationUpsertArgs<ExtArgs>>): Prisma__DoctorApplicationClient<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of DoctorApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationCountArgs} args - Arguments to filter DoctorApplications to count.
     * @example
     * // Count the number of DoctorApplications
     * const count = await prisma.doctorApplication.count({
     *   where: {
     *     // ... the filter for the DoctorApplications we want to count
     *   }
     * })
    **/
    count<T extends DoctorApplicationCountArgs>(args?: Subset<T, DoctorApplicationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], DoctorApplicationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a DoctorApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorApplicationAggregateArgs>(args: Subset<T, DoctorApplicationAggregateArgs>): PrismaPromise<GetDoctorApplicationAggregateType<T>>;
    /**
     * Group by DoctorApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends DoctorApplicationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: DoctorApplicationGroupByArgs['orderBy'];
    } : {
        orderBy?: DoctorApplicationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, DoctorApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorApplicationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the DoctorApplication model
     */
    readonly fields: DoctorApplicationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for DoctorApplication.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__DoctorApplicationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the DoctorApplication model
 */
interface DoctorApplicationFieldRefs {
    readonly id: FieldRef<"DoctorApplication", 'String'>;
    readonly createdAt: FieldRef<"DoctorApplication", 'DateTime'>;
    readonly updatedAt: FieldRef<"DoctorApplication", 'DateTime'>;
    readonly userId: FieldRef<"DoctorApplication", 'String'>;
    readonly hospitalId: FieldRef<"DoctorApplication", 'String'>;
    readonly yearsOfExperience: FieldRef<"DoctorApplication", 'Int'>;
    readonly bio: FieldRef<"DoctorApplication", 'String'>;
    readonly status: FieldRef<"DoctorApplication", 'DoctorApplicationStatus'>;
    readonly specializationIds: FieldRef<"DoctorApplication", 'String[]'>;
}
/**
 * DoctorApplication findUnique
 */
type DoctorApplicationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorApplication to fetch.
     */
    where: DoctorApplicationWhereUniqueInput;
};
/**
 * DoctorApplication findUniqueOrThrow
 */
type DoctorApplicationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorApplication to fetch.
     */
    where: DoctorApplicationWhereUniqueInput;
};
/**
 * DoctorApplication findFirst
 */
type DoctorApplicationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorApplication to fetch.
     */
    where?: DoctorApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorApplications to fetch.
     */
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorApplications.
     */
    cursor?: DoctorApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorApplications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorApplications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorApplications.
     */
    distinct?: DoctorApplicationScalarFieldEnum | DoctorApplicationScalarFieldEnum[];
};
/**
 * DoctorApplication findFirstOrThrow
 */
type DoctorApplicationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorApplication to fetch.
     */
    where?: DoctorApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorApplications to fetch.
     */
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorApplications.
     */
    cursor?: DoctorApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorApplications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorApplications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorApplications.
     */
    distinct?: DoctorApplicationScalarFieldEnum | DoctorApplicationScalarFieldEnum[];
};
/**
 * DoctorApplication findMany
 */
type DoctorApplicationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorApplications to fetch.
     */
    where?: DoctorApplicationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorApplications to fetch.
     */
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DoctorApplications.
     */
    cursor?: DoctorApplicationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorApplications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorApplications.
     */
    skip?: number;
    distinct?: DoctorApplicationScalarFieldEnum | DoctorApplicationScalarFieldEnum[];
};
/**
 * DoctorApplication create
 */
type DoctorApplicationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to create a DoctorApplication.
     */
    data: XOR<DoctorApplicationCreateInput, DoctorApplicationUncheckedCreateInput>;
};
/**
 * DoctorApplication createMany
 */
type DoctorApplicationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorApplications.
     */
    data: DoctorApplicationCreateManyInput | DoctorApplicationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * DoctorApplication createManyAndReturn
 */
type DoctorApplicationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * The data used to create many DoctorApplications.
     */
    data: DoctorApplicationCreateManyInput | DoctorApplicationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorApplication update
 */
type DoctorApplicationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * The data needed to update a DoctorApplication.
     */
    data: XOR<DoctorApplicationUpdateInput, DoctorApplicationUncheckedUpdateInput>;
    /**
     * Choose, which DoctorApplication to update.
     */
    where: DoctorApplicationWhereUniqueInput;
};
/**
 * DoctorApplication updateMany
 */
type DoctorApplicationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorApplications.
     */
    data: XOR<DoctorApplicationUpdateManyMutationInput, DoctorApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorApplications to update
     */
    where?: DoctorApplicationWhereInput;
    /**
     * Limit how many DoctorApplications to update.
     */
    limit?: number;
};
/**
 * DoctorApplication updateManyAndReturn
 */
type DoctorApplicationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * The data used to update DoctorApplications.
     */
    data: XOR<DoctorApplicationUpdateManyMutationInput, DoctorApplicationUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorApplications to update
     */
    where?: DoctorApplicationWhereInput;
    /**
     * Limit how many DoctorApplications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorApplication upsert
 */
type DoctorApplicationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * The filter to search for the DoctorApplication to update in case it exists.
     */
    where: DoctorApplicationWhereUniqueInput;
    /**
     * In case the DoctorApplication found by the `where` argument doesn't exist, create a new DoctorApplication with this data.
     */
    create: XOR<DoctorApplicationCreateInput, DoctorApplicationUncheckedCreateInput>;
    /**
     * In case the DoctorApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorApplicationUpdateInput, DoctorApplicationUncheckedUpdateInput>;
};
/**
 * DoctorApplication delete
 */
type DoctorApplicationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    /**
     * Filter which DoctorApplication to delete.
     */
    where: DoctorApplicationWhereUniqueInput;
};
/**
 * DoctorApplication deleteMany
 */
type DoctorApplicationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorApplications to delete
     */
    where?: DoctorApplicationWhereInput;
    /**
     * Limit how many DoctorApplications to delete.
     */
    limit?: number;
};
/**
 * DoctorApplication without action
 */
type DoctorApplicationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
};

/**
 * Model DoctorHospitalProfile
 *
 */
type DoctorHospitalProfileModel = runtime.Types.Result.DefaultSelection<$DoctorHospitalProfilePayload>;
type AggregateDoctorHospitalProfile = {
    _count: DoctorHospitalProfileCountAggregateOutputType | null;
    _avg: DoctorHospitalProfileAvgAggregateOutputType | null;
    _sum: DoctorHospitalProfileSumAggregateOutputType | null;
    _min: DoctorHospitalProfileMinAggregateOutputType | null;
    _max: DoctorHospitalProfileMaxAggregateOutputType | null;
};
type DoctorHospitalProfileAvgAggregateOutputType = {
    slotDuration: number | null;
};
type DoctorHospitalProfileSumAggregateOutputType = {
    slotDuration: number | null;
};
type DoctorHospitalProfileMinAggregateOutputType = {
    id: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    doctorType: DoctorType | null;
    slotDuration: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type DoctorHospitalProfileMaxAggregateOutputType = {
    id: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    doctorType: DoctorType | null;
    slotDuration: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type DoctorHospitalProfileCountAggregateOutputType = {
    id: number;
    doctorId: number;
    hospitalId: number;
    doctorType: number;
    slotDuration: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type DoctorHospitalProfileAvgAggregateInputType = {
    slotDuration?: true;
};
type DoctorHospitalProfileSumAggregateInputType = {
    slotDuration?: true;
};
type DoctorHospitalProfileMinAggregateInputType = {
    id?: true;
    doctorId?: true;
    hospitalId?: true;
    doctorType?: true;
    slotDuration?: true;
    createdAt?: true;
    updatedAt?: true;
};
type DoctorHospitalProfileMaxAggregateInputType = {
    id?: true;
    doctorId?: true;
    hospitalId?: true;
    doctorType?: true;
    slotDuration?: true;
    createdAt?: true;
    updatedAt?: true;
};
type DoctorHospitalProfileCountAggregateInputType = {
    id?: true;
    doctorId?: true;
    hospitalId?: true;
    doctorType?: true;
    slotDuration?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type DoctorHospitalProfileAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorHospitalProfile to aggregate.
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorHospitalProfiles to fetch.
     */
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorHospitalProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorHospitalProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DoctorHospitalProfiles
    **/
    _count?: true | DoctorHospitalProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: DoctorHospitalProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: DoctorHospitalProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DoctorHospitalProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DoctorHospitalProfileMaxAggregateInputType;
};
type GetDoctorHospitalProfileAggregateType<T extends DoctorHospitalProfileAggregateArgs> = {
    [P in keyof T & keyof AggregateDoctorHospitalProfile]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateDoctorHospitalProfile[P]> : GetScalarType<T[P], AggregateDoctorHospitalProfile[P]>;
};
type DoctorHospitalProfileGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorHospitalProfileWhereInput;
    orderBy?: DoctorHospitalProfileOrderByWithAggregationInput | DoctorHospitalProfileOrderByWithAggregationInput[];
    by: DoctorHospitalProfileScalarFieldEnum[] | DoctorHospitalProfileScalarFieldEnum;
    having?: DoctorHospitalProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DoctorHospitalProfileCountAggregateInputType | true;
    _avg?: DoctorHospitalProfileAvgAggregateInputType;
    _sum?: DoctorHospitalProfileSumAggregateInputType;
    _min?: DoctorHospitalProfileMinAggregateInputType;
    _max?: DoctorHospitalProfileMaxAggregateInputType;
};
type DoctorHospitalProfileGroupByOutputType = {
    id: string;
    doctorId: string;
    hospitalId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt: Date;
    updatedAt: Date;
    _count: DoctorHospitalProfileCountAggregateOutputType | null;
    _avg: DoctorHospitalProfileAvgAggregateOutputType | null;
    _sum: DoctorHospitalProfileSumAggregateOutputType | null;
    _min: DoctorHospitalProfileMinAggregateOutputType | null;
    _max: DoctorHospitalProfileMaxAggregateOutputType | null;
};
type GetDoctorHospitalProfileGroupByPayload<T extends DoctorHospitalProfileGroupByArgs> = PrismaPromise<Array<PickEnumerable<DoctorHospitalProfileGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof DoctorHospitalProfileGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], DoctorHospitalProfileGroupByOutputType[P]> : GetScalarType<T[P], DoctorHospitalProfileGroupByOutputType[P]>;
}>>;
type DoctorHospitalProfileWhereInput = {
    AND?: DoctorHospitalProfileWhereInput | DoctorHospitalProfileWhereInput[];
    OR?: DoctorHospitalProfileWhereInput[];
    NOT?: DoctorHospitalProfileWhereInput | DoctorHospitalProfileWhereInput[];
    id?: StringFilter<"DoctorHospitalProfile"> | string;
    doctorId?: StringFilter<"DoctorHospitalProfile"> | string;
    hospitalId?: StringFilter<"DoctorHospitalProfile"> | string;
    doctorType?: EnumDoctorTypeFilter<"DoctorHospitalProfile"> | DoctorType;
    slotDuration?: IntFilter<"DoctorHospitalProfile"> | number;
    createdAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
};
type DoctorHospitalProfileOrderByWithRelationInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    doctorType?: SortOrder;
    slotDuration?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Doctor?: DoctorOrderByWithRelationInput;
    Hospital?: HospitalOrderByWithRelationInput;
};
type DoctorHospitalProfileWhereUniqueInput = AtLeast<{
    id?: string;
    doctorId_hospitalId?: DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput;
    AND?: DoctorHospitalProfileWhereInput | DoctorHospitalProfileWhereInput[];
    OR?: DoctorHospitalProfileWhereInput[];
    NOT?: DoctorHospitalProfileWhereInput | DoctorHospitalProfileWhereInput[];
    doctorId?: StringFilter<"DoctorHospitalProfile"> | string;
    hospitalId?: StringFilter<"DoctorHospitalProfile"> | string;
    doctorType?: EnumDoctorTypeFilter<"DoctorHospitalProfile"> | DoctorType;
    slotDuration?: IntFilter<"DoctorHospitalProfile"> | number;
    createdAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
}, "id" | "doctorId_hospitalId">;
type DoctorHospitalProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    doctorType?: SortOrder;
    slotDuration?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DoctorHospitalProfileCountOrderByAggregateInput;
    _avg?: DoctorHospitalProfileAvgOrderByAggregateInput;
    _max?: DoctorHospitalProfileMaxOrderByAggregateInput;
    _min?: DoctorHospitalProfileMinOrderByAggregateInput;
    _sum?: DoctorHospitalProfileSumOrderByAggregateInput;
};
type DoctorHospitalProfileScalarWhereWithAggregatesInput = {
    AND?: DoctorHospitalProfileScalarWhereWithAggregatesInput | DoctorHospitalProfileScalarWhereWithAggregatesInput[];
    OR?: DoctorHospitalProfileScalarWhereWithAggregatesInput[];
    NOT?: DoctorHospitalProfileScalarWhereWithAggregatesInput | DoctorHospitalProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"DoctorHospitalProfile"> | string;
    doctorId?: StringWithAggregatesFilter<"DoctorHospitalProfile"> | string;
    hospitalId?: StringWithAggregatesFilter<"DoctorHospitalProfile"> | string;
    doctorType?: EnumDoctorTypeWithAggregatesFilter<"DoctorHospitalProfile"> | DoctorType;
    slotDuration?: IntWithAggregatesFilter<"DoctorHospitalProfile"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"DoctorHospitalProfile"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"DoctorHospitalProfile"> | Date | string;
};
type DoctorHospitalProfileCreateInput = {
    id?: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor: DoctorCreateNestedOneWithoutDoctorHospitalProfileInput;
    Hospital: HospitalCreateNestedOneWithoutDoctorHospitalProfileInput;
};
type DoctorHospitalProfileUncheckedCreateInput = {
    id?: string;
    doctorId: string;
    hospitalId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
};
type DoctorHospitalProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileCreateManyInput = {
    id?: string;
    doctorId: string;
    hospitalId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileListRelationFilter = {
    every?: DoctorHospitalProfileWhereInput;
    some?: DoctorHospitalProfileWhereInput;
    none?: DoctorHospitalProfileWhereInput;
};
type DoctorHospitalProfileOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput = {
    doctorId: string;
    hospitalId: string;
};
type DoctorHospitalProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    doctorType?: SortOrder;
    slotDuration?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorHospitalProfileAvgOrderByAggregateInput = {
    slotDuration?: SortOrder;
};
type DoctorHospitalProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    doctorType?: SortOrder;
    slotDuration?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorHospitalProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    doctorType?: SortOrder;
    slotDuration?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorHospitalProfileSumOrderByAggregateInput = {
    slotDuration?: SortOrder;
};
type DoctorHospitalProfileCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput> | DoctorHospitalProfileCreateWithoutDoctorInput[] | DoctorHospitalProfileUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutDoctorInput | DoctorHospitalProfileCreateOrConnectWithoutDoctorInput[];
    createMany?: DoctorHospitalProfileCreateManyDoctorInputEnvelope;
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
};
type DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput> | DoctorHospitalProfileCreateWithoutDoctorInput[] | DoctorHospitalProfileUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutDoctorInput | DoctorHospitalProfileCreateOrConnectWithoutDoctorInput[];
    createMany?: DoctorHospitalProfileCreateManyDoctorInputEnvelope;
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
};
type DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput> | DoctorHospitalProfileCreateWithoutDoctorInput[] | DoctorHospitalProfileUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutDoctorInput | DoctorHospitalProfileCreateOrConnectWithoutDoctorInput[];
    upsert?: DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput | DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: DoctorHospitalProfileCreateManyDoctorInputEnvelope;
    set?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    disconnect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    delete?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    update?: DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput | DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput | DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
};
type DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput> | DoctorHospitalProfileCreateWithoutDoctorInput[] | DoctorHospitalProfileUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutDoctorInput | DoctorHospitalProfileCreateOrConnectWithoutDoctorInput[];
    upsert?: DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput | DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: DoctorHospitalProfileCreateManyDoctorInputEnvelope;
    set?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    disconnect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    delete?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    update?: DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput | DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput | DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
};
type EnumDoctorTypeFieldUpdateOperationsInput = {
    set?: DoctorType;
};
type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
};
type DoctorHospitalProfileCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput> | DoctorHospitalProfileCreateWithoutHospitalInput[] | DoctorHospitalProfileUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutHospitalInput | DoctorHospitalProfileCreateOrConnectWithoutHospitalInput[];
    createMany?: DoctorHospitalProfileCreateManyHospitalInputEnvelope;
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
};
type DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput> | DoctorHospitalProfileCreateWithoutHospitalInput[] | DoctorHospitalProfileUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutHospitalInput | DoctorHospitalProfileCreateOrConnectWithoutHospitalInput[];
    createMany?: DoctorHospitalProfileCreateManyHospitalInputEnvelope;
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
};
type DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput> | DoctorHospitalProfileCreateWithoutHospitalInput[] | DoctorHospitalProfileUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutHospitalInput | DoctorHospitalProfileCreateOrConnectWithoutHospitalInput[];
    upsert?: DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput | DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: DoctorHospitalProfileCreateManyHospitalInputEnvelope;
    set?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    disconnect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    delete?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    update?: DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput | DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput | DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
};
type DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput> | DoctorHospitalProfileCreateWithoutHospitalInput[] | DoctorHospitalProfileUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: DoctorHospitalProfileCreateOrConnectWithoutHospitalInput | DoctorHospitalProfileCreateOrConnectWithoutHospitalInput[];
    upsert?: DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput | DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: DoctorHospitalProfileCreateManyHospitalInputEnvelope;
    set?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    disconnect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    delete?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    connect?: DoctorHospitalProfileWhereUniqueInput | DoctorHospitalProfileWhereUniqueInput[];
    update?: DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput | DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput | DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
};
type DoctorHospitalProfileCreateWithoutDoctorInput = {
    id?: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Hospital: HospitalCreateNestedOneWithoutDoctorHospitalProfileInput;
};
type DoctorHospitalProfileUncheckedCreateWithoutDoctorInput = {
    id?: string;
    hospitalId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileCreateOrConnectWithoutDoctorInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    create: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput>;
};
type DoctorHospitalProfileCreateManyDoctorInputEnvelope = {
    data: DoctorHospitalProfileCreateManyDoctorInput | DoctorHospitalProfileCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    update: XOR<DoctorHospitalProfileUpdateWithoutDoctorInput, DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput>;
    create: XOR<DoctorHospitalProfileCreateWithoutDoctorInput, DoctorHospitalProfileUncheckedCreateWithoutDoctorInput>;
};
type DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    data: XOR<DoctorHospitalProfileUpdateWithoutDoctorInput, DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput>;
};
type DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorHospitalProfileScalarWhereInput;
    data: XOR<DoctorHospitalProfileUpdateManyMutationInput, DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput>;
};
type DoctorHospitalProfileScalarWhereInput = {
    AND?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
    OR?: DoctorHospitalProfileScalarWhereInput[];
    NOT?: DoctorHospitalProfileScalarWhereInput | DoctorHospitalProfileScalarWhereInput[];
    id?: StringFilter<"DoctorHospitalProfile"> | string;
    doctorId?: StringFilter<"DoctorHospitalProfile"> | string;
    hospitalId?: StringFilter<"DoctorHospitalProfile"> | string;
    doctorType?: EnumDoctorTypeFilter<"DoctorHospitalProfile"> | DoctorType;
    slotDuration?: IntFilter<"DoctorHospitalProfile"> | number;
    createdAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorHospitalProfile"> | Date | string;
};
type DoctorHospitalProfileCreateWithoutHospitalInput = {
    id?: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor: DoctorCreateNestedOneWithoutDoctorHospitalProfileInput;
};
type DoctorHospitalProfileUncheckedCreateWithoutHospitalInput = {
    id?: string;
    doctorId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileCreateOrConnectWithoutHospitalInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    create: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput>;
};
type DoctorHospitalProfileCreateManyHospitalInputEnvelope = {
    data: DoctorHospitalProfileCreateManyHospitalInput | DoctorHospitalProfileCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    update: XOR<DoctorHospitalProfileUpdateWithoutHospitalInput, DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput>;
    create: XOR<DoctorHospitalProfileCreateWithoutHospitalInput, DoctorHospitalProfileUncheckedCreateWithoutHospitalInput>;
};
type DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput = {
    where: DoctorHospitalProfileWhereUniqueInput;
    data: XOR<DoctorHospitalProfileUpdateWithoutHospitalInput, DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput>;
};
type DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput = {
    where: DoctorHospitalProfileScalarWhereInput;
    data: XOR<DoctorHospitalProfileUpdateManyMutationInput, DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput>;
};
type DoctorHospitalProfileCreateManyDoctorInput = {
    id?: string;
    hospitalId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Hospital?: HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
};
type DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileCreateManyHospitalInput = {
    id?: string;
    doctorId: string;
    doctorType: DoctorType;
    slotDuration: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorHospitalProfileUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
};
type DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    doctorType?: EnumDoctorTypeFieldUpdateOperationsInput | DoctorType;
    slotDuration?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorHospitalProfileSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    doctorType?: boolean;
    slotDuration?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorHospitalProfile"]>;
type DoctorHospitalProfileSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    doctorType?: boolean;
    slotDuration?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorHospitalProfile"]>;
type DoctorHospitalProfileSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    doctorType?: boolean;
    slotDuration?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorHospitalProfile"]>;
type DoctorHospitalProfileSelectScalar = {
    id?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    doctorType?: boolean;
    slotDuration?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type DoctorHospitalProfileOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "doctorId" | "hospitalId" | "doctorType" | "slotDuration" | "createdAt" | "updatedAt", ExtArgs["result"]["doctorHospitalProfile"]>;
type DoctorHospitalProfileInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
};
type DoctorHospitalProfileIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
};
type DoctorHospitalProfileIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
};
type $DoctorHospitalProfilePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "DoctorHospitalProfile";
    objects: {
        Doctor: $DoctorPayload<ExtArgs>;
        Hospital: $HospitalPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        doctorId: string;
        hospitalId: string;
        doctorType: DoctorType;
        slotDuration: number;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["doctorHospitalProfile"]>;
    composites: {};
};
type DoctorHospitalProfileGetPayload<S extends boolean | null | undefined | DoctorHospitalProfileDefaultArgs> = runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload, S>;
type DoctorHospitalProfileCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<DoctorHospitalProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DoctorHospitalProfileCountAggregateInputType | true;
};
interface DoctorHospitalProfileDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['DoctorHospitalProfile'];
        meta: {
            name: 'DoctorHospitalProfile';
        };
    };
    /**
     * Find zero or one DoctorHospitalProfile that matches the filter.
     * @param {DoctorHospitalProfileFindUniqueArgs} args - Arguments to find a DoctorHospitalProfile
     * @example
     * // Get one DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorHospitalProfileFindUniqueArgs>(args: SelectSubset<T, DoctorHospitalProfileFindUniqueArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one DoctorHospitalProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorHospitalProfileFindUniqueOrThrowArgs} args - Arguments to find a DoctorHospitalProfile
     * @example
     * // Get one DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorHospitalProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorHospitalProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorHospitalProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileFindFirstArgs} args - Arguments to find a DoctorHospitalProfile
     * @example
     * // Get one DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorHospitalProfileFindFirstArgs>(args?: SelectSubset<T, DoctorHospitalProfileFindFirstArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorHospitalProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileFindFirstOrThrowArgs} args - Arguments to find a DoctorHospitalProfile
     * @example
     * // Get one DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorHospitalProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorHospitalProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more DoctorHospitalProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorHospitalProfiles
     * const doctorHospitalProfiles = await prisma.doctorHospitalProfile.findMany()
     *
     * // Get first 10 DoctorHospitalProfiles
     * const doctorHospitalProfiles = await prisma.doctorHospitalProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const doctorHospitalProfileWithIdOnly = await prisma.doctorHospitalProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DoctorHospitalProfileFindManyArgs>(args?: SelectSubset<T, DoctorHospitalProfileFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a DoctorHospitalProfile.
     * @param {DoctorHospitalProfileCreateArgs} args - Arguments to create a DoctorHospitalProfile.
     * @example
     * // Create one DoctorHospitalProfile
     * const DoctorHospitalProfile = await prisma.doctorHospitalProfile.create({
     *   data: {
     *     // ... data to create a DoctorHospitalProfile
     *   }
     * })
     *
     */
    create<T extends DoctorHospitalProfileCreateArgs>(args: SelectSubset<T, DoctorHospitalProfileCreateArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many DoctorHospitalProfiles.
     * @param {DoctorHospitalProfileCreateManyArgs} args - Arguments to create many DoctorHospitalProfiles.
     * @example
     * // Create many DoctorHospitalProfiles
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DoctorHospitalProfileCreateManyArgs>(args?: SelectSubset<T, DoctorHospitalProfileCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many DoctorHospitalProfiles and returns the data saved in the database.
     * @param {DoctorHospitalProfileCreateManyAndReturnArgs} args - Arguments to create many DoctorHospitalProfiles.
     * @example
     * // Create many DoctorHospitalProfiles
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DoctorHospitalProfiles and only return the `id`
     * const doctorHospitalProfileWithIdOnly = await prisma.doctorHospitalProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DoctorHospitalProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorHospitalProfileCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a DoctorHospitalProfile.
     * @param {DoctorHospitalProfileDeleteArgs} args - Arguments to delete one DoctorHospitalProfile.
     * @example
     * // Delete one DoctorHospitalProfile
     * const DoctorHospitalProfile = await prisma.doctorHospitalProfile.delete({
     *   where: {
     *     // ... filter to delete one DoctorHospitalProfile
     *   }
     * })
     *
     */
    delete<T extends DoctorHospitalProfileDeleteArgs>(args: SelectSubset<T, DoctorHospitalProfileDeleteArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one DoctorHospitalProfile.
     * @param {DoctorHospitalProfileUpdateArgs} args - Arguments to update one DoctorHospitalProfile.
     * @example
     * // Update one DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DoctorHospitalProfileUpdateArgs>(args: SelectSubset<T, DoctorHospitalProfileUpdateArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more DoctorHospitalProfiles.
     * @param {DoctorHospitalProfileDeleteManyArgs} args - Arguments to filter DoctorHospitalProfiles to delete.
     * @example
     * // Delete a few DoctorHospitalProfiles
     * const { count } = await prisma.doctorHospitalProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DoctorHospitalProfileDeleteManyArgs>(args?: SelectSubset<T, DoctorHospitalProfileDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorHospitalProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorHospitalProfiles
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DoctorHospitalProfileUpdateManyArgs>(args: SelectSubset<T, DoctorHospitalProfileUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorHospitalProfiles and returns the data updated in the database.
     * @param {DoctorHospitalProfileUpdateManyAndReturnArgs} args - Arguments to update many DoctorHospitalProfiles.
     * @example
     * // Update many DoctorHospitalProfiles
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DoctorHospitalProfiles and only return the `id`
     * const doctorHospitalProfileWithIdOnly = await prisma.doctorHospitalProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DoctorHospitalProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorHospitalProfileUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one DoctorHospitalProfile.
     * @param {DoctorHospitalProfileUpsertArgs} args - Arguments to update or create a DoctorHospitalProfile.
     * @example
     * // Update or create a DoctorHospitalProfile
     * const doctorHospitalProfile = await prisma.doctorHospitalProfile.upsert({
     *   create: {
     *     // ... data to create a DoctorHospitalProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorHospitalProfile we want to update
     *   }
     * })
     */
    upsert<T extends DoctorHospitalProfileUpsertArgs>(args: SelectSubset<T, DoctorHospitalProfileUpsertArgs<ExtArgs>>): Prisma__DoctorHospitalProfileClient<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of DoctorHospitalProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileCountArgs} args - Arguments to filter DoctorHospitalProfiles to count.
     * @example
     * // Count the number of DoctorHospitalProfiles
     * const count = await prisma.doctorHospitalProfile.count({
     *   where: {
     *     // ... the filter for the DoctorHospitalProfiles we want to count
     *   }
     * })
    **/
    count<T extends DoctorHospitalProfileCountArgs>(args?: Subset<T, DoctorHospitalProfileCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], DoctorHospitalProfileCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a DoctorHospitalProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorHospitalProfileAggregateArgs>(args: Subset<T, DoctorHospitalProfileAggregateArgs>): PrismaPromise<GetDoctorHospitalProfileAggregateType<T>>;
    /**
     * Group by DoctorHospitalProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorHospitalProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends DoctorHospitalProfileGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: DoctorHospitalProfileGroupByArgs['orderBy'];
    } : {
        orderBy?: DoctorHospitalProfileGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, DoctorHospitalProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorHospitalProfileGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the DoctorHospitalProfile model
     */
    readonly fields: DoctorHospitalProfileFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for DoctorHospitalProfile.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__DoctorHospitalProfileClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the DoctorHospitalProfile model
 */
interface DoctorHospitalProfileFieldRefs {
    readonly id: FieldRef<"DoctorHospitalProfile", 'String'>;
    readonly doctorId: FieldRef<"DoctorHospitalProfile", 'String'>;
    readonly hospitalId: FieldRef<"DoctorHospitalProfile", 'String'>;
    readonly doctorType: FieldRef<"DoctorHospitalProfile", 'DoctorType'>;
    readonly slotDuration: FieldRef<"DoctorHospitalProfile", 'Int'>;
    readonly createdAt: FieldRef<"DoctorHospitalProfile", 'DateTime'>;
    readonly updatedAt: FieldRef<"DoctorHospitalProfile", 'DateTime'>;
}
/**
 * DoctorHospitalProfile findUnique
 */
type DoctorHospitalProfileFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorHospitalProfile to fetch.
     */
    where: DoctorHospitalProfileWhereUniqueInput;
};
/**
 * DoctorHospitalProfile findUniqueOrThrow
 */
type DoctorHospitalProfileFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorHospitalProfile to fetch.
     */
    where: DoctorHospitalProfileWhereUniqueInput;
};
/**
 * DoctorHospitalProfile findFirst
 */
type DoctorHospitalProfileFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorHospitalProfile to fetch.
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorHospitalProfiles to fetch.
     */
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorHospitalProfiles.
     */
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorHospitalProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorHospitalProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorHospitalProfiles.
     */
    distinct?: DoctorHospitalProfileScalarFieldEnum | DoctorHospitalProfileScalarFieldEnum[];
};
/**
 * DoctorHospitalProfile findFirstOrThrow
 */
type DoctorHospitalProfileFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorHospitalProfile to fetch.
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorHospitalProfiles to fetch.
     */
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorHospitalProfiles.
     */
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorHospitalProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorHospitalProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorHospitalProfiles.
     */
    distinct?: DoctorHospitalProfileScalarFieldEnum | DoctorHospitalProfileScalarFieldEnum[];
};
/**
 * DoctorHospitalProfile findMany
 */
type DoctorHospitalProfileFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorHospitalProfiles to fetch.
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorHospitalProfiles to fetch.
     */
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DoctorHospitalProfiles.
     */
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorHospitalProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorHospitalProfiles.
     */
    skip?: number;
    distinct?: DoctorHospitalProfileScalarFieldEnum | DoctorHospitalProfileScalarFieldEnum[];
};
/**
 * DoctorHospitalProfile create
 */
type DoctorHospitalProfileCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a DoctorHospitalProfile.
     */
    data: XOR<DoctorHospitalProfileCreateInput, DoctorHospitalProfileUncheckedCreateInput>;
};
/**
 * DoctorHospitalProfile createMany
 */
type DoctorHospitalProfileCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorHospitalProfiles.
     */
    data: DoctorHospitalProfileCreateManyInput | DoctorHospitalProfileCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * DoctorHospitalProfile createManyAndReturn
 */
type DoctorHospitalProfileCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * The data used to create many DoctorHospitalProfiles.
     */
    data: DoctorHospitalProfileCreateManyInput | DoctorHospitalProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorHospitalProfile update
 */
type DoctorHospitalProfileUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a DoctorHospitalProfile.
     */
    data: XOR<DoctorHospitalProfileUpdateInput, DoctorHospitalProfileUncheckedUpdateInput>;
    /**
     * Choose, which DoctorHospitalProfile to update.
     */
    where: DoctorHospitalProfileWhereUniqueInput;
};
/**
 * DoctorHospitalProfile updateMany
 */
type DoctorHospitalProfileUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorHospitalProfiles.
     */
    data: XOR<DoctorHospitalProfileUpdateManyMutationInput, DoctorHospitalProfileUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorHospitalProfiles to update
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * Limit how many DoctorHospitalProfiles to update.
     */
    limit?: number;
};
/**
 * DoctorHospitalProfile updateManyAndReturn
 */
type DoctorHospitalProfileUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * The data used to update DoctorHospitalProfiles.
     */
    data: XOR<DoctorHospitalProfileUpdateManyMutationInput, DoctorHospitalProfileUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorHospitalProfiles to update
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * Limit how many DoctorHospitalProfiles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorHospitalProfile upsert
 */
type DoctorHospitalProfileUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the DoctorHospitalProfile to update in case it exists.
     */
    where: DoctorHospitalProfileWhereUniqueInput;
    /**
     * In case the DoctorHospitalProfile found by the `where` argument doesn't exist, create a new DoctorHospitalProfile with this data.
     */
    create: XOR<DoctorHospitalProfileCreateInput, DoctorHospitalProfileUncheckedCreateInput>;
    /**
     * In case the DoctorHospitalProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorHospitalProfileUpdateInput, DoctorHospitalProfileUncheckedUpdateInput>;
};
/**
 * DoctorHospitalProfile delete
 */
type DoctorHospitalProfileDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    /**
     * Filter which DoctorHospitalProfile to delete.
     */
    where: DoctorHospitalProfileWhereUniqueInput;
};
/**
 * DoctorHospitalProfile deleteMany
 */
type DoctorHospitalProfileDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorHospitalProfiles to delete
     */
    where?: DoctorHospitalProfileWhereInput;
    /**
     * Limit how many DoctorHospitalProfiles to delete.
     */
    limit?: number;
};
/**
 * DoctorHospitalProfile without action
 */
type DoctorHospitalProfileDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
};

/**
 * Model DoctorSpecialization
 *
 */
type DoctorSpecializationModel = runtime.Types.Result.DefaultSelection<$DoctorSpecializationPayload>;
type AggregateDoctorSpecialization = {
    _count: DoctorSpecializationCountAggregateOutputType | null;
    _min: DoctorSpecializationMinAggregateOutputType | null;
    _max: DoctorSpecializationMaxAggregateOutputType | null;
};
type DoctorSpecializationMinAggregateOutputType = {
    id: string | null;
    doctorId: string | null;
    specializationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type DoctorSpecializationMaxAggregateOutputType = {
    id: string | null;
    doctorId: string | null;
    specializationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type DoctorSpecializationCountAggregateOutputType = {
    id: number;
    doctorId: number;
    specializationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type DoctorSpecializationMinAggregateInputType = {
    id?: true;
    doctorId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type DoctorSpecializationMaxAggregateInputType = {
    id?: true;
    doctorId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type DoctorSpecializationCountAggregateInputType = {
    id?: true;
    doctorId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type DoctorSpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSpecialization to aggregate.
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorSpecializations to fetch.
     */
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DoctorSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DoctorSpecializations
    **/
    _count?: true | DoctorSpecializationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: DoctorSpecializationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: DoctorSpecializationMaxAggregateInputType;
};
type GetDoctorSpecializationAggregateType<T extends DoctorSpecializationAggregateArgs> = {
    [P in keyof T & keyof AggregateDoctorSpecialization]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateDoctorSpecialization[P]> : GetScalarType<T[P], AggregateDoctorSpecialization[P]>;
};
type DoctorSpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorSpecializationWhereInput;
    orderBy?: DoctorSpecializationOrderByWithAggregationInput | DoctorSpecializationOrderByWithAggregationInput[];
    by: DoctorSpecializationScalarFieldEnum[] | DoctorSpecializationScalarFieldEnum;
    having?: DoctorSpecializationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DoctorSpecializationCountAggregateInputType | true;
    _min?: DoctorSpecializationMinAggregateInputType;
    _max?: DoctorSpecializationMaxAggregateInputType;
};
type DoctorSpecializationGroupByOutputType = {
    id: string;
    doctorId: string;
    specializationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: DoctorSpecializationCountAggregateOutputType | null;
    _min: DoctorSpecializationMinAggregateOutputType | null;
    _max: DoctorSpecializationMaxAggregateOutputType | null;
};
type GetDoctorSpecializationGroupByPayload<T extends DoctorSpecializationGroupByArgs> = PrismaPromise<Array<PickEnumerable<DoctorSpecializationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof DoctorSpecializationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], DoctorSpecializationGroupByOutputType[P]> : GetScalarType<T[P], DoctorSpecializationGroupByOutputType[P]>;
}>>;
type DoctorSpecializationWhereInput = {
    AND?: DoctorSpecializationWhereInput | DoctorSpecializationWhereInput[];
    OR?: DoctorSpecializationWhereInput[];
    NOT?: DoctorSpecializationWhereInput | DoctorSpecializationWhereInput[];
    id?: StringFilter<"DoctorSpecialization"> | string;
    doctorId?: StringFilter<"DoctorSpecialization"> | string;
    specializationId?: StringFilter<"DoctorSpecialization"> | string;
    createdAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Specialization?: XOR<SpecializationScalarRelationFilter, SpecializationWhereInput>;
};
type DoctorSpecializationOrderByWithRelationInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Doctor?: DoctorOrderByWithRelationInput;
    Specialization?: SpecializationOrderByWithRelationInput;
};
type DoctorSpecializationWhereUniqueInput = AtLeast<{
    id?: string;
    doctorId_specializationId?: DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput;
    AND?: DoctorSpecializationWhereInput | DoctorSpecializationWhereInput[];
    OR?: DoctorSpecializationWhereInput[];
    NOT?: DoctorSpecializationWhereInput | DoctorSpecializationWhereInput[];
    doctorId?: StringFilter<"DoctorSpecialization"> | string;
    specializationId?: StringFilter<"DoctorSpecialization"> | string;
    createdAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Specialization?: XOR<SpecializationScalarRelationFilter, SpecializationWhereInput>;
}, "id" | "doctorId_specializationId">;
type DoctorSpecializationOrderByWithAggregationInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DoctorSpecializationCountOrderByAggregateInput;
    _max?: DoctorSpecializationMaxOrderByAggregateInput;
    _min?: DoctorSpecializationMinOrderByAggregateInput;
};
type DoctorSpecializationScalarWhereWithAggregatesInput = {
    AND?: DoctorSpecializationScalarWhereWithAggregatesInput | DoctorSpecializationScalarWhereWithAggregatesInput[];
    OR?: DoctorSpecializationScalarWhereWithAggregatesInput[];
    NOT?: DoctorSpecializationScalarWhereWithAggregatesInput | DoctorSpecializationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"DoctorSpecialization"> | string;
    doctorId?: StringWithAggregatesFilter<"DoctorSpecialization"> | string;
    specializationId?: StringWithAggregatesFilter<"DoctorSpecialization"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"DoctorSpecialization"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"DoctorSpecialization"> | Date | string;
};
type DoctorSpecializationCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor: DoctorCreateNestedOneWithoutDoctorSpecializationInput;
    Specialization: SpecializationCreateNestedOneWithoutDoctorSpecializationInput;
};
type DoctorSpecializationUncheckedCreateInput = {
    id?: string;
    doctorId: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
    Specialization?: SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
};
type DoctorSpecializationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationCreateManyInput = {
    id?: string;
    doctorId: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationListRelationFilter = {
    every?: DoctorSpecializationWhereInput;
    some?: DoctorSpecializationWhereInput;
    none?: DoctorSpecializationWhereInput;
};
type DoctorSpecializationOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput = {
    doctorId: string;
    specializationId: string;
};
type DoctorSpecializationCountOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorSpecializationMaxOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorSpecializationMinOrderByAggregateInput = {
    id?: SortOrder;
    doctorId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type DoctorSpecializationCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput> | DoctorSpecializationCreateWithoutDoctorInput[] | DoctorSpecializationUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutDoctorInput | DoctorSpecializationCreateOrConnectWithoutDoctorInput[];
    createMany?: DoctorSpecializationCreateManyDoctorInputEnvelope;
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
};
type DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput> | DoctorSpecializationCreateWithoutDoctorInput[] | DoctorSpecializationUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutDoctorInput | DoctorSpecializationCreateOrConnectWithoutDoctorInput[];
    createMany?: DoctorSpecializationCreateManyDoctorInputEnvelope;
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
};
type DoctorSpecializationUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput> | DoctorSpecializationCreateWithoutDoctorInput[] | DoctorSpecializationUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutDoctorInput | DoctorSpecializationCreateOrConnectWithoutDoctorInput[];
    upsert?: DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput | DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: DoctorSpecializationCreateManyDoctorInputEnvelope;
    set?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    disconnect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    delete?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    update?: DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput | DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput | DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
};
type DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput> | DoctorSpecializationCreateWithoutDoctorInput[] | DoctorSpecializationUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutDoctorInput | DoctorSpecializationCreateOrConnectWithoutDoctorInput[];
    upsert?: DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput | DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: DoctorSpecializationCreateManyDoctorInputEnvelope;
    set?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    disconnect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    delete?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    update?: DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput | DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput | DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
};
type DoctorSpecializationCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput> | DoctorSpecializationCreateWithoutSpecializationInput[] | DoctorSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutSpecializationInput | DoctorSpecializationCreateOrConnectWithoutSpecializationInput[];
    createMany?: DoctorSpecializationCreateManySpecializationInputEnvelope;
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
};
type DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput> | DoctorSpecializationCreateWithoutSpecializationInput[] | DoctorSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutSpecializationInput | DoctorSpecializationCreateOrConnectWithoutSpecializationInput[];
    createMany?: DoctorSpecializationCreateManySpecializationInputEnvelope;
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
};
type DoctorSpecializationUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput> | DoctorSpecializationCreateWithoutSpecializationInput[] | DoctorSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutSpecializationInput | DoctorSpecializationCreateOrConnectWithoutSpecializationInput[];
    upsert?: DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput | DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput[];
    createMany?: DoctorSpecializationCreateManySpecializationInputEnvelope;
    set?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    disconnect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    delete?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    update?: DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput | DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput[];
    updateMany?: DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput | DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput[];
    deleteMany?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
};
type DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput> | DoctorSpecializationCreateWithoutSpecializationInput[] | DoctorSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: DoctorSpecializationCreateOrConnectWithoutSpecializationInput | DoctorSpecializationCreateOrConnectWithoutSpecializationInput[];
    upsert?: DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput | DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput[];
    createMany?: DoctorSpecializationCreateManySpecializationInputEnvelope;
    set?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    disconnect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    delete?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    connect?: DoctorSpecializationWhereUniqueInput | DoctorSpecializationWhereUniqueInput[];
    update?: DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput | DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput[];
    updateMany?: DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput | DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput[];
    deleteMany?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
};
type DoctorSpecializationCreateWithoutDoctorInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Specialization: SpecializationCreateNestedOneWithoutDoctorSpecializationInput;
};
type DoctorSpecializationUncheckedCreateWithoutDoctorInput = {
    id?: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationCreateOrConnectWithoutDoctorInput = {
    where: DoctorSpecializationWhereUniqueInput;
    create: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput>;
};
type DoctorSpecializationCreateManyDoctorInputEnvelope = {
    data: DoctorSpecializationCreateManyDoctorInput | DoctorSpecializationCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorSpecializationWhereUniqueInput;
    update: XOR<DoctorSpecializationUpdateWithoutDoctorInput, DoctorSpecializationUncheckedUpdateWithoutDoctorInput>;
    create: XOR<DoctorSpecializationCreateWithoutDoctorInput, DoctorSpecializationUncheckedCreateWithoutDoctorInput>;
};
type DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorSpecializationWhereUniqueInput;
    data: XOR<DoctorSpecializationUpdateWithoutDoctorInput, DoctorSpecializationUncheckedUpdateWithoutDoctorInput>;
};
type DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorSpecializationScalarWhereInput;
    data: XOR<DoctorSpecializationUpdateManyMutationInput, DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput>;
};
type DoctorSpecializationScalarWhereInput = {
    AND?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
    OR?: DoctorSpecializationScalarWhereInput[];
    NOT?: DoctorSpecializationScalarWhereInput | DoctorSpecializationScalarWhereInput[];
    id?: StringFilter<"DoctorSpecialization"> | string;
    doctorId?: StringFilter<"DoctorSpecialization"> | string;
    specializationId?: StringFilter<"DoctorSpecialization"> | string;
    createdAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"DoctorSpecialization"> | Date | string;
};
type DoctorSpecializationCreateWithoutSpecializationInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor: DoctorCreateNestedOneWithoutDoctorSpecializationInput;
};
type DoctorSpecializationUncheckedCreateWithoutSpecializationInput = {
    id?: string;
    doctorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationCreateOrConnectWithoutSpecializationInput = {
    where: DoctorSpecializationWhereUniqueInput;
    create: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput>;
};
type DoctorSpecializationCreateManySpecializationInputEnvelope = {
    data: DoctorSpecializationCreateManySpecializationInput | DoctorSpecializationCreateManySpecializationInput[];
    skipDuplicates?: boolean;
};
type DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput = {
    where: DoctorSpecializationWhereUniqueInput;
    update: XOR<DoctorSpecializationUpdateWithoutSpecializationInput, DoctorSpecializationUncheckedUpdateWithoutSpecializationInput>;
    create: XOR<DoctorSpecializationCreateWithoutSpecializationInput, DoctorSpecializationUncheckedCreateWithoutSpecializationInput>;
};
type DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput = {
    where: DoctorSpecializationWhereUniqueInput;
    data: XOR<DoctorSpecializationUpdateWithoutSpecializationInput, DoctorSpecializationUncheckedUpdateWithoutSpecializationInput>;
};
type DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput = {
    where: DoctorSpecializationScalarWhereInput;
    data: XOR<DoctorSpecializationUpdateManyMutationInput, DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput>;
};
type DoctorSpecializationCreateManyDoctorInput = {
    id?: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Specialization?: SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
};
type DoctorSpecializationUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationCreateManySpecializationInput = {
    id?: string;
    doctorId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type DoctorSpecializationUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
};
type DoctorSpecializationUncheckedUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type DoctorSpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorSpecialization"]>;
type DoctorSpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorSpecialization"]>;
type DoctorSpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    doctorId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["doctorSpecialization"]>;
type DoctorSpecializationSelectScalar = {
    id?: boolean;
    doctorId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type DoctorSpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "doctorId" | "specializationId" | "createdAt" | "updatedAt", ExtArgs["result"]["doctorSpecialization"]>;
type DoctorSpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type DoctorSpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type DoctorSpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type $DoctorSpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "DoctorSpecialization";
    objects: {
        Doctor: $DoctorPayload<ExtArgs>;
        Specialization: $SpecializationPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        doctorId: string;
        specializationId: string;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["doctorSpecialization"]>;
    composites: {};
};
type DoctorSpecializationGetPayload<S extends boolean | null | undefined | DoctorSpecializationDefaultArgs> = runtime.Types.Result.GetResult<$DoctorSpecializationPayload, S>;
type DoctorSpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<DoctorSpecializationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DoctorSpecializationCountAggregateInputType | true;
};
interface DoctorSpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['DoctorSpecialization'];
        meta: {
            name: 'DoctorSpecialization';
        };
    };
    /**
     * Find zero or one DoctorSpecialization that matches the filter.
     * @param {DoctorSpecializationFindUniqueArgs} args - Arguments to find a DoctorSpecialization
     * @example
     * // Get one DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorSpecializationFindUniqueArgs>(args: SelectSubset<T, DoctorSpecializationFindUniqueArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one DoctorSpecialization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DoctorSpecializationFindUniqueOrThrowArgs} args - Arguments to find a DoctorSpecialization
     * @example
     * // Get one DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorSpecializationFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorSpecializationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorSpecialization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationFindFirstArgs} args - Arguments to find a DoctorSpecialization
     * @example
     * // Get one DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorSpecializationFindFirstArgs>(args?: SelectSubset<T, DoctorSpecializationFindFirstArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first DoctorSpecialization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationFindFirstOrThrowArgs} args - Arguments to find a DoctorSpecialization
     * @example
     * // Get one DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorSpecializationFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorSpecializationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more DoctorSpecializations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorSpecializations
     * const doctorSpecializations = await prisma.doctorSpecialization.findMany()
     *
     * // Get first 10 DoctorSpecializations
     * const doctorSpecializations = await prisma.doctorSpecialization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const doctorSpecializationWithIdOnly = await prisma.doctorSpecialization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DoctorSpecializationFindManyArgs>(args?: SelectSubset<T, DoctorSpecializationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a DoctorSpecialization.
     * @param {DoctorSpecializationCreateArgs} args - Arguments to create a DoctorSpecialization.
     * @example
     * // Create one DoctorSpecialization
     * const DoctorSpecialization = await prisma.doctorSpecialization.create({
     *   data: {
     *     // ... data to create a DoctorSpecialization
     *   }
     * })
     *
     */
    create<T extends DoctorSpecializationCreateArgs>(args: SelectSubset<T, DoctorSpecializationCreateArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many DoctorSpecializations.
     * @param {DoctorSpecializationCreateManyArgs} args - Arguments to create many DoctorSpecializations.
     * @example
     * // Create many DoctorSpecializations
     * const doctorSpecialization = await prisma.doctorSpecialization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DoctorSpecializationCreateManyArgs>(args?: SelectSubset<T, DoctorSpecializationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many DoctorSpecializations and returns the data saved in the database.
     * @param {DoctorSpecializationCreateManyAndReturnArgs} args - Arguments to create many DoctorSpecializations.
     * @example
     * // Create many DoctorSpecializations
     * const doctorSpecialization = await prisma.doctorSpecialization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DoctorSpecializations and only return the `id`
     * const doctorSpecializationWithIdOnly = await prisma.doctorSpecialization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DoctorSpecializationCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorSpecializationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a DoctorSpecialization.
     * @param {DoctorSpecializationDeleteArgs} args - Arguments to delete one DoctorSpecialization.
     * @example
     * // Delete one DoctorSpecialization
     * const DoctorSpecialization = await prisma.doctorSpecialization.delete({
     *   where: {
     *     // ... filter to delete one DoctorSpecialization
     *   }
     * })
     *
     */
    delete<T extends DoctorSpecializationDeleteArgs>(args: SelectSubset<T, DoctorSpecializationDeleteArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one DoctorSpecialization.
     * @param {DoctorSpecializationUpdateArgs} args - Arguments to update one DoctorSpecialization.
     * @example
     * // Update one DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DoctorSpecializationUpdateArgs>(args: SelectSubset<T, DoctorSpecializationUpdateArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more DoctorSpecializations.
     * @param {DoctorSpecializationDeleteManyArgs} args - Arguments to filter DoctorSpecializations to delete.
     * @example
     * // Delete a few DoctorSpecializations
     * const { count } = await prisma.doctorSpecialization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DoctorSpecializationDeleteManyArgs>(args?: SelectSubset<T, DoctorSpecializationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorSpecializations
     * const doctorSpecialization = await prisma.doctorSpecialization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DoctorSpecializationUpdateManyArgs>(args: SelectSubset<T, DoctorSpecializationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more DoctorSpecializations and returns the data updated in the database.
     * @param {DoctorSpecializationUpdateManyAndReturnArgs} args - Arguments to update many DoctorSpecializations.
     * @example
     * // Update many DoctorSpecializations
     * const doctorSpecialization = await prisma.doctorSpecialization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DoctorSpecializations and only return the `id`
     * const doctorSpecializationWithIdOnly = await prisma.doctorSpecialization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DoctorSpecializationUpdateManyAndReturnArgs>(args: SelectSubset<T, DoctorSpecializationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one DoctorSpecialization.
     * @param {DoctorSpecializationUpsertArgs} args - Arguments to update or create a DoctorSpecialization.
     * @example
     * // Update or create a DoctorSpecialization
     * const doctorSpecialization = await prisma.doctorSpecialization.upsert({
     *   create: {
     *     // ... data to create a DoctorSpecialization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorSpecialization we want to update
     *   }
     * })
     */
    upsert<T extends DoctorSpecializationUpsertArgs>(args: SelectSubset<T, DoctorSpecializationUpsertArgs<ExtArgs>>): Prisma__DoctorSpecializationClient<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of DoctorSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationCountArgs} args - Arguments to filter DoctorSpecializations to count.
     * @example
     * // Count the number of DoctorSpecializations
     * const count = await prisma.doctorSpecialization.count({
     *   where: {
     *     // ... the filter for the DoctorSpecializations we want to count
     *   }
     * })
    **/
    count<T extends DoctorSpecializationCountArgs>(args?: Subset<T, DoctorSpecializationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], DoctorSpecializationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a DoctorSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorSpecializationAggregateArgs>(args: Subset<T, DoctorSpecializationAggregateArgs>): PrismaPromise<GetDoctorSpecializationAggregateType<T>>;
    /**
     * Group by DoctorSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorSpecializationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends DoctorSpecializationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: DoctorSpecializationGroupByArgs['orderBy'];
    } : {
        orderBy?: DoctorSpecializationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, DoctorSpecializationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorSpecializationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the DoctorSpecialization model
     */
    readonly fields: DoctorSpecializationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for DoctorSpecialization.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__DoctorSpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Specialization<T extends SpecializationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecializationDefaultArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the DoctorSpecialization model
 */
interface DoctorSpecializationFieldRefs {
    readonly id: FieldRef<"DoctorSpecialization", 'String'>;
    readonly doctorId: FieldRef<"DoctorSpecialization", 'String'>;
    readonly specializationId: FieldRef<"DoctorSpecialization", 'String'>;
    readonly createdAt: FieldRef<"DoctorSpecialization", 'DateTime'>;
    readonly updatedAt: FieldRef<"DoctorSpecialization", 'DateTime'>;
}
/**
 * DoctorSpecialization findUnique
 */
type DoctorSpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorSpecialization to fetch.
     */
    where: DoctorSpecializationWhereUniqueInput;
};
/**
 * DoctorSpecialization findUniqueOrThrow
 */
type DoctorSpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorSpecialization to fetch.
     */
    where: DoctorSpecializationWhereUniqueInput;
};
/**
 * DoctorSpecialization findFirst
 */
type DoctorSpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorSpecialization to fetch.
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorSpecializations to fetch.
     */
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorSpecializations.
     */
    cursor?: DoctorSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorSpecializations.
     */
    distinct?: DoctorSpecializationScalarFieldEnum | DoctorSpecializationScalarFieldEnum[];
};
/**
 * DoctorSpecialization findFirstOrThrow
 */
type DoctorSpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorSpecialization to fetch.
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorSpecializations to fetch.
     */
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DoctorSpecializations.
     */
    cursor?: DoctorSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DoctorSpecializations.
     */
    distinct?: DoctorSpecializationScalarFieldEnum | DoctorSpecializationScalarFieldEnum[];
};
/**
 * DoctorSpecialization findMany
 */
type DoctorSpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which DoctorSpecializations to fetch.
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DoctorSpecializations to fetch.
     */
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DoctorSpecializations.
     */
    cursor?: DoctorSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` DoctorSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DoctorSpecializations.
     */
    skip?: number;
    distinct?: DoctorSpecializationScalarFieldEnum | DoctorSpecializationScalarFieldEnum[];
};
/**
 * DoctorSpecialization create
 */
type DoctorSpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to create a DoctorSpecialization.
     */
    data: XOR<DoctorSpecializationCreateInput, DoctorSpecializationUncheckedCreateInput>;
};
/**
 * DoctorSpecialization createMany
 */
type DoctorSpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorSpecializations.
     */
    data: DoctorSpecializationCreateManyInput | DoctorSpecializationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * DoctorSpecialization createManyAndReturn
 */
type DoctorSpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * The data used to create many DoctorSpecializations.
     */
    data: DoctorSpecializationCreateManyInput | DoctorSpecializationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorSpecialization update
 */
type DoctorSpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to update a DoctorSpecialization.
     */
    data: XOR<DoctorSpecializationUpdateInput, DoctorSpecializationUncheckedUpdateInput>;
    /**
     * Choose, which DoctorSpecialization to update.
     */
    where: DoctorSpecializationWhereUniqueInput;
};
/**
 * DoctorSpecialization updateMany
 */
type DoctorSpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorSpecializations.
     */
    data: XOR<DoctorSpecializationUpdateManyMutationInput, DoctorSpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorSpecializations to update
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * Limit how many DoctorSpecializations to update.
     */
    limit?: number;
};
/**
 * DoctorSpecialization updateManyAndReturn
 */
type DoctorSpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * The data used to update DoctorSpecializations.
     */
    data: XOR<DoctorSpecializationUpdateManyMutationInput, DoctorSpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which DoctorSpecializations to update
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * Limit how many DoctorSpecializations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * DoctorSpecialization upsert
 */
type DoctorSpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * The filter to search for the DoctorSpecialization to update in case it exists.
     */
    where: DoctorSpecializationWhereUniqueInput;
    /**
     * In case the DoctorSpecialization found by the `where` argument doesn't exist, create a new DoctorSpecialization with this data.
     */
    create: XOR<DoctorSpecializationCreateInput, DoctorSpecializationUncheckedCreateInput>;
    /**
     * In case the DoctorSpecialization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorSpecializationUpdateInput, DoctorSpecializationUncheckedUpdateInput>;
};
/**
 * DoctorSpecialization delete
 */
type DoctorSpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    /**
     * Filter which DoctorSpecialization to delete.
     */
    where: DoctorSpecializationWhereUniqueInput;
};
/**
 * DoctorSpecialization deleteMany
 */
type DoctorSpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSpecializations to delete
     */
    where?: DoctorSpecializationWhereInput;
    /**
     * Limit how many DoctorSpecializations to delete.
     */
    limit?: number;
};
/**
 * DoctorSpecialization without action
 */
type DoctorSpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
};

/**
 * Model Hospital
 *
 */
type HospitalModel = runtime.Types.Result.DefaultSelection<$HospitalPayload>;
type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null;
    _avg: HospitalAvgAggregateOutputType | null;
    _sum: HospitalSumAggregateOutputType | null;
    _min: HospitalMinAggregateOutputType | null;
    _max: HospitalMaxAggregateOutputType | null;
};
type HospitalAvgAggregateOutputType = {
    latitude: runtime.Decimal | null;
    longitude: runtime.Decimal | null;
    rating: runtime.Decimal | null;
    reviewCount: number | null;
    fee: runtime.Decimal | null;
};
type HospitalSumAggregateOutputType = {
    latitude: runtime.Decimal | null;
    longitude: runtime.Decimal | null;
    rating: runtime.Decimal | null;
    reviewCount: number | null;
    fee: runtime.Decimal | null;
};
type HospitalMinAggregateOutputType = {
    id: string | null;
    adminId: string | null;
    name: string | null;
    description: string | null;
    address: string | null;
    city: string | null;
    latitude: runtime.Decimal | null;
    longitude: runtime.Decimal | null;
    phone: string | null;
    email: string | null;
    website: string | null;
    openTime: Date | null;
    closeTime: Date | null;
    is24Hours: boolean | null;
    emergencySupport: boolean | null;
    rating: runtime.Decimal | null;
    reviewCount: number | null;
    logoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isDeactivated: boolean | null;
    fee: runtime.Decimal | null;
    type: HospitalType | null;
    timezone: string | null;
    subAccountId: string | null;
    logoId: string | null;
};
type HospitalMaxAggregateOutputType = {
    id: string | null;
    adminId: string | null;
    name: string | null;
    description: string | null;
    address: string | null;
    city: string | null;
    latitude: runtime.Decimal | null;
    longitude: runtime.Decimal | null;
    phone: string | null;
    email: string | null;
    website: string | null;
    openTime: Date | null;
    closeTime: Date | null;
    is24Hours: boolean | null;
    emergencySupport: boolean | null;
    rating: runtime.Decimal | null;
    reviewCount: number | null;
    logoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    isDeactivated: boolean | null;
    fee: runtime.Decimal | null;
    type: HospitalType | null;
    timezone: string | null;
    subAccountId: string | null;
    logoId: string | null;
};
type HospitalCountAggregateOutputType = {
    id: number;
    adminId: number;
    name: number;
    description: number;
    address: number;
    city: number;
    latitude: number;
    longitude: number;
    phone: number;
    email: number;
    website: number;
    openTime: number;
    closeTime: number;
    is24Hours: number;
    emergencySupport: number;
    rating: number;
    reviewCount: number;
    logoUrl: number;
    createdAt: number;
    updatedAt: number;
    isDeactivated: number;
    fee: number;
    type: number;
    timezone: number;
    subAccountId: number;
    logoId: number;
    _all: number;
};
type HospitalAvgAggregateInputType = {
    latitude?: true;
    longitude?: true;
    rating?: true;
    reviewCount?: true;
    fee?: true;
};
type HospitalSumAggregateInputType = {
    latitude?: true;
    longitude?: true;
    rating?: true;
    reviewCount?: true;
    fee?: true;
};
type HospitalMinAggregateInputType = {
    id?: true;
    adminId?: true;
    name?: true;
    description?: true;
    address?: true;
    city?: true;
    latitude?: true;
    longitude?: true;
    phone?: true;
    email?: true;
    website?: true;
    openTime?: true;
    closeTime?: true;
    is24Hours?: true;
    emergencySupport?: true;
    rating?: true;
    reviewCount?: true;
    logoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
    fee?: true;
    type?: true;
    timezone?: true;
    subAccountId?: true;
    logoId?: true;
};
type HospitalMaxAggregateInputType = {
    id?: true;
    adminId?: true;
    name?: true;
    description?: true;
    address?: true;
    city?: true;
    latitude?: true;
    longitude?: true;
    phone?: true;
    email?: true;
    website?: true;
    openTime?: true;
    closeTime?: true;
    is24Hours?: true;
    emergencySupport?: true;
    rating?: true;
    reviewCount?: true;
    logoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
    fee?: true;
    type?: true;
    timezone?: true;
    subAccountId?: true;
    logoId?: true;
};
type HospitalCountAggregateInputType = {
    id?: true;
    adminId?: true;
    name?: true;
    description?: true;
    address?: true;
    city?: true;
    latitude?: true;
    longitude?: true;
    phone?: true;
    email?: true;
    website?: true;
    openTime?: true;
    closeTime?: true;
    is24Hours?: true;
    emergencySupport?: true;
    rating?: true;
    reviewCount?: true;
    logoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    isDeactivated?: true;
    fee?: true;
    type?: true;
    timezone?: true;
    subAccountId?: true;
    logoId?: true;
    _all?: true;
};
type HospitalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Hospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: HospitalAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: HospitalSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType;
};
type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
    [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateHospital[P]> : GetScalarType<T[P], AggregateHospital[P]>;
};
type HospitalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[];
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum;
    having?: HospitalScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HospitalCountAggregateInputType | true;
    _avg?: HospitalAvgAggregateInputType;
    _sum?: HospitalSumAggregateInputType;
    _min?: HospitalMinAggregateInputType;
    _max?: HospitalMaxAggregateInputType;
};
type HospitalGroupByOutputType = {
    id: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal;
    longitude: runtime.Decimal;
    phone: string;
    email: string;
    website: string | null;
    openTime: Date | null;
    closeTime: Date | null;
    is24Hours: boolean;
    emergencySupport: boolean;
    rating: runtime.Decimal | null;
    reviewCount: number;
    logoUrl: string;
    createdAt: Date;
    updatedAt: Date;
    isDeactivated: boolean;
    fee: runtime.Decimal;
    type: HospitalType;
    timezone: string;
    subAccountId: string;
    logoId: string;
    _count: HospitalCountAggregateOutputType | null;
    _avg: HospitalAvgAggregateOutputType | null;
    _sum: HospitalSumAggregateOutputType | null;
    _min: HospitalMinAggregateOutputType | null;
    _max: HospitalMaxAggregateOutputType | null;
};
type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = PrismaPromise<Array<PickEnumerable<HospitalGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], HospitalGroupByOutputType[P]> : GetScalarType<T[P], HospitalGroupByOutputType[P]>;
}>>;
type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[];
    OR?: HospitalWhereInput[];
    NOT?: HospitalWhereInput | HospitalWhereInput[];
    id?: StringFilter<"Hospital"> | string;
    adminId?: StringFilter<"Hospital"> | string;
    name?: StringFilter<"Hospital"> | string;
    description?: StringFilter<"Hospital"> | string;
    address?: StringFilter<"Hospital"> | string;
    city?: StringFilter<"Hospital"> | string;
    latitude?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFilter<"Hospital"> | string;
    email?: StringFilter<"Hospital"> | string;
    website?: StringNullableFilter<"Hospital"> | string | null;
    openTime?: DateTimeNullableFilter<"Hospital"> | Date | string | null;
    closeTime?: DateTimeNullableFilter<"Hospital"> | Date | string | null;
    is24Hours?: BoolFilter<"Hospital"> | boolean;
    emergencySupport?: BoolFilter<"Hospital"> | boolean;
    rating?: DecimalNullableFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFilter<"Hospital"> | number;
    logoUrl?: StringFilter<"Hospital"> | string;
    createdAt?: DateTimeFilter<"Hospital"> | Date | string;
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string;
    isDeactivated?: BoolFilter<"Hospital"> | boolean;
    fee?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFilter<"Hospital"> | HospitalType;
    timezone?: StringFilter<"Hospital"> | string;
    subAccountId?: StringFilter<"Hospital"> | string;
    logoId?: StringFilter<"Hospital"> | string;
    Appointment?: AppointmentListRelationFilter;
    DoctorApplication?: DoctorApplicationListRelationFilter;
    DoctorHospitalProfile?: DoctorHospitalProfileListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    HospitalSpecialization?: HospitalSpecializationListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
};
type HospitalOrderByWithRelationInput = {
    id?: SortOrder;
    adminId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    latitude?: SortOrder;
    longitude?: SortOrder;
    phone?: SortOrder;
    email?: SortOrder;
    website?: SortOrderInput | SortOrder;
    openTime?: SortOrderInput | SortOrder;
    closeTime?: SortOrderInput | SortOrder;
    is24Hours?: SortOrder;
    emergencySupport?: SortOrder;
    rating?: SortOrderInput | SortOrder;
    reviewCount?: SortOrder;
    logoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    fee?: SortOrder;
    type?: SortOrder;
    timezone?: SortOrder;
    subAccountId?: SortOrder;
    logoId?: SortOrder;
    Appointment?: AppointmentOrderByRelationAggregateInput;
    DoctorApplication?: DoctorApplicationOrderByRelationAggregateInput;
    DoctorHospitalProfile?: DoctorHospitalProfileOrderByRelationAggregateInput;
    User?: UserOrderByWithRelationInput;
    HospitalSpecialization?: HospitalSpecializationOrderByRelationAggregateInput;
    Review?: ReviewOrderByRelationAggregateInput;
    SavedDoctorHospital?: SavedDoctorHospitalOrderByRelationAggregateInput;
    Schedule?: ScheduleOrderByRelationAggregateInput;
};
type HospitalWhereUniqueInput = AtLeast<{
    id?: string;
    adminId?: string;
    name?: string;
    AND?: HospitalWhereInput | HospitalWhereInput[];
    OR?: HospitalWhereInput[];
    NOT?: HospitalWhereInput | HospitalWhereInput[];
    description?: StringFilter<"Hospital"> | string;
    address?: StringFilter<"Hospital"> | string;
    city?: StringFilter<"Hospital"> | string;
    latitude?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFilter<"Hospital"> | string;
    email?: StringFilter<"Hospital"> | string;
    website?: StringNullableFilter<"Hospital"> | string | null;
    openTime?: DateTimeNullableFilter<"Hospital"> | Date | string | null;
    closeTime?: DateTimeNullableFilter<"Hospital"> | Date | string | null;
    is24Hours?: BoolFilter<"Hospital"> | boolean;
    emergencySupport?: BoolFilter<"Hospital"> | boolean;
    rating?: DecimalNullableFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFilter<"Hospital"> | number;
    logoUrl?: StringFilter<"Hospital"> | string;
    createdAt?: DateTimeFilter<"Hospital"> | Date | string;
    updatedAt?: DateTimeFilter<"Hospital"> | Date | string;
    isDeactivated?: BoolFilter<"Hospital"> | boolean;
    fee?: DecimalFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFilter<"Hospital"> | HospitalType;
    timezone?: StringFilter<"Hospital"> | string;
    subAccountId?: StringFilter<"Hospital"> | string;
    logoId?: StringFilter<"Hospital"> | string;
    Appointment?: AppointmentListRelationFilter;
    DoctorApplication?: DoctorApplicationListRelationFilter;
    DoctorHospitalProfile?: DoctorHospitalProfileListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    HospitalSpecialization?: HospitalSpecializationListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
}, "id" | "adminId" | "name">;
type HospitalOrderByWithAggregationInput = {
    id?: SortOrder;
    adminId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    latitude?: SortOrder;
    longitude?: SortOrder;
    phone?: SortOrder;
    email?: SortOrder;
    website?: SortOrderInput | SortOrder;
    openTime?: SortOrderInput | SortOrder;
    closeTime?: SortOrderInput | SortOrder;
    is24Hours?: SortOrder;
    emergencySupport?: SortOrder;
    rating?: SortOrderInput | SortOrder;
    reviewCount?: SortOrder;
    logoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    fee?: SortOrder;
    type?: SortOrder;
    timezone?: SortOrder;
    subAccountId?: SortOrder;
    logoId?: SortOrder;
    _count?: HospitalCountOrderByAggregateInput;
    _avg?: HospitalAvgOrderByAggregateInput;
    _max?: HospitalMaxOrderByAggregateInput;
    _min?: HospitalMinOrderByAggregateInput;
    _sum?: HospitalSumOrderByAggregateInput;
};
type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[];
    OR?: HospitalScalarWhereWithAggregatesInput[];
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Hospital"> | string;
    adminId?: StringWithAggregatesFilter<"Hospital"> | string;
    name?: StringWithAggregatesFilter<"Hospital"> | string;
    description?: StringWithAggregatesFilter<"Hospital"> | string;
    address?: StringWithAggregatesFilter<"Hospital"> | string;
    city?: StringWithAggregatesFilter<"Hospital"> | string;
    latitude?: DecimalWithAggregatesFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalWithAggregatesFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringWithAggregatesFilter<"Hospital"> | string;
    email?: StringWithAggregatesFilter<"Hospital"> | string;
    website?: StringNullableWithAggregatesFilter<"Hospital"> | string | null;
    openTime?: DateTimeNullableWithAggregatesFilter<"Hospital"> | Date | string | null;
    closeTime?: DateTimeNullableWithAggregatesFilter<"Hospital"> | Date | string | null;
    is24Hours?: BoolWithAggregatesFilter<"Hospital"> | boolean;
    emergencySupport?: BoolWithAggregatesFilter<"Hospital"> | boolean;
    rating?: DecimalNullableWithAggregatesFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntWithAggregatesFilter<"Hospital"> | number;
    logoUrl?: StringWithAggregatesFilter<"Hospital"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string;
    isDeactivated?: BoolWithAggregatesFilter<"Hospital"> | boolean;
    fee?: DecimalWithAggregatesFilter<"Hospital"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeWithAggregatesFilter<"Hospital"> | HospitalType;
    timezone?: StringWithAggregatesFilter<"Hospital"> | string;
    subAccountId?: StringWithAggregatesFilter<"Hospital"> | string;
    logoId?: StringWithAggregatesFilter<"Hospital"> | string;
};
type HospitalCreateInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateManyInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
};
type HospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
};
type HospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
};
type HospitalScalarRelationFilter = {
    is?: HospitalWhereInput;
    isNot?: HospitalWhereInput;
};
type HospitalCountOrderByAggregateInput = {
    id?: SortOrder;
    adminId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    latitude?: SortOrder;
    longitude?: SortOrder;
    phone?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    openTime?: SortOrder;
    closeTime?: SortOrder;
    is24Hours?: SortOrder;
    emergencySupport?: SortOrder;
    rating?: SortOrder;
    reviewCount?: SortOrder;
    logoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    fee?: SortOrder;
    type?: SortOrder;
    timezone?: SortOrder;
    subAccountId?: SortOrder;
    logoId?: SortOrder;
};
type HospitalAvgOrderByAggregateInput = {
    latitude?: SortOrder;
    longitude?: SortOrder;
    rating?: SortOrder;
    reviewCount?: SortOrder;
    fee?: SortOrder;
};
type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder;
    adminId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    latitude?: SortOrder;
    longitude?: SortOrder;
    phone?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    openTime?: SortOrder;
    closeTime?: SortOrder;
    is24Hours?: SortOrder;
    emergencySupport?: SortOrder;
    rating?: SortOrder;
    reviewCount?: SortOrder;
    logoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    fee?: SortOrder;
    type?: SortOrder;
    timezone?: SortOrder;
    subAccountId?: SortOrder;
    logoId?: SortOrder;
};
type HospitalMinOrderByAggregateInput = {
    id?: SortOrder;
    adminId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    latitude?: SortOrder;
    longitude?: SortOrder;
    phone?: SortOrder;
    email?: SortOrder;
    website?: SortOrder;
    openTime?: SortOrder;
    closeTime?: SortOrder;
    is24Hours?: SortOrder;
    emergencySupport?: SortOrder;
    rating?: SortOrder;
    reviewCount?: SortOrder;
    logoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    isDeactivated?: SortOrder;
    fee?: SortOrder;
    type?: SortOrder;
    timezone?: SortOrder;
    subAccountId?: SortOrder;
    logoId?: SortOrder;
};
type HospitalSumOrderByAggregateInput = {
    latitude?: SortOrder;
    longitude?: SortOrder;
    rating?: SortOrder;
    reviewCount?: SortOrder;
    fee?: SortOrder;
};
type HospitalNullableScalarRelationFilter = {
    is?: HospitalWhereInput | null;
    isNot?: HospitalWhereInput | null;
};
type HospitalCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<HospitalCreateWithoutAppointmentInput, HospitalUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutAppointmentInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<HospitalCreateWithoutAppointmentInput, HospitalUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutAppointmentInput;
    upsert?: HospitalUpsertWithoutAppointmentInput;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutAppointmentInput, HospitalUpdateWithoutAppointmentInput>, HospitalUncheckedUpdateWithoutAppointmentInput>;
};
type HospitalCreateNestedOneWithoutDoctorApplicationInput = {
    create?: XOR<HospitalCreateWithoutDoctorApplicationInput, HospitalUncheckedCreateWithoutDoctorApplicationInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutDoctorApplicationInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput = {
    create?: XOR<HospitalCreateWithoutDoctorApplicationInput, HospitalUncheckedCreateWithoutDoctorApplicationInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutDoctorApplicationInput;
    upsert?: HospitalUpsertWithoutDoctorApplicationInput;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput, HospitalUpdateWithoutDoctorApplicationInput>, HospitalUncheckedUpdateWithoutDoctorApplicationInput>;
};
type HospitalCreateNestedOneWithoutDoctorHospitalProfileInput = {
    create?: XOR<HospitalCreateWithoutDoctorHospitalProfileInput, HospitalUncheckedCreateWithoutDoctorHospitalProfileInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutDoctorHospitalProfileInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput = {
    create?: XOR<HospitalCreateWithoutDoctorHospitalProfileInput, HospitalUncheckedCreateWithoutDoctorHospitalProfileInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutDoctorHospitalProfileInput;
    upsert?: HospitalUpsertWithoutDoctorHospitalProfileInput;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput, HospitalUpdateWithoutDoctorHospitalProfileInput>, HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput>;
};
type DecimalFieldUpdateOperationsInput = {
    set?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    increment?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    decrement?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    multiply?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    divide?: runtime.Decimal | runtime.DecimalJsLike | number | string;
};
type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
};
type NullableDecimalFieldUpdateOperationsInput = {
    set?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    increment?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    decrement?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    multiply?: runtime.Decimal | runtime.DecimalJsLike | number | string;
    divide?: runtime.Decimal | runtime.DecimalJsLike | number | string;
};
type EnumHospitalTypeFieldUpdateOperationsInput = {
    set?: HospitalType;
};
type HospitalCreateNestedOneWithoutHospitalSpecializationInput = {
    create?: XOR<HospitalCreateWithoutHospitalSpecializationInput, HospitalUncheckedCreateWithoutHospitalSpecializationInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutHospitalSpecializationInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput = {
    create?: XOR<HospitalCreateWithoutHospitalSpecializationInput, HospitalUncheckedCreateWithoutHospitalSpecializationInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutHospitalSpecializationInput;
    upsert?: HospitalUpsertWithoutHospitalSpecializationInput;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput, HospitalUpdateWithoutHospitalSpecializationInput>, HospitalUncheckedUpdateWithoutHospitalSpecializationInput>;
};
type HospitalCreateNestedOneWithoutReviewInput = {
    create?: XOR<HospitalCreateWithoutReviewInput, HospitalUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutReviewInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneWithoutReviewNestedInput = {
    create?: XOR<HospitalCreateWithoutReviewInput, HospitalUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutReviewInput;
    upsert?: HospitalUpsertWithoutReviewInput;
    disconnect?: HospitalWhereInput | boolean;
    delete?: HospitalWhereInput | boolean;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutReviewInput, HospitalUpdateWithoutReviewInput>, HospitalUncheckedUpdateWithoutReviewInput>;
};
type HospitalCreateNestedOneWithoutSavedDoctorHospitalInput = {
    create?: XOR<HospitalCreateWithoutSavedDoctorHospitalInput, HospitalUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutSavedDoctorHospitalInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput = {
    create?: XOR<HospitalCreateWithoutSavedDoctorHospitalInput, HospitalUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutSavedDoctorHospitalInput;
    upsert?: HospitalUpsertWithoutSavedDoctorHospitalInput;
    disconnect?: HospitalWhereInput | boolean;
    delete?: HospitalWhereInput | boolean;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, HospitalUpdateWithoutSavedDoctorHospitalInput>, HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type HospitalCreateNestedOneWithoutScheduleInput = {
    create?: XOR<HospitalCreateWithoutScheduleInput, HospitalUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutScheduleInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<HospitalCreateWithoutScheduleInput, HospitalUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutScheduleInput;
    upsert?: HospitalUpsertWithoutScheduleInput;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutScheduleInput, HospitalUpdateWithoutScheduleInput>, HospitalUncheckedUpdateWithoutScheduleInput>;
};
type HospitalCreateNestedOneWithoutUserInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput;
    connect?: HospitalWhereUniqueInput;
};
type HospitalUpdateOneWithoutUserNestedInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput;
    upsert?: HospitalUpsertWithoutUserInput;
    disconnect?: HospitalWhereInput | boolean;
    delete?: HospitalWhereInput | boolean;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutUserInput, HospitalUpdateWithoutUserInput>, HospitalUncheckedUpdateWithoutUserInput>;
};
type HospitalUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
    connectOrCreate?: HospitalCreateOrConnectWithoutUserInput;
    upsert?: HospitalUpsertWithoutUserInput;
    disconnect?: HospitalWhereInput | boolean;
    delete?: HospitalWhereInput | boolean;
    connect?: HospitalWhereUniqueInput;
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutUserInput, HospitalUpdateWithoutUserInput>, HospitalUncheckedUpdateWithoutUserInput>;
};
type HospitalCreateWithoutAppointmentInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutAppointmentInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutAppointmentInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutAppointmentInput, HospitalUncheckedCreateWithoutAppointmentInput>;
};
type HospitalUpsertWithoutAppointmentInput = {
    update: XOR<HospitalUpdateWithoutAppointmentInput, HospitalUncheckedUpdateWithoutAppointmentInput>;
    create: XOR<HospitalCreateWithoutAppointmentInput, HospitalUncheckedCreateWithoutAppointmentInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutAppointmentInput, HospitalUncheckedUpdateWithoutAppointmentInput>;
};
type HospitalUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutDoctorApplicationInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutDoctorApplicationInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutDoctorApplicationInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutDoctorApplicationInput, HospitalUncheckedCreateWithoutDoctorApplicationInput>;
};
type HospitalUpsertWithoutDoctorApplicationInput = {
    update: XOR<HospitalUpdateWithoutDoctorApplicationInput, HospitalUncheckedUpdateWithoutDoctorApplicationInput>;
    create: XOR<HospitalCreateWithoutDoctorApplicationInput, HospitalUncheckedCreateWithoutDoctorApplicationInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutDoctorApplicationInput, HospitalUncheckedUpdateWithoutDoctorApplicationInput>;
};
type HospitalUpdateWithoutDoctorApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutDoctorApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutDoctorHospitalProfileInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutDoctorHospitalProfileInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutDoctorHospitalProfileInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutDoctorHospitalProfileInput, HospitalUncheckedCreateWithoutDoctorHospitalProfileInput>;
};
type HospitalUpsertWithoutDoctorHospitalProfileInput = {
    update: XOR<HospitalUpdateWithoutDoctorHospitalProfileInput, HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput>;
    create: XOR<HospitalCreateWithoutDoctorHospitalProfileInput, HospitalUncheckedCreateWithoutDoctorHospitalProfileInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutDoctorHospitalProfileInput, HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput>;
};
type HospitalUpdateWithoutDoctorHospitalProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutHospitalSpecializationInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutHospitalSpecializationInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutHospitalSpecializationInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutHospitalSpecializationInput, HospitalUncheckedCreateWithoutHospitalSpecializationInput>;
};
type HospitalUpsertWithoutHospitalSpecializationInput = {
    update: XOR<HospitalUpdateWithoutHospitalSpecializationInput, HospitalUncheckedUpdateWithoutHospitalSpecializationInput>;
    create: XOR<HospitalCreateWithoutHospitalSpecializationInput, HospitalUncheckedCreateWithoutHospitalSpecializationInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutHospitalSpecializationInput, HospitalUncheckedUpdateWithoutHospitalSpecializationInput>;
};
type HospitalUpdateWithoutHospitalSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutHospitalSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutReviewInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutReviewInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutReviewInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutReviewInput, HospitalUncheckedCreateWithoutReviewInput>;
};
type HospitalUpsertWithoutReviewInput = {
    update: XOR<HospitalUpdateWithoutReviewInput, HospitalUncheckedUpdateWithoutReviewInput>;
    create: XOR<HospitalCreateWithoutReviewInput, HospitalUncheckedCreateWithoutReviewInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutReviewInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutReviewInput, HospitalUncheckedUpdateWithoutReviewInput>;
};
type HospitalUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutSavedDoctorHospitalInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutSavedDoctorHospitalInput, HospitalUncheckedCreateWithoutSavedDoctorHospitalInput>;
};
type HospitalUpsertWithoutSavedDoctorHospitalInput = {
    update: XOR<HospitalUpdateWithoutSavedDoctorHospitalInput, HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput>;
    create: XOR<HospitalCreateWithoutSavedDoctorHospitalInput, HospitalUncheckedCreateWithoutSavedDoctorHospitalInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutSavedDoctorHospitalInput, HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type HospitalUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutScheduleInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    User: UserCreateNestedOneWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutScheduleInput = {
    id?: string;
    adminId: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutScheduleInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutScheduleInput, HospitalUncheckedCreateWithoutScheduleInput>;
};
type HospitalUpsertWithoutScheduleInput = {
    update: XOR<HospitalUpdateWithoutScheduleInput, HospitalUncheckedUpdateWithoutScheduleInput>;
    create: XOR<HospitalCreateWithoutScheduleInput, HospitalUncheckedCreateWithoutScheduleInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutScheduleInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutScheduleInput, HospitalUncheckedUpdateWithoutScheduleInput>;
};
type HospitalUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    adminId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
};
type HospitalCreateWithoutUserInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutHospitalInput;
    Review?: ReviewCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleCreateNestedManyWithoutHospitalInput;
};
type HospitalUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    description: string;
    address: string;
    city: string;
    latitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude: runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone: string;
    email: string;
    website?: string | null;
    openTime?: Date | string | null;
    closeTime?: Date | string | null;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: number;
    logoUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    isDeactivated?: boolean;
    fee: runtime.Decimal | runtime.DecimalJsLike | number | string;
    type: HospitalType;
    timezone?: string;
    subAccountId: string;
    logoId: string;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutHospitalInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
};
type HospitalCreateOrConnectWithoutUserInput = {
    where: HospitalWhereUniqueInput;
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
};
type HospitalUpsertWithoutUserInput = {
    update: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>;
    create: XOR<HospitalCreateWithoutUserInput, HospitalUncheckedCreateWithoutUserInput>;
    where?: HospitalWhereInput;
};
type HospitalUpdateToOneWithWhereWithoutUserInput = {
    where?: HospitalWhereInput;
    data: XOR<HospitalUpdateWithoutUserInput, HospitalUncheckedUpdateWithoutUserInput>;
};
type HospitalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUpdateManyWithoutHospitalNestedInput;
};
type HospitalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    latitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    longitude?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    phone?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    openTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    closeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    is24Hours?: BoolFieldUpdateOperationsInput | boolean;
    emergencySupport?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableDecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    reviewCount?: IntFieldUpdateOperationsInput | number;
    logoUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    fee?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    type?: EnumHospitalTypeFieldUpdateOperationsInput | HospitalType;
    timezone?: StringFieldUpdateOperationsInput | string;
    subAccountId?: StringFieldUpdateOperationsInput | string;
    logoId?: StringFieldUpdateOperationsInput | string;
    Appointment?: AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
    DoctorHospitalProfile?: DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
};
/**
 * Count Type HospitalCountOutputType
 */
type HospitalCountOutputType = {
    Appointment: number;
    DoctorApplication: number;
    DoctorHospitalProfile: number;
    HospitalSpecialization: number;
    Review: number;
    SavedDoctorHospital: number;
    Schedule: number;
};
type HospitalCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | HospitalCountOutputTypeCountAppointmentArgs;
    DoctorApplication?: boolean | HospitalCountOutputTypeCountDoctorApplicationArgs;
    DoctorHospitalProfile?: boolean | HospitalCountOutputTypeCountDoctorHospitalProfileArgs;
    HospitalSpecialization?: boolean | HospitalCountOutputTypeCountHospitalSpecializationArgs;
    Review?: boolean | HospitalCountOutputTypeCountReviewArgs;
    SavedDoctorHospital?: boolean | HospitalCountOutputTypeCountSavedDoctorHospitalArgs;
    Schedule?: boolean | HospitalCountOutputTypeCountScheduleArgs;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalCountOutputType
     */
    select?: HospitalCountOutputTypeSelect<ExtArgs> | null;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountDoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorApplicationWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorHospitalProfileWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountHospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: HospitalSpecializationWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ReviewWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SavedDoctorHospitalWhereInput;
};
/**
 * HospitalCountOutputType without action
 */
type HospitalCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput;
};
type HospitalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    adminId?: boolean;
    name?: boolean;
    description?: boolean;
    address?: boolean;
    city?: boolean;
    latitude?: boolean;
    longitude?: boolean;
    phone?: boolean;
    email?: boolean;
    website?: boolean;
    openTime?: boolean;
    closeTime?: boolean;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: boolean;
    reviewCount?: boolean;
    logoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    fee?: boolean;
    type?: boolean;
    timezone?: boolean;
    subAccountId?: boolean;
    logoId?: boolean;
    Appointment?: boolean | Hospital$AppointmentArgs<ExtArgs>;
    DoctorApplication?: boolean | Hospital$DoctorApplicationArgs<ExtArgs>;
    DoctorHospitalProfile?: boolean | Hospital$DoctorHospitalProfileArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    HospitalSpecialization?: boolean | Hospital$HospitalSpecializationArgs<ExtArgs>;
    Review?: boolean | Hospital$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | Hospital$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | Hospital$ScheduleArgs<ExtArgs>;
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospital"]>;
type HospitalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    adminId?: boolean;
    name?: boolean;
    description?: boolean;
    address?: boolean;
    city?: boolean;
    latitude?: boolean;
    longitude?: boolean;
    phone?: boolean;
    email?: boolean;
    website?: boolean;
    openTime?: boolean;
    closeTime?: boolean;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: boolean;
    reviewCount?: boolean;
    logoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    fee?: boolean;
    type?: boolean;
    timezone?: boolean;
    subAccountId?: boolean;
    logoId?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospital"]>;
type HospitalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    adminId?: boolean;
    name?: boolean;
    description?: boolean;
    address?: boolean;
    city?: boolean;
    latitude?: boolean;
    longitude?: boolean;
    phone?: boolean;
    email?: boolean;
    website?: boolean;
    openTime?: boolean;
    closeTime?: boolean;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: boolean;
    reviewCount?: boolean;
    logoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    fee?: boolean;
    type?: boolean;
    timezone?: boolean;
    subAccountId?: boolean;
    logoId?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospital"]>;
type HospitalSelectScalar = {
    id?: boolean;
    adminId?: boolean;
    name?: boolean;
    description?: boolean;
    address?: boolean;
    city?: boolean;
    latitude?: boolean;
    longitude?: boolean;
    phone?: boolean;
    email?: boolean;
    website?: boolean;
    openTime?: boolean;
    closeTime?: boolean;
    is24Hours?: boolean;
    emergencySupport?: boolean;
    rating?: boolean;
    reviewCount?: boolean;
    logoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    isDeactivated?: boolean;
    fee?: boolean;
    type?: boolean;
    timezone?: boolean;
    subAccountId?: boolean;
    logoId?: boolean;
};
type HospitalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "adminId" | "name" | "description" | "address" | "city" | "latitude" | "longitude" | "phone" | "email" | "website" | "openTime" | "closeTime" | "is24Hours" | "emergencySupport" | "rating" | "reviewCount" | "logoUrl" | "createdAt" | "updatedAt" | "isDeactivated" | "fee" | "type" | "timezone" | "subAccountId" | "logoId", ExtArgs["result"]["hospital"]>;
type HospitalInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Hospital$AppointmentArgs<ExtArgs>;
    DoctorApplication?: boolean | Hospital$DoctorApplicationArgs<ExtArgs>;
    DoctorHospitalProfile?: boolean | Hospital$DoctorHospitalProfileArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    HospitalSpecialization?: boolean | Hospital$HospitalSpecializationArgs<ExtArgs>;
    Review?: boolean | Hospital$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | Hospital$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | Hospital$ScheduleArgs<ExtArgs>;
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>;
};
type HospitalIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type HospitalIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $HospitalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Hospital";
    objects: {
        Appointment: $AppointmentPayload<ExtArgs>[];
        DoctorApplication: $DoctorApplicationPayload<ExtArgs>[];
        DoctorHospitalProfile: $DoctorHospitalProfilePayload<ExtArgs>[];
        User: $UserPayload<ExtArgs>;
        HospitalSpecialization: $HospitalSpecializationPayload<ExtArgs>[];
        Review: $ReviewPayload<ExtArgs>[];
        SavedDoctorHospital: $SavedDoctorHospitalPayload<ExtArgs>[];
        Schedule: $SchedulePayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        adminId: string;
        name: string;
        description: string;
        address: string;
        city: string;
        latitude: runtime.Decimal;
        longitude: runtime.Decimal;
        phone: string;
        email: string;
        website: string | null;
        openTime: Date | null;
        closeTime: Date | null;
        is24Hours: boolean;
        emergencySupport: boolean;
        rating: runtime.Decimal | null;
        reviewCount: number;
        logoUrl: string;
        createdAt: Date;
        updatedAt: Date;
        isDeactivated: boolean;
        fee: runtime.Decimal;
        type: HospitalType;
        timezone: string;
        subAccountId: string;
        logoId: string;
    }, ExtArgs["result"]["hospital"]>;
    composites: {};
};
type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = runtime.Types.Result.GetResult<$HospitalPayload, S>;
type HospitalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: HospitalCountAggregateInputType | true;
};
interface HospitalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Hospital'];
        meta: {
            name: 'Hospital';
        };
    };
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     *
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     *
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Hospitals and returns the data saved in the database.
     * @param {HospitalCreateManyAndReturnArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     *
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Hospitals and returns the data updated in the database.
     * @param {HospitalUpdateManyAndReturnArgs} args - Arguments to update many Hospitals.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends HospitalUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(args?: Subset<T, HospitalCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], HospitalCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): PrismaPromise<GetHospitalAggregateType<T>>;
    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends HospitalGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: HospitalGroupByArgs['orderBy'];
    } : {
        orderBy?: HospitalGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Hospital model
     */
    readonly fields: HospitalFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Hospital.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__HospitalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment<T extends Hospital$AppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$AppointmentArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    DoctorApplication<T extends Hospital$DoctorApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$DoctorApplicationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    DoctorHospitalProfile<T extends Hospital$DoctorHospitalProfileArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$DoctorHospitalProfileArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorHospitalProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    HospitalSpecialization<T extends Hospital$HospitalSpecializationArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$HospitalSpecializationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Review<T extends Hospital$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$ReviewArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    SavedDoctorHospital<T extends Hospital$SavedDoctorHospitalArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$SavedDoctorHospitalArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Schedule<T extends Hospital$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$ScheduleArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Hospital model
 */
interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'String'>;
    readonly adminId: FieldRef<"Hospital", 'String'>;
    readonly name: FieldRef<"Hospital", 'String'>;
    readonly description: FieldRef<"Hospital", 'String'>;
    readonly address: FieldRef<"Hospital", 'String'>;
    readonly city: FieldRef<"Hospital", 'String'>;
    readonly latitude: FieldRef<"Hospital", 'Decimal'>;
    readonly longitude: FieldRef<"Hospital", 'Decimal'>;
    readonly phone: FieldRef<"Hospital", 'String'>;
    readonly email: FieldRef<"Hospital", 'String'>;
    readonly website: FieldRef<"Hospital", 'String'>;
    readonly openTime: FieldRef<"Hospital", 'DateTime'>;
    readonly closeTime: FieldRef<"Hospital", 'DateTime'>;
    readonly is24Hours: FieldRef<"Hospital", 'Boolean'>;
    readonly emergencySupport: FieldRef<"Hospital", 'Boolean'>;
    readonly rating: FieldRef<"Hospital", 'Decimal'>;
    readonly reviewCount: FieldRef<"Hospital", 'Int'>;
    readonly logoUrl: FieldRef<"Hospital", 'String'>;
    readonly createdAt: FieldRef<"Hospital", 'DateTime'>;
    readonly updatedAt: FieldRef<"Hospital", 'DateTime'>;
    readonly isDeactivated: FieldRef<"Hospital", 'Boolean'>;
    readonly fee: FieldRef<"Hospital", 'Decimal'>;
    readonly type: FieldRef<"Hospital", 'HospitalType'>;
    readonly timezone: FieldRef<"Hospital", 'String'>;
    readonly subAccountId: FieldRef<"Hospital", 'String'>;
    readonly logoId: FieldRef<"Hospital", 'String'>;
}
/**
 * Hospital findUnique
 */
type HospitalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput;
};
/**
 * Hospital findUniqueOrThrow
 */
type HospitalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput;
};
/**
 * Hospital findFirst
 */
type HospitalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Hospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[];
};
/**
 * Hospital findFirstOrThrow
 */
type HospitalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Hospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[];
};
/**
 * Hospital findMany
 */
type HospitalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Hospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hospitals.
     */
    skip?: number;
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[];
};
/**
 * Hospital create
 */
type HospitalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>;
};
/**
 * Hospital createMany
 */
type HospitalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Hospital createManyAndReturn
 */
type HospitalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Hospital update
 */
type HospitalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>;
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput;
};
/**
 * Hospital updateMany
 */
type HospitalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>;
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput;
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number;
};
/**
 * Hospital updateManyAndReturn
 */
type HospitalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>;
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput;
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Hospital upsert
 */
type HospitalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput;
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>;
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>;
};
/**
 * Hospital delete
 */
type HospitalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput;
};
/**
 * Hospital deleteMany
 */
type HospitalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput;
    /**
     * Limit how many Hospitals to delete.
     */
    limit?: number;
};
/**
 * Hospital.Appointment
 */
type Hospital$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    cursor?: AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Hospital.DoctorApplication
 */
type Hospital$DoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    where?: DoctorApplicationWhereInput;
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    cursor?: DoctorApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorApplicationScalarFieldEnum | DoctorApplicationScalarFieldEnum[];
};
/**
 * Hospital.DoctorHospitalProfile
 */
type Hospital$DoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorHospitalProfile
     */
    select?: DoctorHospitalProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorHospitalProfile
     */
    omit?: DoctorHospitalProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorHospitalProfileInclude<ExtArgs> | null;
    where?: DoctorHospitalProfileWhereInput;
    orderBy?: DoctorHospitalProfileOrderByWithRelationInput | DoctorHospitalProfileOrderByWithRelationInput[];
    cursor?: DoctorHospitalProfileWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorHospitalProfileScalarFieldEnum | DoctorHospitalProfileScalarFieldEnum[];
};
/**
 * Hospital.HospitalSpecialization
 */
type Hospital$HospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    where?: HospitalSpecializationWhereInput;
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    cursor?: HospitalSpecializationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: HospitalSpecializationScalarFieldEnum | HospitalSpecializationScalarFieldEnum[];
};
/**
 * Hospital.Review
 */
type Hospital$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * Hospital.SavedDoctorHospital
 */
type Hospital$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    where?: SavedDoctorHospitalWhereInput;
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * Hospital.Schedule
 */
type Hospital$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    cursor?: ScheduleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * Hospital without action
 */
type HospitalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
};

/**
 * Model HospitalSpecialization
 *
 */
type HospitalSpecializationModel = runtime.Types.Result.DefaultSelection<$HospitalSpecializationPayload>;
type AggregateHospitalSpecialization = {
    _count: HospitalSpecializationCountAggregateOutputType | null;
    _min: HospitalSpecializationMinAggregateOutputType | null;
    _max: HospitalSpecializationMaxAggregateOutputType | null;
};
type HospitalSpecializationMinAggregateOutputType = {
    id: string | null;
    hospitalId: string | null;
    specializationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type HospitalSpecializationMaxAggregateOutputType = {
    id: string | null;
    hospitalId: string | null;
    specializationId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type HospitalSpecializationCountAggregateOutputType = {
    id: number;
    hospitalId: number;
    specializationId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type HospitalSpecializationMinAggregateInputType = {
    id?: true;
    hospitalId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type HospitalSpecializationMaxAggregateInputType = {
    id?: true;
    hospitalId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type HospitalSpecializationCountAggregateInputType = {
    id?: true;
    hospitalId?: true;
    specializationId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type HospitalSpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which HospitalSpecialization to aggregate.
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HospitalSpecializations to fetch.
     */
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HospitalSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` HospitalSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HospitalSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned HospitalSpecializations
    **/
    _count?: true | HospitalSpecializationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: HospitalSpecializationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: HospitalSpecializationMaxAggregateInputType;
};
type GetHospitalSpecializationAggregateType<T extends HospitalSpecializationAggregateArgs> = {
    [P in keyof T & keyof AggregateHospitalSpecialization]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateHospitalSpecialization[P]> : GetScalarType<T[P], AggregateHospitalSpecialization[P]>;
};
type HospitalSpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: HospitalSpecializationWhereInput;
    orderBy?: HospitalSpecializationOrderByWithAggregationInput | HospitalSpecializationOrderByWithAggregationInput[];
    by: HospitalSpecializationScalarFieldEnum[] | HospitalSpecializationScalarFieldEnum;
    having?: HospitalSpecializationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HospitalSpecializationCountAggregateInputType | true;
    _min?: HospitalSpecializationMinAggregateInputType;
    _max?: HospitalSpecializationMaxAggregateInputType;
};
type HospitalSpecializationGroupByOutputType = {
    id: string;
    hospitalId: string;
    specializationId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: HospitalSpecializationCountAggregateOutputType | null;
    _min: HospitalSpecializationMinAggregateOutputType | null;
    _max: HospitalSpecializationMaxAggregateOutputType | null;
};
type GetHospitalSpecializationGroupByPayload<T extends HospitalSpecializationGroupByArgs> = PrismaPromise<Array<PickEnumerable<HospitalSpecializationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof HospitalSpecializationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], HospitalSpecializationGroupByOutputType[P]> : GetScalarType<T[P], HospitalSpecializationGroupByOutputType[P]>;
}>>;
type HospitalSpecializationWhereInput = {
    AND?: HospitalSpecializationWhereInput | HospitalSpecializationWhereInput[];
    OR?: HospitalSpecializationWhereInput[];
    NOT?: HospitalSpecializationWhereInput | HospitalSpecializationWhereInput[];
    id?: StringFilter<"HospitalSpecialization"> | string;
    hospitalId?: StringFilter<"HospitalSpecialization"> | string;
    specializationId?: StringFilter<"HospitalSpecialization"> | string;
    createdAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Specialization?: XOR<SpecializationScalarRelationFilter, SpecializationWhereInput>;
};
type HospitalSpecializationOrderByWithRelationInput = {
    id?: SortOrder;
    hospitalId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Hospital?: HospitalOrderByWithRelationInput;
    Specialization?: SpecializationOrderByWithRelationInput;
};
type HospitalSpecializationWhereUniqueInput = AtLeast<{
    id?: string;
    hospitalId_specializationId?: HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput;
    AND?: HospitalSpecializationWhereInput | HospitalSpecializationWhereInput[];
    OR?: HospitalSpecializationWhereInput[];
    NOT?: HospitalSpecializationWhereInput | HospitalSpecializationWhereInput[];
    hospitalId?: StringFilter<"HospitalSpecialization"> | string;
    specializationId?: StringFilter<"HospitalSpecialization"> | string;
    createdAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Specialization?: XOR<SpecializationScalarRelationFilter, SpecializationWhereInput>;
}, "id" | "hospitalId_specializationId">;
type HospitalSpecializationOrderByWithAggregationInput = {
    id?: SortOrder;
    hospitalId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: HospitalSpecializationCountOrderByAggregateInput;
    _max?: HospitalSpecializationMaxOrderByAggregateInput;
    _min?: HospitalSpecializationMinOrderByAggregateInput;
};
type HospitalSpecializationScalarWhereWithAggregatesInput = {
    AND?: HospitalSpecializationScalarWhereWithAggregatesInput | HospitalSpecializationScalarWhereWithAggregatesInput[];
    OR?: HospitalSpecializationScalarWhereWithAggregatesInput[];
    NOT?: HospitalSpecializationScalarWhereWithAggregatesInput | HospitalSpecializationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"HospitalSpecialization"> | string;
    hospitalId?: StringWithAggregatesFilter<"HospitalSpecialization"> | string;
    specializationId?: StringWithAggregatesFilter<"HospitalSpecialization"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"HospitalSpecialization"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"HospitalSpecialization"> | Date | string;
};
type HospitalSpecializationCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Hospital: HospitalCreateNestedOneWithoutHospitalSpecializationInput;
    Specialization: SpecializationCreateNestedOneWithoutHospitalSpecializationInput;
};
type HospitalSpecializationUncheckedCreateInput = {
    id?: string;
    hospitalId: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Hospital?: HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
    Specialization?: SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
};
type HospitalSpecializationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationCreateManyInput = {
    id?: string;
    hospitalId: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationListRelationFilter = {
    every?: HospitalSpecializationWhereInput;
    some?: HospitalSpecializationWhereInput;
    none?: HospitalSpecializationWhereInput;
};
type HospitalSpecializationOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput = {
    hospitalId: string;
    specializationId: string;
};
type HospitalSpecializationCountOrderByAggregateInput = {
    id?: SortOrder;
    hospitalId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type HospitalSpecializationMaxOrderByAggregateInput = {
    id?: SortOrder;
    hospitalId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type HospitalSpecializationMinOrderByAggregateInput = {
    id?: SortOrder;
    hospitalId?: SortOrder;
    specializationId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type HospitalSpecializationCreateNestedManyWithoutHospitalInput = {
    create?: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput> | HospitalSpecializationCreateWithoutHospitalInput[] | HospitalSpecializationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutHospitalInput | HospitalSpecializationCreateOrConnectWithoutHospitalInput[];
    createMany?: HospitalSpecializationCreateManyHospitalInputEnvelope;
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
};
type HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput> | HospitalSpecializationCreateWithoutHospitalInput[] | HospitalSpecializationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutHospitalInput | HospitalSpecializationCreateOrConnectWithoutHospitalInput[];
    createMany?: HospitalSpecializationCreateManyHospitalInputEnvelope;
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
};
type HospitalSpecializationUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput> | HospitalSpecializationCreateWithoutHospitalInput[] | HospitalSpecializationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutHospitalInput | HospitalSpecializationCreateOrConnectWithoutHospitalInput[];
    upsert?: HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput | HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: HospitalSpecializationCreateManyHospitalInputEnvelope;
    set?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    disconnect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    delete?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    update?: HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput | HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput | HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
};
type HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput> | HospitalSpecializationCreateWithoutHospitalInput[] | HospitalSpecializationUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutHospitalInput | HospitalSpecializationCreateOrConnectWithoutHospitalInput[];
    upsert?: HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput | HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: HospitalSpecializationCreateManyHospitalInputEnvelope;
    set?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    disconnect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    delete?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    update?: HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput | HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput | HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
};
type HospitalSpecializationCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput> | HospitalSpecializationCreateWithoutSpecializationInput[] | HospitalSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutSpecializationInput | HospitalSpecializationCreateOrConnectWithoutSpecializationInput[];
    createMany?: HospitalSpecializationCreateManySpecializationInputEnvelope;
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
};
type HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput> | HospitalSpecializationCreateWithoutSpecializationInput[] | HospitalSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutSpecializationInput | HospitalSpecializationCreateOrConnectWithoutSpecializationInput[];
    createMany?: HospitalSpecializationCreateManySpecializationInputEnvelope;
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
};
type HospitalSpecializationUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput> | HospitalSpecializationCreateWithoutSpecializationInput[] | HospitalSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutSpecializationInput | HospitalSpecializationCreateOrConnectWithoutSpecializationInput[];
    upsert?: HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput | HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput[];
    createMany?: HospitalSpecializationCreateManySpecializationInputEnvelope;
    set?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    disconnect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    delete?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    update?: HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput | HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput[];
    updateMany?: HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput | HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput[];
    deleteMany?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
};
type HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput> | HospitalSpecializationCreateWithoutSpecializationInput[] | HospitalSpecializationUncheckedCreateWithoutSpecializationInput[];
    connectOrCreate?: HospitalSpecializationCreateOrConnectWithoutSpecializationInput | HospitalSpecializationCreateOrConnectWithoutSpecializationInput[];
    upsert?: HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput | HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput[];
    createMany?: HospitalSpecializationCreateManySpecializationInputEnvelope;
    set?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    disconnect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    delete?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    connect?: HospitalSpecializationWhereUniqueInput | HospitalSpecializationWhereUniqueInput[];
    update?: HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput | HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput[];
    updateMany?: HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput | HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput[];
    deleteMany?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
};
type HospitalSpecializationCreateWithoutHospitalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Specialization: SpecializationCreateNestedOneWithoutHospitalSpecializationInput;
};
type HospitalSpecializationUncheckedCreateWithoutHospitalInput = {
    id?: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationCreateOrConnectWithoutHospitalInput = {
    where: HospitalSpecializationWhereUniqueInput;
    create: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput>;
};
type HospitalSpecializationCreateManyHospitalInputEnvelope = {
    data: HospitalSpecializationCreateManyHospitalInput | HospitalSpecializationCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput = {
    where: HospitalSpecializationWhereUniqueInput;
    update: XOR<HospitalSpecializationUpdateWithoutHospitalInput, HospitalSpecializationUncheckedUpdateWithoutHospitalInput>;
    create: XOR<HospitalSpecializationCreateWithoutHospitalInput, HospitalSpecializationUncheckedCreateWithoutHospitalInput>;
};
type HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput = {
    where: HospitalSpecializationWhereUniqueInput;
    data: XOR<HospitalSpecializationUpdateWithoutHospitalInput, HospitalSpecializationUncheckedUpdateWithoutHospitalInput>;
};
type HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput = {
    where: HospitalSpecializationScalarWhereInput;
    data: XOR<HospitalSpecializationUpdateManyMutationInput, HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput>;
};
type HospitalSpecializationScalarWhereInput = {
    AND?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
    OR?: HospitalSpecializationScalarWhereInput[];
    NOT?: HospitalSpecializationScalarWhereInput | HospitalSpecializationScalarWhereInput[];
    id?: StringFilter<"HospitalSpecialization"> | string;
    hospitalId?: StringFilter<"HospitalSpecialization"> | string;
    specializationId?: StringFilter<"HospitalSpecialization"> | string;
    createdAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
    updatedAt?: DateTimeFilter<"HospitalSpecialization"> | Date | string;
};
type HospitalSpecializationCreateWithoutSpecializationInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Hospital: HospitalCreateNestedOneWithoutHospitalSpecializationInput;
};
type HospitalSpecializationUncheckedCreateWithoutSpecializationInput = {
    id?: string;
    hospitalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationCreateOrConnectWithoutSpecializationInput = {
    where: HospitalSpecializationWhereUniqueInput;
    create: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput>;
};
type HospitalSpecializationCreateManySpecializationInputEnvelope = {
    data: HospitalSpecializationCreateManySpecializationInput | HospitalSpecializationCreateManySpecializationInput[];
    skipDuplicates?: boolean;
};
type HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput = {
    where: HospitalSpecializationWhereUniqueInput;
    update: XOR<HospitalSpecializationUpdateWithoutSpecializationInput, HospitalSpecializationUncheckedUpdateWithoutSpecializationInput>;
    create: XOR<HospitalSpecializationCreateWithoutSpecializationInput, HospitalSpecializationUncheckedCreateWithoutSpecializationInput>;
};
type HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput = {
    where: HospitalSpecializationWhereUniqueInput;
    data: XOR<HospitalSpecializationUpdateWithoutSpecializationInput, HospitalSpecializationUncheckedUpdateWithoutSpecializationInput>;
};
type HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput = {
    where: HospitalSpecializationScalarWhereInput;
    data: XOR<HospitalSpecializationUpdateManyMutationInput, HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput>;
};
type HospitalSpecializationCreateManyHospitalInput = {
    id?: string;
    specializationId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Specialization?: SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
};
type HospitalSpecializationUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    specializationId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationCreateManySpecializationInput = {
    id?: string;
    hospitalId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type HospitalSpecializationUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Hospital?: HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
};
type HospitalSpecializationUncheckedUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type HospitalSpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    hospitalId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospitalSpecialization"]>;
type HospitalSpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    hospitalId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospitalSpecialization"]>;
type HospitalSpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    hospitalId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["hospitalSpecialization"]>;
type HospitalSpecializationSelectScalar = {
    id?: boolean;
    hospitalId?: boolean;
    specializationId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type HospitalSpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "hospitalId" | "specializationId" | "createdAt" | "updatedAt", ExtArgs["result"]["hospitalSpecialization"]>;
type HospitalSpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type HospitalSpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type HospitalSpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Specialization?: boolean | SpecializationDefaultArgs<ExtArgs>;
};
type $HospitalSpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "HospitalSpecialization";
    objects: {
        Hospital: $HospitalPayload<ExtArgs>;
        Specialization: $SpecializationPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        hospitalId: string;
        specializationId: string;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["hospitalSpecialization"]>;
    composites: {};
};
type HospitalSpecializationGetPayload<S extends boolean | null | undefined | HospitalSpecializationDefaultArgs> = runtime.Types.Result.GetResult<$HospitalSpecializationPayload, S>;
type HospitalSpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<HospitalSpecializationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: HospitalSpecializationCountAggregateInputType | true;
};
interface HospitalSpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['HospitalSpecialization'];
        meta: {
            name: 'HospitalSpecialization';
        };
    };
    /**
     * Find zero or one HospitalSpecialization that matches the filter.
     * @param {HospitalSpecializationFindUniqueArgs} args - Arguments to find a HospitalSpecialization
     * @example
     * // Get one HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalSpecializationFindUniqueArgs>(args: SelectSubset<T, HospitalSpecializationFindUniqueArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one HospitalSpecialization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalSpecializationFindUniqueOrThrowArgs} args - Arguments to find a HospitalSpecialization
     * @example
     * // Get one HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalSpecializationFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalSpecializationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first HospitalSpecialization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationFindFirstArgs} args - Arguments to find a HospitalSpecialization
     * @example
     * // Get one HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalSpecializationFindFirstArgs>(args?: SelectSubset<T, HospitalSpecializationFindFirstArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first HospitalSpecialization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationFindFirstOrThrowArgs} args - Arguments to find a HospitalSpecialization
     * @example
     * // Get one HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalSpecializationFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalSpecializationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more HospitalSpecializations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HospitalSpecializations
     * const hospitalSpecializations = await prisma.hospitalSpecialization.findMany()
     *
     * // Get first 10 HospitalSpecializations
     * const hospitalSpecializations = await prisma.hospitalSpecialization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const hospitalSpecializationWithIdOnly = await prisma.hospitalSpecialization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HospitalSpecializationFindManyArgs>(args?: SelectSubset<T, HospitalSpecializationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a HospitalSpecialization.
     * @param {HospitalSpecializationCreateArgs} args - Arguments to create a HospitalSpecialization.
     * @example
     * // Create one HospitalSpecialization
     * const HospitalSpecialization = await prisma.hospitalSpecialization.create({
     *   data: {
     *     // ... data to create a HospitalSpecialization
     *   }
     * })
     *
     */
    create<T extends HospitalSpecializationCreateArgs>(args: SelectSubset<T, HospitalSpecializationCreateArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many HospitalSpecializations.
     * @param {HospitalSpecializationCreateManyArgs} args - Arguments to create many HospitalSpecializations.
     * @example
     * // Create many HospitalSpecializations
     * const hospitalSpecialization = await prisma.hospitalSpecialization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HospitalSpecializationCreateManyArgs>(args?: SelectSubset<T, HospitalSpecializationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many HospitalSpecializations and returns the data saved in the database.
     * @param {HospitalSpecializationCreateManyAndReturnArgs} args - Arguments to create many HospitalSpecializations.
     * @example
     * // Create many HospitalSpecializations
     * const hospitalSpecialization = await prisma.hospitalSpecialization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many HospitalSpecializations and only return the `id`
     * const hospitalSpecializationWithIdOnly = await prisma.hospitalSpecialization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HospitalSpecializationCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalSpecializationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a HospitalSpecialization.
     * @param {HospitalSpecializationDeleteArgs} args - Arguments to delete one HospitalSpecialization.
     * @example
     * // Delete one HospitalSpecialization
     * const HospitalSpecialization = await prisma.hospitalSpecialization.delete({
     *   where: {
     *     // ... filter to delete one HospitalSpecialization
     *   }
     * })
     *
     */
    delete<T extends HospitalSpecializationDeleteArgs>(args: SelectSubset<T, HospitalSpecializationDeleteArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one HospitalSpecialization.
     * @param {HospitalSpecializationUpdateArgs} args - Arguments to update one HospitalSpecialization.
     * @example
     * // Update one HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HospitalSpecializationUpdateArgs>(args: SelectSubset<T, HospitalSpecializationUpdateArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more HospitalSpecializations.
     * @param {HospitalSpecializationDeleteManyArgs} args - Arguments to filter HospitalSpecializations to delete.
     * @example
     * // Delete a few HospitalSpecializations
     * const { count } = await prisma.hospitalSpecialization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HospitalSpecializationDeleteManyArgs>(args?: SelectSubset<T, HospitalSpecializationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more HospitalSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HospitalSpecializations
     * const hospitalSpecialization = await prisma.hospitalSpecialization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HospitalSpecializationUpdateManyArgs>(args: SelectSubset<T, HospitalSpecializationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more HospitalSpecializations and returns the data updated in the database.
     * @param {HospitalSpecializationUpdateManyAndReturnArgs} args - Arguments to update many HospitalSpecializations.
     * @example
     * // Update many HospitalSpecializations
     * const hospitalSpecialization = await prisma.hospitalSpecialization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more HospitalSpecializations and only return the `id`
     * const hospitalSpecializationWithIdOnly = await prisma.hospitalSpecialization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends HospitalSpecializationUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalSpecializationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one HospitalSpecialization.
     * @param {HospitalSpecializationUpsertArgs} args - Arguments to update or create a HospitalSpecialization.
     * @example
     * // Update or create a HospitalSpecialization
     * const hospitalSpecialization = await prisma.hospitalSpecialization.upsert({
     *   create: {
     *     // ... data to create a HospitalSpecialization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HospitalSpecialization we want to update
     *   }
     * })
     */
    upsert<T extends HospitalSpecializationUpsertArgs>(args: SelectSubset<T, HospitalSpecializationUpsertArgs<ExtArgs>>): Prisma__HospitalSpecializationClient<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of HospitalSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationCountArgs} args - Arguments to filter HospitalSpecializations to count.
     * @example
     * // Count the number of HospitalSpecializations
     * const count = await prisma.hospitalSpecialization.count({
     *   where: {
     *     // ... the filter for the HospitalSpecializations we want to count
     *   }
     * })
    **/
    count<T extends HospitalSpecializationCountArgs>(args?: Subset<T, HospitalSpecializationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], HospitalSpecializationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a HospitalSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalSpecializationAggregateArgs>(args: Subset<T, HospitalSpecializationAggregateArgs>): PrismaPromise<GetHospitalSpecializationAggregateType<T>>;
    /**
     * Group by HospitalSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalSpecializationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends HospitalSpecializationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: HospitalSpecializationGroupByArgs['orderBy'];
    } : {
        orderBy?: HospitalSpecializationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, HospitalSpecializationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalSpecializationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the HospitalSpecialization model
     */
    readonly fields: HospitalSpecializationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for HospitalSpecialization.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__HospitalSpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Specialization<T extends SpecializationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecializationDefaultArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the HospitalSpecialization model
 */
interface HospitalSpecializationFieldRefs {
    readonly id: FieldRef<"HospitalSpecialization", 'String'>;
    readonly hospitalId: FieldRef<"HospitalSpecialization", 'String'>;
    readonly specializationId: FieldRef<"HospitalSpecialization", 'String'>;
    readonly createdAt: FieldRef<"HospitalSpecialization", 'DateTime'>;
    readonly updatedAt: FieldRef<"HospitalSpecialization", 'DateTime'>;
}
/**
 * HospitalSpecialization findUnique
 */
type HospitalSpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which HospitalSpecialization to fetch.
     */
    where: HospitalSpecializationWhereUniqueInput;
};
/**
 * HospitalSpecialization findUniqueOrThrow
 */
type HospitalSpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which HospitalSpecialization to fetch.
     */
    where: HospitalSpecializationWhereUniqueInput;
};
/**
 * HospitalSpecialization findFirst
 */
type HospitalSpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which HospitalSpecialization to fetch.
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HospitalSpecializations to fetch.
     */
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HospitalSpecializations.
     */
    cursor?: HospitalSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` HospitalSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HospitalSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HospitalSpecializations.
     */
    distinct?: HospitalSpecializationScalarFieldEnum | HospitalSpecializationScalarFieldEnum[];
};
/**
 * HospitalSpecialization findFirstOrThrow
 */
type HospitalSpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which HospitalSpecialization to fetch.
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HospitalSpecializations to fetch.
     */
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HospitalSpecializations.
     */
    cursor?: HospitalSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` HospitalSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HospitalSpecializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HospitalSpecializations.
     */
    distinct?: HospitalSpecializationScalarFieldEnum | HospitalSpecializationScalarFieldEnum[];
};
/**
 * HospitalSpecialization findMany
 */
type HospitalSpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which HospitalSpecializations to fetch.
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HospitalSpecializations to fetch.
     */
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing HospitalSpecializations.
     */
    cursor?: HospitalSpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` HospitalSpecializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HospitalSpecializations.
     */
    skip?: number;
    distinct?: HospitalSpecializationScalarFieldEnum | HospitalSpecializationScalarFieldEnum[];
};
/**
 * HospitalSpecialization create
 */
type HospitalSpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to create a HospitalSpecialization.
     */
    data: XOR<HospitalSpecializationCreateInput, HospitalSpecializationUncheckedCreateInput>;
};
/**
 * HospitalSpecialization createMany
 */
type HospitalSpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many HospitalSpecializations.
     */
    data: HospitalSpecializationCreateManyInput | HospitalSpecializationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * HospitalSpecialization createManyAndReturn
 */
type HospitalSpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * The data used to create many HospitalSpecializations.
     */
    data: HospitalSpecializationCreateManyInput | HospitalSpecializationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * HospitalSpecialization update
 */
type HospitalSpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to update a HospitalSpecialization.
     */
    data: XOR<HospitalSpecializationUpdateInput, HospitalSpecializationUncheckedUpdateInput>;
    /**
     * Choose, which HospitalSpecialization to update.
     */
    where: HospitalSpecializationWhereUniqueInput;
};
/**
 * HospitalSpecialization updateMany
 */
type HospitalSpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update HospitalSpecializations.
     */
    data: XOR<HospitalSpecializationUpdateManyMutationInput, HospitalSpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which HospitalSpecializations to update
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * Limit how many HospitalSpecializations to update.
     */
    limit?: number;
};
/**
 * HospitalSpecialization updateManyAndReturn
 */
type HospitalSpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * The data used to update HospitalSpecializations.
     */
    data: XOR<HospitalSpecializationUpdateManyMutationInput, HospitalSpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which HospitalSpecializations to update
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * Limit how many HospitalSpecializations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * HospitalSpecialization upsert
 */
type HospitalSpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * The filter to search for the HospitalSpecialization to update in case it exists.
     */
    where: HospitalSpecializationWhereUniqueInput;
    /**
     * In case the HospitalSpecialization found by the `where` argument doesn't exist, create a new HospitalSpecialization with this data.
     */
    create: XOR<HospitalSpecializationCreateInput, HospitalSpecializationUncheckedCreateInput>;
    /**
     * In case the HospitalSpecialization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalSpecializationUpdateInput, HospitalSpecializationUncheckedUpdateInput>;
};
/**
 * HospitalSpecialization delete
 */
type HospitalSpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    /**
     * Filter which HospitalSpecialization to delete.
     */
    where: HospitalSpecializationWhereUniqueInput;
};
/**
 * HospitalSpecialization deleteMany
 */
type HospitalSpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which HospitalSpecializations to delete
     */
    where?: HospitalSpecializationWhereInput;
    /**
     * Limit how many HospitalSpecializations to delete.
     */
    limit?: number;
};
/**
 * HospitalSpecialization without action
 */
type HospitalSpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
};

/**
 * Model Notification
 *
 */
type NotificationModel = runtime.Types.Result.DefaultSelection<$NotificationPayload>;
type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
};
type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    isRead: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    isRead: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    title: number;
    message: number;
    isRead: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    isRead?: true;
    createdAt?: true;
    updatedAt?: true;
};
type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    isRead?: true;
    createdAt?: true;
    updatedAt?: true;
};
type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    isRead?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type NotificationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType;
};
type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateNotification[P]> : GetScalarType<T[P], AggregateNotification[P]>;
};
type NotificationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
};
type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    title: string;
    message: string;
    isRead: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
};
type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<Array<PickEnumerable<NotificationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], NotificationGroupByOutputType[P]> : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
}>>;
type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<"Notification"> | string;
    userId?: StringFilter<"Notification"> | string;
    title?: StringFilter<"Notification"> | string;
    message?: StringFilter<"Notification"> | string;
    isRead?: BoolFilter<"Notification"> | boolean;
    createdAt?: DateTimeFilter<"Notification"> | Date | string;
    updatedAt?: DateTimeFilter<"Notification"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    User?: UserOrderByWithRelationInput;
};
type NotificationWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    userId?: StringFilter<"Notification"> | string;
    title?: StringFilter<"Notification"> | string;
    message?: StringFilter<"Notification"> | string;
    isRead?: BoolFilter<"Notification"> | boolean;
    createdAt?: DateTimeFilter<"Notification"> | Date | string;
    updatedAt?: DateTimeFilter<"Notification"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id">;
type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
};
type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Notification"> | string;
    userId?: StringWithAggregatesFilter<"Notification"> | string;
    title?: StringWithAggregatesFilter<"Notification"> | string;
    message?: StringWithAggregatesFilter<"Notification"> | string;
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string;
};
type NotificationCreateInput = {
    id?: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutNotificationInput;
};
type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput;
};
type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    isRead?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
};
type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
};
type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
};
type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[];
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
};
type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[];
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
};
type NotificationCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
};
type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
};
type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
};
type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>;
};
type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<"Notification"> | string;
    userId?: StringFilter<"Notification"> | string;
    title?: StringFilter<"Notification"> | string;
    message?: StringFilter<"Notification"> | string;
    isRead?: BoolFilter<"Notification"> | boolean;
    createdAt?: DateTimeFilter<"Notification"> | Date | string;
    updatedAt?: DateTimeFilter<"Notification"> | Date | string;
};
type NotificationCreateManyUserInput = {
    id?: string;
    title: string;
    message: string;
    isRead?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    isRead?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type NotificationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    isRead?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["notification"]>;
type NotificationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    isRead?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["notification"]>;
type NotificationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    isRead?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["notification"]>;
type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    isRead?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type NotificationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "title" | "message" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>;
type NotificationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type NotificationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type NotificationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $NotificationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Notification";
    objects: {
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        userId: string;
        title: string;
        message: string;
        isRead: boolean;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["notification"]>;
    composites: {};
};
type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = runtime.Types.Result.GetResult<$NotificationPayload, S>;
type NotificationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationCountAggregateInputType | true;
};
interface NotificationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Notification'];
        meta: {
            name: 'Notification';
        };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(args?: Subset<T, NotificationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], NotificationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>;
    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends NotificationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: NotificationGroupByArgs['orderBy'];
    } : {
        orderBy?: NotificationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Notification.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__NotificationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Notification model
 */
interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>;
    readonly userId: FieldRef<"Notification", 'String'>;
    readonly title: FieldRef<"Notification", 'String'>;
    readonly message: FieldRef<"Notification", 'String'>;
    readonly isRead: FieldRef<"Notification", 'Boolean'>;
    readonly createdAt: FieldRef<"Notification", 'DateTime'>;
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>;
}
/**
 * Notification findUnique
 */
type NotificationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
};
/**
 * Notification findUniqueOrThrow
 */
type NotificationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
};
/**
 * Notification findFirst
 */
type NotificationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
};
/**
 * Notification findFirstOrThrow
 */
type NotificationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
};
/**
 * Notification findMany
 */
type NotificationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
};
/**
 * Notification create
 */
type NotificationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
};
/**
 * Notification createMany
 */
type NotificationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Notification createManyAndReturn
 */
type NotificationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Notification update
 */
type NotificationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
};
/**
 * Notification updateMany
 */
type NotificationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
};
/**
 * Notification updateManyAndReturn
 */
type NotificationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Notification upsert
 */
type NotificationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
};
/**
 * Notification delete
 */
type NotificationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
};
/**
 * Notification deleteMany
 */
type NotificationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
};
/**
 * Notification without action
 */
type NotificationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
};

/**
 * Model Payment
 *
 */
type PaymentModel = runtime.Types.Result.DefaultSelection<$PaymentPayload>;
type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
};
type PaymentAvgAggregateOutputType = {
    amount: runtime.Decimal | null;
};
type PaymentSumAggregateOutputType = {
    amount: runtime.Decimal | null;
};
type PaymentMinAggregateOutputType = {
    id: string | null;
    appointmentId: string | null;
    customerId: string | null;
    amount: runtime.Decimal | null;
    status: string | null;
    method: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type PaymentMaxAggregateOutputType = {
    id: string | null;
    appointmentId: string | null;
    customerId: string | null;
    amount: runtime.Decimal | null;
    status: string | null;
    method: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type PaymentCountAggregateOutputType = {
    id: number;
    appointmentId: number;
    customerId: number;
    amount: number;
    status: number;
    method: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type PaymentAvgAggregateInputType = {
    amount?: true;
};
type PaymentSumAggregateInputType = {
    amount?: true;
};
type PaymentMinAggregateInputType = {
    id?: true;
    appointmentId?: true;
    customerId?: true;
    amount?: true;
    status?: true;
    method?: true;
    createdAt?: true;
    updatedAt?: true;
};
type PaymentMaxAggregateInputType = {
    id?: true;
    appointmentId?: true;
    customerId?: true;
    amount?: true;
    status?: true;
    method?: true;
    createdAt?: true;
    updatedAt?: true;
};
type PaymentCountAggregateInputType = {
    id?: true;
    appointmentId?: true;
    customerId?: true;
    amount?: true;
    status?: true;
    method?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type PaymentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType;
};
type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregatePayment[P]> : GetScalarType<T[P], AggregatePayment[P]>;
};
type PaymentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
};
type PaymentGroupByOutputType = {
    id: string;
    appointmentId: string;
    customerId: string;
    amount: runtime.Decimal;
    status: string;
    method: string;
    createdAt: Date;
    updatedAt: Date;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
};
type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = PrismaPromise<Array<PickEnumerable<PaymentGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], PaymentGroupByOutputType[P]> : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
}>>;
type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    id?: StringFilter<"Payment"> | string;
    appointmentId?: StringFilter<"Payment"> | string;
    customerId?: StringFilter<"Payment"> | string;
    amount?: DecimalFilter<"Payment"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFilter<"Payment"> | string;
    method?: StringFilter<"Payment"> | string;
    createdAt?: DateTimeFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeFilter<"Payment"> | Date | string;
    Appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type PaymentOrderByWithRelationInput = {
    id?: SortOrder;
    appointmentId?: SortOrder;
    customerId?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    method?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Appointment?: AppointmentOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
};
type PaymentWhereUniqueInput = AtLeast<{
    id?: string;
    appointmentId?: string;
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    customerId?: StringFilter<"Payment"> | string;
    amount?: DecimalFilter<"Payment"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFilter<"Payment"> | string;
    method?: StringFilter<"Payment"> | string;
    createdAt?: DateTimeFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeFilter<"Payment"> | Date | string;
    Appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id" | "appointmentId">;
type PaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    appointmentId?: SortOrder;
    customerId?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    method?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
};
type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Payment"> | string;
    appointmentId?: StringWithAggregatesFilter<"Payment"> | string;
    customerId?: StringWithAggregatesFilter<"Payment"> | string;
    amount?: DecimalWithAggregatesFilter<"Payment"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringWithAggregatesFilter<"Payment"> | string;
    method?: StringWithAggregatesFilter<"Payment"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string;
};
type PaymentCreateInput = {
    id?: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Appointment: AppointmentCreateNestedOneWithoutPaymentInput;
    User: UserCreateNestedOneWithoutPaymentInput;
};
type PaymentUncheckedCreateInput = {
    id?: string;
    appointmentId: string;
    customerId: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Appointment?: AppointmentUpdateOneRequiredWithoutPaymentNestedInput;
    User?: UserUpdateOneRequiredWithoutPaymentNestedInput;
};
type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    appointmentId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentCreateManyInput = {
    id?: string;
    appointmentId: string;
    customerId: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    appointmentId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null;
    isNot?: PaymentWhereInput | null;
};
type PaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    appointmentId?: SortOrder;
    customerId?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    method?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder;
};
type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    appointmentId?: SortOrder;
    customerId?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    method?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type PaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    appointmentId?: SortOrder;
    customerId?: SortOrder;
    amount?: SortOrder;
    status?: SortOrder;
    method?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder;
};
type PaymentListRelationFilter = {
    every?: PaymentWhereInput;
    some?: PaymentWhereInput;
    none?: PaymentWhereInput;
};
type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type PaymentCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput;
    connect?: PaymentWhereUniqueInput;
};
type PaymentUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput;
    connect?: PaymentWhereUniqueInput;
};
type PaymentUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput;
    upsert?: PaymentUpsertWithoutAppointmentInput;
    disconnect?: PaymentWhereInput | boolean;
    delete?: PaymentWhereInput | boolean;
    connect?: PaymentWhereUniqueInput;
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutAppointmentInput, PaymentUpdateWithoutAppointmentInput>, PaymentUncheckedUpdateWithoutAppointmentInput>;
};
type PaymentUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutAppointmentInput;
    upsert?: PaymentUpsertWithoutAppointmentInput;
    disconnect?: PaymentWhereInput | boolean;
    delete?: PaymentWhereInput | boolean;
    connect?: PaymentWhereUniqueInput;
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutAppointmentInput, PaymentUpdateWithoutAppointmentInput>, PaymentUncheckedUpdateWithoutAppointmentInput>;
};
type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
};
type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
};
type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[];
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
};
type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[];
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
};
type PaymentCreateWithoutAppointmentInput = {
    id?: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutPaymentInput;
};
type PaymentUncheckedCreateWithoutAppointmentInput = {
    id?: string;
    customerId: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type PaymentCreateOrConnectWithoutAppointmentInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
};
type PaymentUpsertWithoutAppointmentInput = {
    update: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>;
    create: XOR<PaymentCreateWithoutAppointmentInput, PaymentUncheckedCreateWithoutAppointmentInput>;
    where?: PaymentWhereInput;
};
type PaymentUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: PaymentWhereInput;
    data: XOR<PaymentUpdateWithoutAppointmentInput, PaymentUncheckedUpdateWithoutAppointmentInput>;
};
type PaymentUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutPaymentNestedInput;
};
type PaymentUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentCreateWithoutUserInput = {
    id?: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Appointment: AppointmentCreateNestedOneWithoutPaymentInput;
};
type PaymentUncheckedCreateWithoutUserInput = {
    id?: string;
    appointmentId: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>;
};
type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>;
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>;
};
type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>;
};
type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput;
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>;
};
type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    OR?: PaymentScalarWhereInput[];
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    id?: StringFilter<"Payment"> | string;
    appointmentId?: StringFilter<"Payment"> | string;
    customerId?: StringFilter<"Payment"> | string;
    amount?: DecimalFilter<"Payment"> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFilter<"Payment"> | string;
    method?: StringFilter<"Payment"> | string;
    createdAt?: DateTimeFilter<"Payment"> | Date | string;
    updatedAt?: DateTimeFilter<"Payment"> | Date | string;
};
type PaymentCreateManyUserInput = {
    id?: string;
    appointmentId: string;
    amount: runtime.Decimal | runtime.DecimalJsLike | number | string;
    status: string;
    method: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Appointment?: AppointmentUpdateOneRequiredWithoutPaymentNestedInput;
};
type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    appointmentId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    appointmentId?: StringFieldUpdateOperationsInput | string;
    amount?: DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string;
    status?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type PaymentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    appointmentId?: boolean;
    customerId?: boolean;
    amount?: boolean;
    status?: boolean;
    method?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["payment"]>;
type PaymentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    appointmentId?: boolean;
    customerId?: boolean;
    amount?: boolean;
    status?: boolean;
    method?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["payment"]>;
type PaymentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    appointmentId?: boolean;
    customerId?: boolean;
    amount?: boolean;
    status?: boolean;
    method?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["payment"]>;
type PaymentSelectScalar = {
    id?: boolean;
    appointmentId?: boolean;
    customerId?: boolean;
    amount?: boolean;
    status?: boolean;
    method?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type PaymentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "appointmentId" | "customerId" | "amount" | "status" | "method" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>;
type PaymentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type PaymentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type PaymentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | AppointmentDefaultArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $PaymentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Payment";
    objects: {
        Appointment: $AppointmentPayload<ExtArgs>;
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        appointmentId: string;
        customerId: string;
        amount: runtime.Decimal;
        status: string;
        method: string;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["payment"]>;
    composites: {};
};
type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = runtime.Types.Result.GetResult<$PaymentPayload, S>;
type PaymentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PaymentCountAggregateInputType | true;
};
interface PaymentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Payment'];
        meta: {
            name: 'Payment';
        };
    };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(args?: Subset<T, PaymentCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], PaymentCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>;
    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends PaymentGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: PaymentGroupByArgs['orderBy'];
    } : {
        orderBy?: PaymentGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Payment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__PaymentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Payment model
 */
interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>;
    readonly appointmentId: FieldRef<"Payment", 'String'>;
    readonly customerId: FieldRef<"Payment", 'String'>;
    readonly amount: FieldRef<"Payment", 'Decimal'>;
    readonly status: FieldRef<"Payment", 'String'>;
    readonly method: FieldRef<"Payment", 'String'>;
    readonly createdAt: FieldRef<"Payment", 'DateTime'>;
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>;
}
/**
 * Payment findUnique
 */
type PaymentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
};
/**
 * Payment findUniqueOrThrow
 */
type PaymentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
};
/**
 * Payment findFirst
 */
type PaymentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
};
/**
 * Payment findFirstOrThrow
 */
type PaymentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
};
/**
 * Payment findMany
 */
type PaymentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
};
/**
 * Payment create
 */
type PaymentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
};
/**
 * Payment createMany
 */
type PaymentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Payment createManyAndReturn
 */
type PaymentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Payment update
 */
type PaymentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
};
/**
 * Payment updateMany
 */
type PaymentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
};
/**
 * Payment updateManyAndReturn
 */
type PaymentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Payment upsert
 */
type PaymentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
};
/**
 * Payment delete
 */
type PaymentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
};
/**
 * Payment deleteMany
 */
type PaymentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to delete.
     */
    limit?: number;
};
/**
 * Payment without action
 */
type PaymentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
};

/**
 * Model Review
 *
 */
type ReviewModel = runtime.Types.Result.DefaultSelection<$ReviewPayload>;
type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
};
type ReviewAvgAggregateOutputType = {
    rating: number | null;
};
type ReviewSumAggregateOutputType = {
    rating: number | null;
};
type ReviewMinAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type ReviewMaxAggregateOutputType = {
    id: string | null;
    customerId: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type ReviewCountAggregateOutputType = {
    id: number;
    customerId: number;
    doctorId: number;
    hospitalId: number;
    rating: number;
    comment: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type ReviewAvgAggregateInputType = {
    rating?: true;
};
type ReviewSumAggregateInputType = {
    rating?: true;
};
type ReviewMinAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    hospitalId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    updatedAt?: true;
};
type ReviewMaxAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    hospitalId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    updatedAt?: true;
};
type ReviewCountAggregateInputType = {
    id?: true;
    customerId?: true;
    doctorId?: true;
    hospitalId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type ReviewAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType;
};
type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateReview[P]> : GetScalarType<T[P], AggregateReview[P]>;
};
type ReviewGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[];
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum;
    having?: ReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReviewCountAggregateInputType | true;
    _avg?: ReviewAvgAggregateInputType;
    _sum?: ReviewSumAggregateInputType;
    _min?: ReviewMinAggregateInputType;
    _max?: ReviewMaxAggregateInputType;
};
type ReviewGroupByOutputType = {
    id: string;
    customerId: string;
    doctorId: string | null;
    hospitalId: string | null;
    rating: number;
    comment: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
};
type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<Array<PickEnumerable<ReviewGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], ReviewGroupByOutputType[P]> : GetScalarType<T[P], ReviewGroupByOutputType[P]>;
}>>;
type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    id?: StringFilter<"Review"> | string;
    customerId?: StringFilter<"Review"> | string;
    doctorId?: StringNullableFilter<"Review"> | string | null;
    hospitalId?: StringNullableFilter<"Review"> | string | null;
    rating?: IntFilter<"Review"> | number;
    comment?: StringNullableFilter<"Review"> | string | null;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    updatedAt?: DateTimeFilter<"Review"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
};
type ReviewOrderByWithRelationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrderInput | SortOrder;
    hospitalId?: SortOrderInput | SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    User?: UserOrderByWithRelationInput;
    Doctor?: DoctorOrderByWithRelationInput;
    Hospital?: HospitalOrderByWithRelationInput;
};
type ReviewWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    customerId?: StringFilter<"Review"> | string;
    doctorId?: StringNullableFilter<"Review"> | string | null;
    hospitalId?: StringNullableFilter<"Review"> | string | null;
    rating?: IntFilter<"Review"> | number;
    comment?: StringNullableFilter<"Review"> | string | null;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    updatedAt?: DateTimeFilter<"Review"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
}, "id">;
type ReviewOrderByWithAggregationInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrderInput | SortOrder;
    hospitalId?: SortOrderInput | SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ReviewCountOrderByAggregateInput;
    _avg?: ReviewAvgOrderByAggregateInput;
    _max?: ReviewMaxOrderByAggregateInput;
    _min?: ReviewMinOrderByAggregateInput;
    _sum?: ReviewSumOrderByAggregateInput;
};
type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[];
    OR?: ReviewScalarWhereWithAggregatesInput[];
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Review"> | string;
    customerId?: StringWithAggregatesFilter<"Review"> | string;
    doctorId?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    hospitalId?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    rating?: IntWithAggregatesFilter<"Review"> | number;
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string;
};
type ReviewCreateInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutReviewInput;
    Doctor?: DoctorCreateNestedOneWithoutReviewInput;
    Hospital?: HospitalCreateNestedOneWithoutReviewInput;
};
type ReviewUncheckedCreateInput = {
    id?: string;
    customerId: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutReviewNestedInput;
    Doctor?: DoctorUpdateOneWithoutReviewNestedInput;
    Hospital?: HospitalUpdateOneWithoutReviewNestedInput;
};
type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewCreateManyInput = {
    id?: string;
    customerId: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewListRelationFilter = {
    every?: ReviewWhereInput;
    some?: ReviewWhereInput;
    none?: ReviewWhereInput;
};
type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type ReviewCountOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder;
};
type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type ReviewMinOrderByAggregateInput = {
    id?: SortOrder;
    customerId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder;
};
type ReviewCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput> | ReviewCreateWithoutDoctorInput[] | ReviewUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutDoctorInput | ReviewCreateOrConnectWithoutDoctorInput[];
    createMany?: ReviewCreateManyDoctorInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput> | ReviewCreateWithoutDoctorInput[] | ReviewUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutDoctorInput | ReviewCreateOrConnectWithoutDoctorInput[];
    createMany?: ReviewCreateManyDoctorInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput> | ReviewCreateWithoutDoctorInput[] | ReviewUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutDoctorInput | ReviewCreateOrConnectWithoutDoctorInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutDoctorInput | ReviewUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: ReviewCreateManyDoctorInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutDoctorInput | ReviewUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutDoctorInput | ReviewUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput> | ReviewCreateWithoutDoctorInput[] | ReviewUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutDoctorInput | ReviewCreateOrConnectWithoutDoctorInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutDoctorInput | ReviewUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: ReviewCreateManyDoctorInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutDoctorInput | ReviewUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutDoctorInput | ReviewUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput> | ReviewCreateWithoutHospitalInput[] | ReviewUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutHospitalInput | ReviewCreateOrConnectWithoutHospitalInput[];
    createMany?: ReviewCreateManyHospitalInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput> | ReviewCreateWithoutHospitalInput[] | ReviewUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutHospitalInput | ReviewCreateOrConnectWithoutHospitalInput[];
    createMany?: ReviewCreateManyHospitalInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput> | ReviewCreateWithoutHospitalInput[] | ReviewUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutHospitalInput | ReviewCreateOrConnectWithoutHospitalInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutHospitalInput | ReviewUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: ReviewCreateManyHospitalInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutHospitalInput | ReviewUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutHospitalInput | ReviewUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput> | ReviewCreateWithoutHospitalInput[] | ReviewUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutHospitalInput | ReviewCreateOrConnectWithoutHospitalInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutHospitalInput | ReviewUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: ReviewCreateManyHospitalInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutHospitalInput | ReviewUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutHospitalInput | ReviewUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
};
type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[];
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
};
type ReviewCreateWithoutDoctorInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutReviewInput;
    Hospital?: HospitalCreateNestedOneWithoutReviewInput;
};
type ReviewUncheckedCreateWithoutDoctorInput = {
    id?: string;
    customerId: string;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewCreateOrConnectWithoutDoctorInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput>;
};
type ReviewCreateManyDoctorInputEnvelope = {
    data: ReviewCreateManyDoctorInput | ReviewCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type ReviewUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<ReviewUpdateWithoutDoctorInput, ReviewUncheckedUpdateWithoutDoctorInput>;
    create: XOR<ReviewCreateWithoutDoctorInput, ReviewUncheckedCreateWithoutDoctorInput>;
};
type ReviewUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<ReviewUpdateWithoutDoctorInput, ReviewUncheckedUpdateWithoutDoctorInput>;
};
type ReviewUpdateManyWithWhereWithoutDoctorInput = {
    where: ReviewScalarWhereInput;
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutDoctorInput>;
};
type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    OR?: ReviewScalarWhereInput[];
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    id?: StringFilter<"Review"> | string;
    customerId?: StringFilter<"Review"> | string;
    doctorId?: StringNullableFilter<"Review"> | string | null;
    hospitalId?: StringNullableFilter<"Review"> | string | null;
    rating?: IntFilter<"Review"> | number;
    comment?: StringNullableFilter<"Review"> | string | null;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    updatedAt?: DateTimeFilter<"Review"> | Date | string;
};
type ReviewCreateWithoutHospitalInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutReviewInput;
    Doctor?: DoctorCreateNestedOneWithoutReviewInput;
};
type ReviewUncheckedCreateWithoutHospitalInput = {
    id?: string;
    customerId: string;
    doctorId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewCreateOrConnectWithoutHospitalInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput>;
};
type ReviewCreateManyHospitalInputEnvelope = {
    data: ReviewCreateManyHospitalInput | ReviewCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type ReviewUpsertWithWhereUniqueWithoutHospitalInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<ReviewUpdateWithoutHospitalInput, ReviewUncheckedUpdateWithoutHospitalInput>;
    create: XOR<ReviewCreateWithoutHospitalInput, ReviewUncheckedCreateWithoutHospitalInput>;
};
type ReviewUpdateWithWhereUniqueWithoutHospitalInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<ReviewUpdateWithoutHospitalInput, ReviewUncheckedUpdateWithoutHospitalInput>;
};
type ReviewUpdateManyWithWhereWithoutHospitalInput = {
    where: ReviewScalarWhereInput;
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutHospitalInput>;
};
type ReviewCreateWithoutUserInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor?: DoctorCreateNestedOneWithoutReviewInput;
    Hospital?: HospitalCreateNestedOneWithoutReviewInput;
};
type ReviewUncheckedCreateWithoutUserInput = {
    id?: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>;
};
type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>;
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>;
};
type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>;
};
type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput;
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>;
};
type ReviewCreateManyDoctorInput = {
    id?: string;
    customerId: string;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutReviewNestedInput;
    Hospital?: HospitalUpdateOneWithoutReviewNestedInput;
};
type ReviewUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewCreateManyHospitalInput = {
    id?: string;
    customerId: string;
    doctorId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutReviewNestedInput;
    Doctor?: DoctorUpdateOneWithoutReviewNestedInput;
};
type ReviewUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewCreateManyUserInput = {
    id?: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneWithoutReviewNestedInput;
    Hospital?: HospitalUpdateOneWithoutReviewNestedInput;
};
type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type ReviewSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
}, ExtArgs["result"]["review"]>;
type ReviewSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
}, ExtArgs["result"]["review"]>;
type ReviewSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
}, ExtArgs["result"]["review"]>;
type ReviewSelectScalar = {
    id?: boolean;
    customerId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type ReviewOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "customerId" | "doctorId" | "hospitalId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>;
type ReviewInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
};
type ReviewIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
};
type ReviewIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | Review$DoctorArgs<ExtArgs>;
    Hospital?: boolean | Review$HospitalArgs<ExtArgs>;
};
type $ReviewPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Review";
    objects: {
        User: $UserPayload<ExtArgs>;
        Doctor: $DoctorPayload<ExtArgs> | null;
        Hospital: $HospitalPayload<ExtArgs> | null;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        customerId: string;
        doctorId: string | null;
        hospitalId: string | null;
        rating: number;
        comment: string | null;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["review"]>;
    composites: {};
};
type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = runtime.Types.Result.GetResult<$ReviewPayload, S>;
type ReviewCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ReviewCountAggregateInputType | true;
};
interface ReviewDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Review'];
        meta: {
            name: 'Review';
        };
    };
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     *
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     *
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     *
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(args?: Subset<T, ReviewCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], ReviewCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>;
    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends ReviewGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: ReviewGroupByArgs['orderBy'];
    } : {
        orderBy?: ReviewGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Review model
     */
    readonly fields: ReviewFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Review.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__ReviewClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Doctor<T extends Review$DoctorArgs<ExtArgs> = {}>(args?: Subset<T, Review$DoctorArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    Hospital<T extends Review$HospitalArgs<ExtArgs> = {}>(args?: Subset<T, Review$HospitalArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Review model
 */
interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>;
    readonly customerId: FieldRef<"Review", 'String'>;
    readonly doctorId: FieldRef<"Review", 'String'>;
    readonly hospitalId: FieldRef<"Review", 'String'>;
    readonly rating: FieldRef<"Review", 'Int'>;
    readonly comment: FieldRef<"Review", 'String'>;
    readonly createdAt: FieldRef<"Review", 'DateTime'>;
    readonly updatedAt: FieldRef<"Review", 'DateTime'>;
}
/**
 * Review findUnique
 */
type ReviewFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
};
/**
 * Review findUniqueOrThrow
 */
type ReviewFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
};
/**
 * Review findFirst
 */
type ReviewFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * Review findFirstOrThrow
 */
type ReviewFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * Review findMany
 */
type ReviewFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * Review create
 */
type ReviewCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
};
/**
 * Review createMany
 */
type ReviewCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Review createManyAndReturn
 */
type ReviewCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Review update
 */
type ReviewUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput;
};
/**
 * Review updateMany
 */
type ReviewUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
};
/**
 * Review updateManyAndReturn
 */
type ReviewUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Review upsert
 */
type ReviewUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput;
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
};
/**
 * Review delete
 */
type ReviewDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput;
};
/**
 * Review deleteMany
 */
type ReviewDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number;
};
/**
 * Review.Doctor
 */
type Review$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    where?: DoctorWhereInput;
};
/**
 * Review.Hospital
 */
type Review$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    where?: HospitalWhereInput;
};
/**
 * Review without action
 */
type ReviewDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
};

/**
 * Model SavedDoctorHospital
 *
 */
type SavedDoctorHospitalModel = runtime.Types.Result.DefaultSelection<$SavedDoctorHospitalPayload>;
type AggregateSavedDoctorHospital = {
    _count: SavedDoctorHospitalCountAggregateOutputType | null;
    _min: SavedDoctorHospitalMinAggregateOutputType | null;
    _max: SavedDoctorHospitalMaxAggregateOutputType | null;
};
type SavedDoctorHospitalMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type SavedDoctorHospitalMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    doctorId: string | null;
    hospitalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type SavedDoctorHospitalCountAggregateOutputType = {
    id: number;
    userId: number;
    doctorId: number;
    hospitalId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type SavedDoctorHospitalMinAggregateInputType = {
    id?: true;
    userId?: true;
    doctorId?: true;
    hospitalId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type SavedDoctorHospitalMaxAggregateInputType = {
    id?: true;
    userId?: true;
    doctorId?: true;
    hospitalId?: true;
    createdAt?: true;
    updatedAt?: true;
};
type SavedDoctorHospitalCountAggregateInputType = {
    id?: true;
    userId?: true;
    doctorId?: true;
    hospitalId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type SavedDoctorHospitalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which SavedDoctorHospital to aggregate.
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SavedDoctorHospitals to fetch.
     */
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SavedDoctorHospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SavedDoctorHospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SavedDoctorHospitals
    **/
    _count?: true | SavedDoctorHospitalCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SavedDoctorHospitalMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SavedDoctorHospitalMaxAggregateInputType;
};
type GetSavedDoctorHospitalAggregateType<T extends SavedDoctorHospitalAggregateArgs> = {
    [P in keyof T & keyof AggregateSavedDoctorHospital]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSavedDoctorHospital[P]> : GetScalarType<T[P], AggregateSavedDoctorHospital[P]>;
};
type SavedDoctorHospitalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SavedDoctorHospitalWhereInput;
    orderBy?: SavedDoctorHospitalOrderByWithAggregationInput | SavedDoctorHospitalOrderByWithAggregationInput[];
    by: SavedDoctorHospitalScalarFieldEnum[] | SavedDoctorHospitalScalarFieldEnum;
    having?: SavedDoctorHospitalScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SavedDoctorHospitalCountAggregateInputType | true;
    _min?: SavedDoctorHospitalMinAggregateInputType;
    _max?: SavedDoctorHospitalMaxAggregateInputType;
};
type SavedDoctorHospitalGroupByOutputType = {
    id: string;
    userId: string;
    doctorId: string | null;
    hospitalId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: SavedDoctorHospitalCountAggregateOutputType | null;
    _min: SavedDoctorHospitalMinAggregateOutputType | null;
    _max: SavedDoctorHospitalMaxAggregateOutputType | null;
};
type GetSavedDoctorHospitalGroupByPayload<T extends SavedDoctorHospitalGroupByArgs> = PrismaPromise<Array<PickEnumerable<SavedDoctorHospitalGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof SavedDoctorHospitalGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], SavedDoctorHospitalGroupByOutputType[P]> : GetScalarType<T[P], SavedDoctorHospitalGroupByOutputType[P]>;
}>>;
type SavedDoctorHospitalWhereInput = {
    AND?: SavedDoctorHospitalWhereInput | SavedDoctorHospitalWhereInput[];
    OR?: SavedDoctorHospitalWhereInput[];
    NOT?: SavedDoctorHospitalWhereInput | SavedDoctorHospitalWhereInput[];
    id?: StringFilter<"SavedDoctorHospital"> | string;
    userId?: StringFilter<"SavedDoctorHospital"> | string;
    doctorId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    hospitalId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    createdAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
    updatedAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type SavedDoctorHospitalOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    doctorId?: SortOrderInput | SortOrder;
    hospitalId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    Doctor?: DoctorOrderByWithRelationInput;
    Hospital?: HospitalOrderByWithRelationInput;
    User?: UserOrderByWithRelationInput;
};
type SavedDoctorHospitalWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: SavedDoctorHospitalWhereInput | SavedDoctorHospitalWhereInput[];
    OR?: SavedDoctorHospitalWhereInput[];
    NOT?: SavedDoctorHospitalWhereInput | SavedDoctorHospitalWhereInput[];
    userId?: StringFilter<"SavedDoctorHospital"> | string;
    doctorId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    hospitalId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    createdAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
    updatedAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id">;
type SavedDoctorHospitalOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    doctorId?: SortOrderInput | SortOrder;
    hospitalId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SavedDoctorHospitalCountOrderByAggregateInput;
    _max?: SavedDoctorHospitalMaxOrderByAggregateInput;
    _min?: SavedDoctorHospitalMinOrderByAggregateInput;
};
type SavedDoctorHospitalScalarWhereWithAggregatesInput = {
    AND?: SavedDoctorHospitalScalarWhereWithAggregatesInput | SavedDoctorHospitalScalarWhereWithAggregatesInput[];
    OR?: SavedDoctorHospitalScalarWhereWithAggregatesInput[];
    NOT?: SavedDoctorHospitalScalarWhereWithAggregatesInput | SavedDoctorHospitalScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SavedDoctorHospital"> | string;
    userId?: StringWithAggregatesFilter<"SavedDoctorHospital"> | string;
    doctorId?: StringNullableWithAggregatesFilter<"SavedDoctorHospital"> | string | null;
    hospitalId?: StringNullableWithAggregatesFilter<"SavedDoctorHospital"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"SavedDoctorHospital"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"SavedDoctorHospital"> | Date | string;
};
type SavedDoctorHospitalCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor?: DoctorCreateNestedOneWithoutSavedDoctorHospitalInput;
    Hospital?: HospitalCreateNestedOneWithoutSavedDoctorHospitalInput;
    User: UserCreateNestedOneWithoutSavedDoctorHospitalInput;
};
type SavedDoctorHospitalUncheckedCreateInput = {
    id?: string;
    userId: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput;
    Hospital?: HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput;
};
type SavedDoctorHospitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalCreateManyInput = {
    id?: string;
    userId: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalListRelationFilter = {
    every?: SavedDoctorHospitalWhereInput;
    some?: SavedDoctorHospitalWhereInput;
    none?: SavedDoctorHospitalWhereInput;
};
type SavedDoctorHospitalOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type SavedDoctorHospitalCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SavedDoctorHospitalMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SavedDoctorHospitalMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    doctorId?: SortOrder;
    hospitalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SavedDoctorHospitalCreateNestedManyWithoutDoctorInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput> | SavedDoctorHospitalCreateWithoutDoctorInput[] | SavedDoctorHospitalUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutDoctorInput | SavedDoctorHospitalCreateOrConnectWithoutDoctorInput[];
    createMany?: SavedDoctorHospitalCreateManyDoctorInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput> | SavedDoctorHospitalCreateWithoutDoctorInput[] | SavedDoctorHospitalUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutDoctorInput | SavedDoctorHospitalCreateOrConnectWithoutDoctorInput[];
    createMany?: SavedDoctorHospitalCreateManyDoctorInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput> | SavedDoctorHospitalCreateWithoutDoctorInput[] | SavedDoctorHospitalUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutDoctorInput | SavedDoctorHospitalCreateOrConnectWithoutDoctorInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: SavedDoctorHospitalCreateManyDoctorInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput | SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput> | SavedDoctorHospitalCreateWithoutDoctorInput[] | SavedDoctorHospitalUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutDoctorInput | SavedDoctorHospitalCreateOrConnectWithoutDoctorInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: SavedDoctorHospitalCreateManyDoctorInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput | SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalCreateNestedManyWithoutHospitalInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput> | SavedDoctorHospitalCreateWithoutHospitalInput[] | SavedDoctorHospitalUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutHospitalInput | SavedDoctorHospitalCreateOrConnectWithoutHospitalInput[];
    createMany?: SavedDoctorHospitalCreateManyHospitalInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput> | SavedDoctorHospitalCreateWithoutHospitalInput[] | SavedDoctorHospitalUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutHospitalInput | SavedDoctorHospitalCreateOrConnectWithoutHospitalInput[];
    createMany?: SavedDoctorHospitalCreateManyHospitalInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput> | SavedDoctorHospitalCreateWithoutHospitalInput[] | SavedDoctorHospitalUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutHospitalInput | SavedDoctorHospitalCreateOrConnectWithoutHospitalInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: SavedDoctorHospitalCreateManyHospitalInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput | SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput> | SavedDoctorHospitalCreateWithoutHospitalInput[] | SavedDoctorHospitalUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutHospitalInput | SavedDoctorHospitalCreateOrConnectWithoutHospitalInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: SavedDoctorHospitalCreateManyHospitalInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput | SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput> | SavedDoctorHospitalCreateWithoutUserInput[] | SavedDoctorHospitalUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutUserInput | SavedDoctorHospitalCreateOrConnectWithoutUserInput[];
    createMany?: SavedDoctorHospitalCreateManyUserInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput> | SavedDoctorHospitalCreateWithoutUserInput[] | SavedDoctorHospitalUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutUserInput | SavedDoctorHospitalCreateOrConnectWithoutUserInput[];
    createMany?: SavedDoctorHospitalCreateManyUserInputEnvelope;
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
};
type SavedDoctorHospitalUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput> | SavedDoctorHospitalCreateWithoutUserInput[] | SavedDoctorHospitalUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutUserInput | SavedDoctorHospitalCreateOrConnectWithoutUserInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SavedDoctorHospitalCreateManyUserInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput | SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput> | SavedDoctorHospitalCreateWithoutUserInput[] | SavedDoctorHospitalUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SavedDoctorHospitalCreateOrConnectWithoutUserInput | SavedDoctorHospitalCreateOrConnectWithoutUserInput[];
    upsert?: SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput | SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SavedDoctorHospitalCreateManyUserInputEnvelope;
    set?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    disconnect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    delete?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    connect?: SavedDoctorHospitalWhereUniqueInput | SavedDoctorHospitalWhereUniqueInput[];
    update?: SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput | SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput | SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
};
type SavedDoctorHospitalCreateWithoutDoctorInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Hospital?: HospitalCreateNestedOneWithoutSavedDoctorHospitalInput;
    User: UserCreateNestedOneWithoutSavedDoctorHospitalInput;
};
type SavedDoctorHospitalUncheckedCreateWithoutDoctorInput = {
    id?: string;
    userId: string;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalCreateOrConnectWithoutDoctorInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    create: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput>;
};
type SavedDoctorHospitalCreateManyDoctorInputEnvelope = {
    data: SavedDoctorHospitalCreateManyDoctorInput | SavedDoctorHospitalCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    update: XOR<SavedDoctorHospitalUpdateWithoutDoctorInput, SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput>;
    create: XOR<SavedDoctorHospitalCreateWithoutDoctorInput, SavedDoctorHospitalUncheckedCreateWithoutDoctorInput>;
};
type SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    data: XOR<SavedDoctorHospitalUpdateWithoutDoctorInput, SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput>;
};
type SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput = {
    where: SavedDoctorHospitalScalarWhereInput;
    data: XOR<SavedDoctorHospitalUpdateManyMutationInput, SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput>;
};
type SavedDoctorHospitalScalarWhereInput = {
    AND?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
    OR?: SavedDoctorHospitalScalarWhereInput[];
    NOT?: SavedDoctorHospitalScalarWhereInput | SavedDoctorHospitalScalarWhereInput[];
    id?: StringFilter<"SavedDoctorHospital"> | string;
    userId?: StringFilter<"SavedDoctorHospital"> | string;
    doctorId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    hospitalId?: StringNullableFilter<"SavedDoctorHospital"> | string | null;
    createdAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
    updatedAt?: DateTimeFilter<"SavedDoctorHospital"> | Date | string;
};
type SavedDoctorHospitalCreateWithoutHospitalInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor?: DoctorCreateNestedOneWithoutSavedDoctorHospitalInput;
    User: UserCreateNestedOneWithoutSavedDoctorHospitalInput;
};
type SavedDoctorHospitalUncheckedCreateWithoutHospitalInput = {
    id?: string;
    userId: string;
    doctorId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalCreateOrConnectWithoutHospitalInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    create: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput>;
};
type SavedDoctorHospitalCreateManyHospitalInputEnvelope = {
    data: SavedDoctorHospitalCreateManyHospitalInput | SavedDoctorHospitalCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    update: XOR<SavedDoctorHospitalUpdateWithoutHospitalInput, SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput>;
    create: XOR<SavedDoctorHospitalCreateWithoutHospitalInput, SavedDoctorHospitalUncheckedCreateWithoutHospitalInput>;
};
type SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    data: XOR<SavedDoctorHospitalUpdateWithoutHospitalInput, SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput>;
};
type SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput = {
    where: SavedDoctorHospitalScalarWhereInput;
    data: XOR<SavedDoctorHospitalUpdateManyMutationInput, SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput>;
};
type SavedDoctorHospitalCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    Doctor?: DoctorCreateNestedOneWithoutSavedDoctorHospitalInput;
    Hospital?: HospitalCreateNestedOneWithoutSavedDoctorHospitalInput;
};
type SavedDoctorHospitalUncheckedCreateWithoutUserInput = {
    id?: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalCreateOrConnectWithoutUserInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    create: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput>;
};
type SavedDoctorHospitalCreateManyUserInputEnvelope = {
    data: SavedDoctorHospitalCreateManyUserInput | SavedDoctorHospitalCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    update: XOR<SavedDoctorHospitalUpdateWithoutUserInput, SavedDoctorHospitalUncheckedUpdateWithoutUserInput>;
    create: XOR<SavedDoctorHospitalCreateWithoutUserInput, SavedDoctorHospitalUncheckedCreateWithoutUserInput>;
};
type SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedDoctorHospitalWhereUniqueInput;
    data: XOR<SavedDoctorHospitalUpdateWithoutUserInput, SavedDoctorHospitalUncheckedUpdateWithoutUserInput>;
};
type SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput = {
    where: SavedDoctorHospitalScalarWhereInput;
    data: XOR<SavedDoctorHospitalUpdateManyMutationInput, SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput>;
};
type SavedDoctorHospitalCreateManyDoctorInput = {
    id?: string;
    userId: string;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Hospital?: HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput;
};
type SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalCreateManyHospitalInput = {
    id?: string;
    userId: string;
    doctorId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput;
    User?: UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput;
};
type SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalCreateManyUserInput = {
    id?: string;
    doctorId?: string | null;
    hospitalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SavedDoctorHospitalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    Doctor?: DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput;
    Hospital?: HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput;
};
type SavedDoctorHospitalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SavedDoctorHospitalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["savedDoctorHospital"]>;
type SavedDoctorHospitalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["savedDoctorHospital"]>;
type SavedDoctorHospitalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["savedDoctorHospital"]>;
type SavedDoctorHospitalSelectScalar = {
    id?: boolean;
    userId?: boolean;
    doctorId?: boolean;
    hospitalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type SavedDoctorHospitalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "doctorId" | "hospitalId" | "createdAt" | "updatedAt", ExtArgs["result"]["savedDoctorHospital"]>;
type SavedDoctorHospitalInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type SavedDoctorHospitalIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type SavedDoctorHospitalIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Doctor?: boolean | SavedDoctorHospital$DoctorArgs<ExtArgs>;
    Hospital?: boolean | SavedDoctorHospital$HospitalArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $SavedDoctorHospitalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "SavedDoctorHospital";
    objects: {
        Doctor: $DoctorPayload<ExtArgs> | null;
        Hospital: $HospitalPayload<ExtArgs> | null;
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        userId: string;
        doctorId: string | null;
        hospitalId: string | null;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["savedDoctorHospital"]>;
    composites: {};
};
type SavedDoctorHospitalGetPayload<S extends boolean | null | undefined | SavedDoctorHospitalDefaultArgs> = runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload, S>;
type SavedDoctorHospitalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<SavedDoctorHospitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SavedDoctorHospitalCountAggregateInputType | true;
};
interface SavedDoctorHospitalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['SavedDoctorHospital'];
        meta: {
            name: 'SavedDoctorHospital';
        };
    };
    /**
     * Find zero or one SavedDoctorHospital that matches the filter.
     * @param {SavedDoctorHospitalFindUniqueArgs} args - Arguments to find a SavedDoctorHospital
     * @example
     * // Get one SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedDoctorHospitalFindUniqueArgs>(args: SelectSubset<T, SavedDoctorHospitalFindUniqueArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one SavedDoctorHospital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedDoctorHospitalFindUniqueOrThrowArgs} args - Arguments to find a SavedDoctorHospital
     * @example
     * // Get one SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedDoctorHospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedDoctorHospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first SavedDoctorHospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalFindFirstArgs} args - Arguments to find a SavedDoctorHospital
     * @example
     * // Get one SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedDoctorHospitalFindFirstArgs>(args?: SelectSubset<T, SavedDoctorHospitalFindFirstArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first SavedDoctorHospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalFindFirstOrThrowArgs} args - Arguments to find a SavedDoctorHospital
     * @example
     * // Get one SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedDoctorHospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedDoctorHospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more SavedDoctorHospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedDoctorHospitals
     * const savedDoctorHospitals = await prisma.savedDoctorHospital.findMany()
     *
     * // Get first 10 SavedDoctorHospitals
     * const savedDoctorHospitals = await prisma.savedDoctorHospital.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const savedDoctorHospitalWithIdOnly = await prisma.savedDoctorHospital.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SavedDoctorHospitalFindManyArgs>(args?: SelectSubset<T, SavedDoctorHospitalFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a SavedDoctorHospital.
     * @param {SavedDoctorHospitalCreateArgs} args - Arguments to create a SavedDoctorHospital.
     * @example
     * // Create one SavedDoctorHospital
     * const SavedDoctorHospital = await prisma.savedDoctorHospital.create({
     *   data: {
     *     // ... data to create a SavedDoctorHospital
     *   }
     * })
     *
     */
    create<T extends SavedDoctorHospitalCreateArgs>(args: SelectSubset<T, SavedDoctorHospitalCreateArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many SavedDoctorHospitals.
     * @param {SavedDoctorHospitalCreateManyArgs} args - Arguments to create many SavedDoctorHospitals.
     * @example
     * // Create many SavedDoctorHospitals
     * const savedDoctorHospital = await prisma.savedDoctorHospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SavedDoctorHospitalCreateManyArgs>(args?: SelectSubset<T, SavedDoctorHospitalCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many SavedDoctorHospitals and returns the data saved in the database.
     * @param {SavedDoctorHospitalCreateManyAndReturnArgs} args - Arguments to create many SavedDoctorHospitals.
     * @example
     * // Create many SavedDoctorHospitals
     * const savedDoctorHospital = await prisma.savedDoctorHospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SavedDoctorHospitals and only return the `id`
     * const savedDoctorHospitalWithIdOnly = await prisma.savedDoctorHospital.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SavedDoctorHospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedDoctorHospitalCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a SavedDoctorHospital.
     * @param {SavedDoctorHospitalDeleteArgs} args - Arguments to delete one SavedDoctorHospital.
     * @example
     * // Delete one SavedDoctorHospital
     * const SavedDoctorHospital = await prisma.savedDoctorHospital.delete({
     *   where: {
     *     // ... filter to delete one SavedDoctorHospital
     *   }
     * })
     *
     */
    delete<T extends SavedDoctorHospitalDeleteArgs>(args: SelectSubset<T, SavedDoctorHospitalDeleteArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one SavedDoctorHospital.
     * @param {SavedDoctorHospitalUpdateArgs} args - Arguments to update one SavedDoctorHospital.
     * @example
     * // Update one SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SavedDoctorHospitalUpdateArgs>(args: SelectSubset<T, SavedDoctorHospitalUpdateArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more SavedDoctorHospitals.
     * @param {SavedDoctorHospitalDeleteManyArgs} args - Arguments to filter SavedDoctorHospitals to delete.
     * @example
     * // Delete a few SavedDoctorHospitals
     * const { count } = await prisma.savedDoctorHospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SavedDoctorHospitalDeleteManyArgs>(args?: SelectSubset<T, SavedDoctorHospitalDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more SavedDoctorHospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedDoctorHospitals
     * const savedDoctorHospital = await prisma.savedDoctorHospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SavedDoctorHospitalUpdateManyArgs>(args: SelectSubset<T, SavedDoctorHospitalUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more SavedDoctorHospitals and returns the data updated in the database.
     * @param {SavedDoctorHospitalUpdateManyAndReturnArgs} args - Arguments to update many SavedDoctorHospitals.
     * @example
     * // Update many SavedDoctorHospitals
     * const savedDoctorHospital = await prisma.savedDoctorHospital.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SavedDoctorHospitals and only return the `id`
     * const savedDoctorHospitalWithIdOnly = await prisma.savedDoctorHospital.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SavedDoctorHospitalUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedDoctorHospitalUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one SavedDoctorHospital.
     * @param {SavedDoctorHospitalUpsertArgs} args - Arguments to update or create a SavedDoctorHospital.
     * @example
     * // Update or create a SavedDoctorHospital
     * const savedDoctorHospital = await prisma.savedDoctorHospital.upsert({
     *   create: {
     *     // ... data to create a SavedDoctorHospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedDoctorHospital we want to update
     *   }
     * })
     */
    upsert<T extends SavedDoctorHospitalUpsertArgs>(args: SelectSubset<T, SavedDoctorHospitalUpsertArgs<ExtArgs>>): Prisma__SavedDoctorHospitalClient<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of SavedDoctorHospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalCountArgs} args - Arguments to filter SavedDoctorHospitals to count.
     * @example
     * // Count the number of SavedDoctorHospitals
     * const count = await prisma.savedDoctorHospital.count({
     *   where: {
     *     // ... the filter for the SavedDoctorHospitals we want to count
     *   }
     * })
    **/
    count<T extends SavedDoctorHospitalCountArgs>(args?: Subset<T, SavedDoctorHospitalCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], SavedDoctorHospitalCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a SavedDoctorHospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedDoctorHospitalAggregateArgs>(args: Subset<T, SavedDoctorHospitalAggregateArgs>): PrismaPromise<GetSavedDoctorHospitalAggregateType<T>>;
    /**
     * Group by SavedDoctorHospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedDoctorHospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends SavedDoctorHospitalGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: SavedDoctorHospitalGroupByArgs['orderBy'];
    } : {
        orderBy?: SavedDoctorHospitalGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, SavedDoctorHospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedDoctorHospitalGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the SavedDoctorHospital model
     */
    readonly fields: SavedDoctorHospitalFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for SavedDoctorHospital.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__SavedDoctorHospitalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Doctor<T extends SavedDoctorHospital$DoctorArgs<ExtArgs> = {}>(args?: Subset<T, SavedDoctorHospital$DoctorArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    Hospital<T extends SavedDoctorHospital$HospitalArgs<ExtArgs> = {}>(args?: Subset<T, SavedDoctorHospital$HospitalArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the SavedDoctorHospital model
 */
interface SavedDoctorHospitalFieldRefs {
    readonly id: FieldRef<"SavedDoctorHospital", 'String'>;
    readonly userId: FieldRef<"SavedDoctorHospital", 'String'>;
    readonly doctorId: FieldRef<"SavedDoctorHospital", 'String'>;
    readonly hospitalId: FieldRef<"SavedDoctorHospital", 'String'>;
    readonly createdAt: FieldRef<"SavedDoctorHospital", 'DateTime'>;
    readonly updatedAt: FieldRef<"SavedDoctorHospital", 'DateTime'>;
}
/**
 * SavedDoctorHospital findUnique
 */
type SavedDoctorHospitalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter, which SavedDoctorHospital to fetch.
     */
    where: SavedDoctorHospitalWhereUniqueInput;
};
/**
 * SavedDoctorHospital findUniqueOrThrow
 */
type SavedDoctorHospitalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter, which SavedDoctorHospital to fetch.
     */
    where: SavedDoctorHospitalWhereUniqueInput;
};
/**
 * SavedDoctorHospital findFirst
 */
type SavedDoctorHospitalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter, which SavedDoctorHospital to fetch.
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SavedDoctorHospitals to fetch.
     */
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SavedDoctorHospitals.
     */
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SavedDoctorHospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SavedDoctorHospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SavedDoctorHospitals.
     */
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * SavedDoctorHospital findFirstOrThrow
 */
type SavedDoctorHospitalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter, which SavedDoctorHospital to fetch.
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SavedDoctorHospitals to fetch.
     */
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SavedDoctorHospitals.
     */
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SavedDoctorHospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SavedDoctorHospitals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SavedDoctorHospitals.
     */
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * SavedDoctorHospital findMany
 */
type SavedDoctorHospitalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter, which SavedDoctorHospitals to fetch.
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SavedDoctorHospitals to fetch.
     */
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SavedDoctorHospitals.
     */
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SavedDoctorHospitals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SavedDoctorHospitals.
     */
    skip?: number;
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * SavedDoctorHospital create
 */
type SavedDoctorHospitalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * The data needed to create a SavedDoctorHospital.
     */
    data: XOR<SavedDoctorHospitalCreateInput, SavedDoctorHospitalUncheckedCreateInput>;
};
/**
 * SavedDoctorHospital createMany
 */
type SavedDoctorHospitalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedDoctorHospitals.
     */
    data: SavedDoctorHospitalCreateManyInput | SavedDoctorHospitalCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * SavedDoctorHospital createManyAndReturn
 */
type SavedDoctorHospitalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * The data used to create many SavedDoctorHospitals.
     */
    data: SavedDoctorHospitalCreateManyInput | SavedDoctorHospitalCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * SavedDoctorHospital update
 */
type SavedDoctorHospitalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * The data needed to update a SavedDoctorHospital.
     */
    data: XOR<SavedDoctorHospitalUpdateInput, SavedDoctorHospitalUncheckedUpdateInput>;
    /**
     * Choose, which SavedDoctorHospital to update.
     */
    where: SavedDoctorHospitalWhereUniqueInput;
};
/**
 * SavedDoctorHospital updateMany
 */
type SavedDoctorHospitalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedDoctorHospitals.
     */
    data: XOR<SavedDoctorHospitalUpdateManyMutationInput, SavedDoctorHospitalUncheckedUpdateManyInput>;
    /**
     * Filter which SavedDoctorHospitals to update
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * Limit how many SavedDoctorHospitals to update.
     */
    limit?: number;
};
/**
 * SavedDoctorHospital updateManyAndReturn
 */
type SavedDoctorHospitalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * The data used to update SavedDoctorHospitals.
     */
    data: XOR<SavedDoctorHospitalUpdateManyMutationInput, SavedDoctorHospitalUncheckedUpdateManyInput>;
    /**
     * Filter which SavedDoctorHospitals to update
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * Limit how many SavedDoctorHospitals to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * SavedDoctorHospital upsert
 */
type SavedDoctorHospitalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * The filter to search for the SavedDoctorHospital to update in case it exists.
     */
    where: SavedDoctorHospitalWhereUniqueInput;
    /**
     * In case the SavedDoctorHospital found by the `where` argument doesn't exist, create a new SavedDoctorHospital with this data.
     */
    create: XOR<SavedDoctorHospitalCreateInput, SavedDoctorHospitalUncheckedCreateInput>;
    /**
     * In case the SavedDoctorHospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedDoctorHospitalUpdateInput, SavedDoctorHospitalUncheckedUpdateInput>;
};
/**
 * SavedDoctorHospital delete
 */
type SavedDoctorHospitalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    /**
     * Filter which SavedDoctorHospital to delete.
     */
    where: SavedDoctorHospitalWhereUniqueInput;
};
/**
 * SavedDoctorHospital deleteMany
 */
type SavedDoctorHospitalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which SavedDoctorHospitals to delete
     */
    where?: SavedDoctorHospitalWhereInput;
    /**
     * Limit how many SavedDoctorHospitals to delete.
     */
    limit?: number;
};
/**
 * SavedDoctorHospital.Doctor
 */
type SavedDoctorHospital$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    where?: DoctorWhereInput;
};
/**
 * SavedDoctorHospital.Hospital
 */
type SavedDoctorHospital$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    where?: HospitalWhereInput;
};
/**
 * SavedDoctorHospital without action
 */
type SavedDoctorHospitalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
};

/**
 * Model Schedule
 *
 */
type ScheduleModel = runtime.Types.Result.DefaultSelection<$SchedulePayload>;
type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null;
    _avg: ScheduleAvgAggregateOutputType | null;
    _sum: ScheduleSumAggregateOutputType | null;
    _min: ScheduleMinAggregateOutputType | null;
    _max: ScheduleMaxAggregateOutputType | null;
};
type ScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null;
};
type ScheduleSumAggregateOutputType = {
    dayOfWeek: number[];
};
type ScheduleMinAggregateOutputType = {
    id: string | null;
    type: ScheduleType | null;
    startTime: string | null;
    endTime: string | null;
    status: ScheduleStatus | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    doctorId: string | null;
    endDate: string | null;
    hospitalId: string | null;
    startDate: string | null;
    name: string | null;
    period: SchedulePeriod | null;
    isDeactivated: boolean | null;
    isExpired: boolean | null;
    slotLastGeneratedDate: string | null;
};
type ScheduleMaxAggregateOutputType = {
    id: string | null;
    type: ScheduleType | null;
    startTime: string | null;
    endTime: string | null;
    status: ScheduleStatus | null;
    createdBy: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    doctorId: string | null;
    endDate: string | null;
    hospitalId: string | null;
    startDate: string | null;
    name: string | null;
    period: SchedulePeriod | null;
    isDeactivated: boolean | null;
    isExpired: boolean | null;
    slotLastGeneratedDate: string | null;
};
type ScheduleCountAggregateOutputType = {
    id: number;
    type: number;
    startTime: number;
    endTime: number;
    status: number;
    createdBy: number;
    createdAt: number;
    updatedAt: number;
    doctorId: number;
    endDate: number;
    hospitalId: number;
    startDate: number;
    dayOfWeek: number;
    name: number;
    period: number;
    isDeactivated: number;
    isExpired: number;
    slotLastGeneratedDate: number;
    _all: number;
};
type ScheduleAvgAggregateInputType = {
    dayOfWeek?: true;
};
type ScheduleSumAggregateInputType = {
    dayOfWeek?: true;
};
type ScheduleMinAggregateInputType = {
    id?: true;
    type?: true;
    startTime?: true;
    endTime?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    doctorId?: true;
    endDate?: true;
    hospitalId?: true;
    startDate?: true;
    name?: true;
    period?: true;
    isDeactivated?: true;
    isExpired?: true;
    slotLastGeneratedDate?: true;
};
type ScheduleMaxAggregateInputType = {
    id?: true;
    type?: true;
    startTime?: true;
    endTime?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    doctorId?: true;
    endDate?: true;
    hospitalId?: true;
    startDate?: true;
    name?: true;
    period?: true;
    isDeactivated?: true;
    isExpired?: true;
    slotLastGeneratedDate?: true;
};
type ScheduleCountAggregateInputType = {
    id?: true;
    type?: true;
    startTime?: true;
    endTime?: true;
    status?: true;
    createdBy?: true;
    createdAt?: true;
    updatedAt?: true;
    doctorId?: true;
    endDate?: true;
    hospitalId?: true;
    startDate?: true;
    dayOfWeek?: true;
    name?: true;
    period?: true;
    isDeactivated?: true;
    isExpired?: true;
    slotLastGeneratedDate?: true;
    _all?: true;
};
type ScheduleAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Schedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Schedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType;
};
type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
    [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSchedule[P]> : GetScalarType<T[P], AggregateSchedule[P]>;
};
type ScheduleGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[];
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum;
    having?: ScheduleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ScheduleCountAggregateInputType | true;
    _avg?: ScheduleAvgAggregateInputType;
    _sum?: ScheduleSumAggregateInputType;
    _min?: ScheduleMinAggregateInputType;
    _max?: ScheduleMaxAggregateInputType;
};
type ScheduleGroupByOutputType = {
    id: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status: ScheduleStatus;
    createdBy: string;
    createdAt: Date;
    updatedAt: Date;
    doctorId: string;
    endDate: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek: number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated: boolean;
    isExpired: boolean;
    slotLastGeneratedDate: string | null;
    _count: ScheduleCountAggregateOutputType | null;
    _avg: ScheduleAvgAggregateOutputType | null;
    _sum: ScheduleSumAggregateOutputType | null;
    _min: ScheduleMinAggregateOutputType | null;
    _max: ScheduleMaxAggregateOutputType | null;
};
type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = PrismaPromise<Array<PickEnumerable<ScheduleGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], ScheduleGroupByOutputType[P]> : GetScalarType<T[P], ScheduleGroupByOutputType[P]>;
}>>;
type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[];
    OR?: ScheduleWhereInput[];
    NOT?: ScheduleWhereInput | ScheduleWhereInput[];
    id?: StringFilter<"Schedule"> | string;
    type?: EnumScheduleTypeFilter<"Schedule"> | ScheduleType;
    startTime?: StringFilter<"Schedule"> | string;
    endTime?: StringFilter<"Schedule"> | string;
    status?: EnumScheduleStatusFilter<"Schedule"> | ScheduleStatus;
    createdBy?: StringFilter<"Schedule"> | string;
    createdAt?: DateTimeFilter<"Schedule"> | Date | string;
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string;
    doctorId?: StringFilter<"Schedule"> | string;
    endDate?: StringNullableFilter<"Schedule"> | string | null;
    hospitalId?: StringFilter<"Schedule"> | string;
    startDate?: StringFilter<"Schedule"> | string;
    dayOfWeek?: IntNullableListFilter<"Schedule">;
    name?: StringFilter<"Schedule"> | string;
    period?: EnumSchedulePeriodFilter<"Schedule"> | SchedulePeriod;
    isDeactivated?: BoolFilter<"Schedule"> | boolean;
    isExpired?: BoolFilter<"Schedule"> | boolean;
    slotLastGeneratedDate?: StringNullableFilter<"Schedule"> | string | null;
    Appointment?: AppointmentListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Slot?: SlotListRelationFilter;
};
type ScheduleOrderByWithRelationInput = {
    id?: SortOrder;
    type?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    doctorId?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    hospitalId?: SortOrder;
    startDate?: SortOrder;
    dayOfWeek?: SortOrder;
    name?: SortOrder;
    period?: SortOrder;
    isDeactivated?: SortOrder;
    isExpired?: SortOrder;
    slotLastGeneratedDate?: SortOrderInput | SortOrder;
    Appointment?: AppointmentOrderByRelationAggregateInput;
    User?: UserOrderByWithRelationInput;
    Doctor?: DoctorOrderByWithRelationInput;
    Hospital?: HospitalOrderByWithRelationInput;
    Slot?: SlotOrderByRelationAggregateInput;
};
type ScheduleWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: ScheduleWhereInput | ScheduleWhereInput[];
    OR?: ScheduleWhereInput[];
    NOT?: ScheduleWhereInput | ScheduleWhereInput[];
    type?: EnumScheduleTypeFilter<"Schedule"> | ScheduleType;
    startTime?: StringFilter<"Schedule"> | string;
    endTime?: StringFilter<"Schedule"> | string;
    status?: EnumScheduleStatusFilter<"Schedule"> | ScheduleStatus;
    createdBy?: StringFilter<"Schedule"> | string;
    createdAt?: DateTimeFilter<"Schedule"> | Date | string;
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string;
    doctorId?: StringFilter<"Schedule"> | string;
    endDate?: StringNullableFilter<"Schedule"> | string | null;
    hospitalId?: StringFilter<"Schedule"> | string;
    startDate?: StringFilter<"Schedule"> | string;
    dayOfWeek?: IntNullableListFilter<"Schedule">;
    name?: StringFilter<"Schedule"> | string;
    period?: EnumSchedulePeriodFilter<"Schedule"> | SchedulePeriod;
    isDeactivated?: BoolFilter<"Schedule"> | boolean;
    isExpired?: BoolFilter<"Schedule"> | boolean;
    slotLastGeneratedDate?: StringNullableFilter<"Schedule"> | string | null;
    Appointment?: AppointmentListRelationFilter;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
    Doctor?: XOR<DoctorScalarRelationFilter, DoctorWhereInput>;
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>;
    Slot?: SlotListRelationFilter;
}, "id">;
type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder;
    type?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    doctorId?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    hospitalId?: SortOrder;
    startDate?: SortOrder;
    dayOfWeek?: SortOrder;
    name?: SortOrder;
    period?: SortOrder;
    isDeactivated?: SortOrder;
    isExpired?: SortOrder;
    slotLastGeneratedDate?: SortOrderInput | SortOrder;
    _count?: ScheduleCountOrderByAggregateInput;
    _avg?: ScheduleAvgOrderByAggregateInput;
    _max?: ScheduleMaxOrderByAggregateInput;
    _min?: ScheduleMinOrderByAggregateInput;
    _sum?: ScheduleSumOrderByAggregateInput;
};
type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[];
    OR?: ScheduleScalarWhereWithAggregatesInput[];
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Schedule"> | string;
    type?: EnumScheduleTypeWithAggregatesFilter<"Schedule"> | ScheduleType;
    startTime?: StringWithAggregatesFilter<"Schedule"> | string;
    endTime?: StringWithAggregatesFilter<"Schedule"> | string;
    status?: EnumScheduleStatusWithAggregatesFilter<"Schedule"> | ScheduleStatus;
    createdBy?: StringWithAggregatesFilter<"Schedule"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string;
    doctorId?: StringWithAggregatesFilter<"Schedule"> | string;
    endDate?: StringNullableWithAggregatesFilter<"Schedule"> | string | null;
    hospitalId?: StringWithAggregatesFilter<"Schedule"> | string;
    startDate?: StringWithAggregatesFilter<"Schedule"> | string;
    dayOfWeek?: IntNullableListFilter<"Schedule">;
    name?: StringWithAggregatesFilter<"Schedule"> | string;
    period?: EnumSchedulePeriodWithAggregatesFilter<"Schedule"> | SchedulePeriod;
    isDeactivated?: BoolWithAggregatesFilter<"Schedule"> | boolean;
    isExpired?: BoolWithAggregatesFilter<"Schedule"> | boolean;
    slotLastGeneratedDate?: StringNullableWithAggregatesFilter<"Schedule"> | string | null;
};
type ScheduleCreateInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentCreateNestedManyWithoutScheduleInput;
    User: UserCreateNestedOneWithoutScheduleInput;
    Doctor: DoctorCreateNestedOneWithoutScheduleInput;
    Hospital: HospitalCreateNestedOneWithoutScheduleInput;
    Slot?: SlotCreateNestedManyWithoutScheduleInput;
};
type ScheduleUncheckedCreateInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
    Slot?: SlotUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUpdateManyWithoutScheduleNestedInput;
    User?: UserUpdateOneRequiredWithoutScheduleNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutScheduleNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutScheduleNestedInput;
    Slot?: SlotUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
    Slot?: SlotUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleCreateManyInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
};
type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
};
type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
};
type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput;
    isNot?: ScheduleWhereInput;
};
type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput;
    some?: ScheduleWhereInput;
    none?: ScheduleWhereInput;
};
type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    has?: number | IntFieldRefInput<$PrismaModel> | null;
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>;
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
};
type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    doctorId?: SortOrder;
    endDate?: SortOrder;
    hospitalId?: SortOrder;
    startDate?: SortOrder;
    dayOfWeek?: SortOrder;
    name?: SortOrder;
    period?: SortOrder;
    isDeactivated?: SortOrder;
    isExpired?: SortOrder;
    slotLastGeneratedDate?: SortOrder;
};
type ScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder;
};
type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    doctorId?: SortOrder;
    endDate?: SortOrder;
    hospitalId?: SortOrder;
    startDate?: SortOrder;
    name?: SortOrder;
    period?: SortOrder;
    isDeactivated?: SortOrder;
    isExpired?: SortOrder;
    slotLastGeneratedDate?: SortOrder;
};
type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder;
    type?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    status?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    doctorId?: SortOrder;
    endDate?: SortOrder;
    hospitalId?: SortOrder;
    startDate?: SortOrder;
    name?: SortOrder;
    period?: SortOrder;
    isDeactivated?: SortOrder;
    isExpired?: SortOrder;
    slotLastGeneratedDate?: SortOrder;
};
type ScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder;
};
type ScheduleCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<ScheduleCreateWithoutAppointmentInput, ScheduleUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: ScheduleCreateOrConnectWithoutAppointmentInput;
    connect?: ScheduleWhereUniqueInput;
};
type ScheduleUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<ScheduleCreateWithoutAppointmentInput, ScheduleUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: ScheduleCreateOrConnectWithoutAppointmentInput;
    upsert?: ScheduleUpsertWithoutAppointmentInput;
    connect?: ScheduleWhereUniqueInput;
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutAppointmentInput, ScheduleUpdateWithoutAppointmentInput>, ScheduleUncheckedUpdateWithoutAppointmentInput>;
};
type ScheduleCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput> | ScheduleCreateWithoutDoctorInput[] | ScheduleUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutDoctorInput | ScheduleCreateOrConnectWithoutDoctorInput[];
    createMany?: ScheduleCreateManyDoctorInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput> | ScheduleCreateWithoutDoctorInput[] | ScheduleUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutDoctorInput | ScheduleCreateOrConnectWithoutDoctorInput[];
    createMany?: ScheduleCreateManyDoctorInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput> | ScheduleCreateWithoutDoctorInput[] | ScheduleUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutDoctorInput | ScheduleCreateOrConnectWithoutDoctorInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutDoctorInput | ScheduleUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: ScheduleCreateManyDoctorInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutDoctorInput | ScheduleUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutDoctorInput | ScheduleUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput> | ScheduleCreateWithoutDoctorInput[] | ScheduleUncheckedCreateWithoutDoctorInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutDoctorInput | ScheduleCreateOrConnectWithoutDoctorInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutDoctorInput | ScheduleUpsertWithWhereUniqueWithoutDoctorInput[];
    createMany?: ScheduleCreateManyDoctorInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutDoctorInput | ScheduleUpdateWithWhereUniqueWithoutDoctorInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutDoctorInput | ScheduleUpdateManyWithWhereWithoutDoctorInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput> | ScheduleCreateWithoutHospitalInput[] | ScheduleUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutHospitalInput | ScheduleCreateOrConnectWithoutHospitalInput[];
    createMany?: ScheduleCreateManyHospitalInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput> | ScheduleCreateWithoutHospitalInput[] | ScheduleUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutHospitalInput | ScheduleCreateOrConnectWithoutHospitalInput[];
    createMany?: ScheduleCreateManyHospitalInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput> | ScheduleCreateWithoutHospitalInput[] | ScheduleUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutHospitalInput | ScheduleCreateOrConnectWithoutHospitalInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutHospitalInput | ScheduleUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: ScheduleCreateManyHospitalInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutHospitalInput | ScheduleUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutHospitalInput | ScheduleUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput> | ScheduleCreateWithoutHospitalInput[] | ScheduleUncheckedCreateWithoutHospitalInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutHospitalInput | ScheduleCreateOrConnectWithoutHospitalInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutHospitalInput | ScheduleUpsertWithWhereUniqueWithoutHospitalInput[];
    createMany?: ScheduleCreateManyHospitalInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutHospitalInput | ScheduleUpdateWithWhereUniqueWithoutHospitalInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutHospitalInput | ScheduleUpdateManyWithWhereWithoutHospitalInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleCreatedayOfWeekInput = {
    set: number[];
};
type EnumScheduleTypeFieldUpdateOperationsInput = {
    set?: ScheduleType;
};
type EnumScheduleStatusFieldUpdateOperationsInput = {
    set?: ScheduleStatus;
};
type ScheduleUpdatedayOfWeekInput = {
    set?: number[];
    push?: number | number[];
};
type EnumSchedulePeriodFieldUpdateOperationsInput = {
    set?: SchedulePeriod;
};
type ScheduleCreateNestedOneWithoutSlotInput = {
    create?: XOR<ScheduleCreateWithoutSlotInput, ScheduleUncheckedCreateWithoutSlotInput>;
    connectOrCreate?: ScheduleCreateOrConnectWithoutSlotInput;
    connect?: ScheduleWhereUniqueInput;
};
type ScheduleUpdateOneRequiredWithoutSlotNestedInput = {
    create?: XOR<ScheduleCreateWithoutSlotInput, ScheduleUncheckedCreateWithoutSlotInput>;
    connectOrCreate?: ScheduleCreateOrConnectWithoutSlotInput;
    upsert?: ScheduleUpsertWithoutSlotInput;
    connect?: ScheduleWhereUniqueInput;
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutSlotInput, ScheduleUpdateWithoutSlotInput>, ScheduleUncheckedUpdateWithoutSlotInput>;
};
type ScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[];
    createMany?: ScheduleCreateManyUserInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[];
    createMany?: ScheduleCreateManyUserInputEnvelope;
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
};
type ScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ScheduleCreateManyUserInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[];
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[];
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ScheduleCreateManyUserInputEnvelope;
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[];
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
};
type ScheduleCreateWithoutAppointmentInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    User: UserCreateNestedOneWithoutScheduleInput;
    Doctor: DoctorCreateNestedOneWithoutScheduleInput;
    Hospital: HospitalCreateNestedOneWithoutScheduleInput;
    Slot?: SlotCreateNestedManyWithoutScheduleInput;
};
type ScheduleUncheckedCreateWithoutAppointmentInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Slot?: SlotUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleCreateOrConnectWithoutAppointmentInput = {
    where: ScheduleWhereUniqueInput;
    create: XOR<ScheduleCreateWithoutAppointmentInput, ScheduleUncheckedCreateWithoutAppointmentInput>;
};
type ScheduleUpsertWithoutAppointmentInput = {
    update: XOR<ScheduleUpdateWithoutAppointmentInput, ScheduleUncheckedUpdateWithoutAppointmentInput>;
    create: XOR<ScheduleCreateWithoutAppointmentInput, ScheduleUncheckedCreateWithoutAppointmentInput>;
    where?: ScheduleWhereInput;
};
type ScheduleUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: ScheduleWhereInput;
    data: XOR<ScheduleUpdateWithoutAppointmentInput, ScheduleUncheckedUpdateWithoutAppointmentInput>;
};
type ScheduleUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneRequiredWithoutScheduleNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutScheduleNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutScheduleNestedInput;
    Slot?: SlotUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Slot?: SlotUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleCreateWithoutDoctorInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentCreateNestedManyWithoutScheduleInput;
    User: UserCreateNestedOneWithoutScheduleInput;
    Hospital: HospitalCreateNestedOneWithoutScheduleInput;
    Slot?: SlotCreateNestedManyWithoutScheduleInput;
};
type ScheduleUncheckedCreateWithoutDoctorInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
    Slot?: SlotUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleCreateOrConnectWithoutDoctorInput = {
    where: ScheduleWhereUniqueInput;
    create: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput>;
};
type ScheduleCreateManyDoctorInputEnvelope = {
    data: ScheduleCreateManyDoctorInput | ScheduleCreateManyDoctorInput[];
    skipDuplicates?: boolean;
};
type ScheduleUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ScheduleWhereUniqueInput;
    update: XOR<ScheduleUpdateWithoutDoctorInput, ScheduleUncheckedUpdateWithoutDoctorInput>;
    create: XOR<ScheduleCreateWithoutDoctorInput, ScheduleUncheckedCreateWithoutDoctorInput>;
};
type ScheduleUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ScheduleWhereUniqueInput;
    data: XOR<ScheduleUpdateWithoutDoctorInput, ScheduleUncheckedUpdateWithoutDoctorInput>;
};
type ScheduleUpdateManyWithWhereWithoutDoctorInput = {
    where: ScheduleScalarWhereInput;
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutDoctorInput>;
};
type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
    OR?: ScheduleScalarWhereInput[];
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[];
    id?: StringFilter<"Schedule"> | string;
    type?: EnumScheduleTypeFilter<"Schedule"> | ScheduleType;
    startTime?: StringFilter<"Schedule"> | string;
    endTime?: StringFilter<"Schedule"> | string;
    status?: EnumScheduleStatusFilter<"Schedule"> | ScheduleStatus;
    createdBy?: StringFilter<"Schedule"> | string;
    createdAt?: DateTimeFilter<"Schedule"> | Date | string;
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string;
    doctorId?: StringFilter<"Schedule"> | string;
    endDate?: StringNullableFilter<"Schedule"> | string | null;
    hospitalId?: StringFilter<"Schedule"> | string;
    startDate?: StringFilter<"Schedule"> | string;
    dayOfWeek?: IntNullableListFilter<"Schedule">;
    name?: StringFilter<"Schedule"> | string;
    period?: EnumSchedulePeriodFilter<"Schedule"> | SchedulePeriod;
    isDeactivated?: BoolFilter<"Schedule"> | boolean;
    isExpired?: BoolFilter<"Schedule"> | boolean;
    slotLastGeneratedDate?: StringNullableFilter<"Schedule"> | string | null;
};
type ScheduleCreateWithoutHospitalInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentCreateNestedManyWithoutScheduleInput;
    User: UserCreateNestedOneWithoutScheduleInput;
    Doctor: DoctorCreateNestedOneWithoutScheduleInput;
    Slot?: SlotCreateNestedManyWithoutScheduleInput;
};
type ScheduleUncheckedCreateWithoutHospitalInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
    Slot?: SlotUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleCreateOrConnectWithoutHospitalInput = {
    where: ScheduleWhereUniqueInput;
    create: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput>;
};
type ScheduleCreateManyHospitalInputEnvelope = {
    data: ScheduleCreateManyHospitalInput | ScheduleCreateManyHospitalInput[];
    skipDuplicates?: boolean;
};
type ScheduleUpsertWithWhereUniqueWithoutHospitalInput = {
    where: ScheduleWhereUniqueInput;
    update: XOR<ScheduleUpdateWithoutHospitalInput, ScheduleUncheckedUpdateWithoutHospitalInput>;
    create: XOR<ScheduleCreateWithoutHospitalInput, ScheduleUncheckedCreateWithoutHospitalInput>;
};
type ScheduleUpdateWithWhereUniqueWithoutHospitalInput = {
    where: ScheduleWhereUniqueInput;
    data: XOR<ScheduleUpdateWithoutHospitalInput, ScheduleUncheckedUpdateWithoutHospitalInput>;
};
type ScheduleUpdateManyWithWhereWithoutHospitalInput = {
    where: ScheduleScalarWhereInput;
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutHospitalInput>;
};
type ScheduleCreateWithoutSlotInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentCreateNestedManyWithoutScheduleInput;
    User: UserCreateNestedOneWithoutScheduleInput;
    Doctor: DoctorCreateNestedOneWithoutScheduleInput;
    Hospital: HospitalCreateNestedOneWithoutScheduleInput;
};
type ScheduleUncheckedCreateWithoutSlotInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleCreateOrConnectWithoutSlotInput = {
    where: ScheduleWhereUniqueInput;
    create: XOR<ScheduleCreateWithoutSlotInput, ScheduleUncheckedCreateWithoutSlotInput>;
};
type ScheduleUpsertWithoutSlotInput = {
    update: XOR<ScheduleUpdateWithoutSlotInput, ScheduleUncheckedUpdateWithoutSlotInput>;
    create: XOR<ScheduleCreateWithoutSlotInput, ScheduleUncheckedCreateWithoutSlotInput>;
    where?: ScheduleWhereInput;
};
type ScheduleUpdateToOneWithWhereWithoutSlotInput = {
    where?: ScheduleWhereInput;
    data: XOR<ScheduleUpdateWithoutSlotInput, ScheduleUncheckedUpdateWithoutSlotInput>;
};
type ScheduleUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUpdateManyWithoutScheduleNestedInput;
    User?: UserUpdateOneRequiredWithoutScheduleNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutScheduleNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleCreateWithoutUserInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentCreateNestedManyWithoutScheduleInput;
    Doctor: DoctorCreateNestedOneWithoutScheduleInput;
    Hospital: HospitalCreateNestedOneWithoutScheduleInput;
    Slot?: SlotCreateNestedManyWithoutScheduleInput;
};
type ScheduleUncheckedCreateWithoutUserInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
    Appointment?: AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
    Slot?: SlotUncheckedCreateNestedManyWithoutScheduleInput;
};
type ScheduleCreateOrConnectWithoutUserInput = {
    where: ScheduleWhereUniqueInput;
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>;
};
type ScheduleCreateManyUserInputEnvelope = {
    data: ScheduleCreateManyUserInput | ScheduleCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type ScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput;
    update: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>;
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>;
};
type ScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput;
    data: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>;
};
type ScheduleUpdateManyWithWhereWithoutUserInput = {
    where: ScheduleScalarWhereInput;
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutUserInput>;
};
type ScheduleCreateManyDoctorInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
};
type ScheduleUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUpdateManyWithoutScheduleNestedInput;
    User?: UserUpdateOneRequiredWithoutScheduleNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutScheduleNestedInput;
    Slot?: SlotUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
    Slot?: SlotUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
};
type ScheduleCreateManyHospitalInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdBy: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
};
type ScheduleUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUpdateManyWithoutScheduleNestedInput;
    User?: UserUpdateOneRequiredWithoutScheduleNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutScheduleNestedInput;
    Slot?: SlotUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
    Slot?: SlotUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateManyWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
};
type ScheduleCreateManyUserInput = {
    id?: string;
    type: ScheduleType;
    startTime: string;
    endTime: string;
    status?: ScheduleStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    doctorId: string;
    endDate?: string | null;
    hospitalId: string;
    startDate: string;
    dayOfWeek?: ScheduleCreatedayOfWeekInput | number[];
    name: string;
    period: SchedulePeriod;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: string | null;
};
type ScheduleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUpdateManyWithoutScheduleNestedInput;
    Doctor?: DoctorUpdateOneRequiredWithoutScheduleNestedInput;
    Hospital?: HospitalUpdateOneRequiredWithoutScheduleNestedInput;
    Slot?: SlotUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
    Appointment?: AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
    Slot?: SlotUncheckedUpdateManyWithoutScheduleNestedInput;
};
type ScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: EnumScheduleTypeFieldUpdateOperationsInput | ScheduleType;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    status?: EnumScheduleStatusFieldUpdateOperationsInput | ScheduleStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    doctorId?: StringFieldUpdateOperationsInput | string;
    endDate?: NullableStringFieldUpdateOperationsInput | string | null;
    hospitalId?: StringFieldUpdateOperationsInput | string;
    startDate?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: ScheduleUpdatedayOfWeekInput | number[];
    name?: StringFieldUpdateOperationsInput | string;
    period?: EnumSchedulePeriodFieldUpdateOperationsInput | SchedulePeriod;
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean;
    isExpired?: BoolFieldUpdateOperationsInput | boolean;
    slotLastGeneratedDate?: NullableStringFieldUpdateOperationsInput | string | null;
};
/**
 * Count Type ScheduleCountOutputType
 */
type ScheduleCountOutputType = {
    Appointment: number;
    Slot: number;
};
type ScheduleCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | ScheduleCountOutputTypeCountAppointmentArgs;
    Slot?: boolean | ScheduleCountOutputTypeCountSlotArgs;
};
/**
 * ScheduleCountOutputType without action
 */
type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null;
};
/**
 * ScheduleCountOutputType without action
 */
type ScheduleCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
};
/**
 * ScheduleCountOutputType without action
 */
type ScheduleCountOutputTypeCountSlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SlotWhereInput;
};
type ScheduleSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    type?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    status?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    doctorId?: boolean;
    endDate?: boolean;
    hospitalId?: boolean;
    startDate?: boolean;
    dayOfWeek?: boolean;
    name?: boolean;
    period?: boolean;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: boolean;
    Appointment?: boolean | Schedule$AppointmentArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Slot?: boolean | Schedule$SlotArgs<ExtArgs>;
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["schedule"]>;
type ScheduleSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    type?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    status?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    doctorId?: boolean;
    endDate?: boolean;
    hospitalId?: boolean;
    startDate?: boolean;
    dayOfWeek?: boolean;
    name?: boolean;
    period?: boolean;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["schedule"]>;
type ScheduleSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    type?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    status?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    doctorId?: boolean;
    endDate?: boolean;
    hospitalId?: boolean;
    startDate?: boolean;
    dayOfWeek?: boolean;
    name?: boolean;
    period?: boolean;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["schedule"]>;
type ScheduleSelectScalar = {
    id?: boolean;
    type?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    status?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    doctorId?: boolean;
    endDate?: boolean;
    hospitalId?: boolean;
    startDate?: boolean;
    dayOfWeek?: boolean;
    name?: boolean;
    period?: boolean;
    isDeactivated?: boolean;
    isExpired?: boolean;
    slotLastGeneratedDate?: boolean;
};
type ScheduleOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "type" | "startTime" | "endTime" | "status" | "createdBy" | "createdAt" | "updatedAt" | "doctorId" | "endDate" | "hospitalId" | "startDate" | "dayOfWeek" | "name" | "period" | "isDeactivated" | "isExpired" | "slotLastGeneratedDate", ExtArgs["result"]["schedule"]>;
type ScheduleInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Schedule$AppointmentArgs<ExtArgs>;
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
    Slot?: boolean | Schedule$SlotArgs<ExtArgs>;
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>;
};
type ScheduleIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
};
type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
    Doctor?: boolean | DoctorDefaultArgs<ExtArgs>;
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>;
};
type $SchedulePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Schedule";
    objects: {
        Appointment: $AppointmentPayload<ExtArgs>[];
        User: $UserPayload<ExtArgs>;
        Doctor: $DoctorPayload<ExtArgs>;
        Hospital: $HospitalPayload<ExtArgs>;
        Slot: $SlotPayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        type: ScheduleType;
        startTime: string;
        endTime: string;
        status: ScheduleStatus;
        createdBy: string;
        createdAt: Date;
        updatedAt: Date;
        doctorId: string;
        endDate: string | null;
        hospitalId: string;
        startDate: string;
        dayOfWeek: number[];
        name: string;
        period: SchedulePeriod;
        isDeactivated: boolean;
        isExpired: boolean;
        slotLastGeneratedDate: string | null;
    }, ExtArgs["result"]["schedule"]>;
    composites: {};
};
type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = runtime.Types.Result.GetResult<$SchedulePayload, S>;
type ScheduleCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ScheduleCountAggregateInputType | true;
};
interface ScheduleDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Schedule'];
        meta: {
            name: 'Schedule';
        };
    };
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     *
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     *
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     *
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(args?: Subset<T, ScheduleCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], ScheduleCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): PrismaPromise<GetScheduleAggregateType<T>>;
    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends ScheduleGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: ScheduleGroupByArgs['orderBy'];
    } : {
        orderBy?: ScheduleGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Schedule model
     */
    readonly fields: ScheduleFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Schedule.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment<T extends Schedule$AppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$AppointmentArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    Slot<T extends Schedule$SlotArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$SlotArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Schedule model
 */
interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>;
    readonly type: FieldRef<"Schedule", 'ScheduleType'>;
    readonly startTime: FieldRef<"Schedule", 'String'>;
    readonly endTime: FieldRef<"Schedule", 'String'>;
    readonly status: FieldRef<"Schedule", 'ScheduleStatus'>;
    readonly createdBy: FieldRef<"Schedule", 'String'>;
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>;
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>;
    readonly doctorId: FieldRef<"Schedule", 'String'>;
    readonly endDate: FieldRef<"Schedule", 'String'>;
    readonly hospitalId: FieldRef<"Schedule", 'String'>;
    readonly startDate: FieldRef<"Schedule", 'String'>;
    readonly dayOfWeek: FieldRef<"Schedule", 'Int[]'>;
    readonly name: FieldRef<"Schedule", 'String'>;
    readonly period: FieldRef<"Schedule", 'SchedulePeriod'>;
    readonly isDeactivated: FieldRef<"Schedule", 'Boolean'>;
    readonly isExpired: FieldRef<"Schedule", 'Boolean'>;
    readonly slotLastGeneratedDate: FieldRef<"Schedule", 'String'>;
}
/**
 * Schedule findUnique
 */
type ScheduleFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput;
};
/**
 * Schedule findUniqueOrThrow
 */
type ScheduleFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput;
};
/**
 * Schedule findFirst
 */
type ScheduleFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Schedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Schedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * Schedule findFirstOrThrow
 */
type ScheduleFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Schedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Schedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * Schedule findMany
 */
type ScheduleFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Schedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Schedules.
     */
    skip?: number;
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * Schedule create
 */
type ScheduleCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>;
};
/**
 * Schedule createMany
 */
type ScheduleCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Schedule createManyAndReturn
 */
type ScheduleCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Schedule update
 */
type ScheduleUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>;
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput;
};
/**
 * Schedule updateMany
 */
type ScheduleUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>;
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput;
    /**
     * Limit how many Schedules to update.
     */
    limit?: number;
};
/**
 * Schedule updateManyAndReturn
 */
type ScheduleUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>;
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput;
    /**
     * Limit how many Schedules to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Schedule upsert
 */
type ScheduleUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput;
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>;
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>;
};
/**
 * Schedule delete
 */
type ScheduleDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput;
};
/**
 * Schedule deleteMany
 */
type ScheduleDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput;
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number;
};
/**
 * Schedule.Appointment
 */
type Schedule$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    cursor?: AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * Schedule.Slot
 */
type Schedule$SlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    where?: SlotWhereInput;
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[];
    cursor?: SlotWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[];
};
/**
 * Schedule without action
 */
type ScheduleDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
};

/**
 * Model SearchLog
 *
 */
type SearchLogModel = runtime.Types.Result.DefaultSelection<$SearchLogPayload>;
type AggregateSearchLog = {
    _count: SearchLogCountAggregateOutputType | null;
    _min: SearchLogMinAggregateOutputType | null;
    _max: SearchLogMaxAggregateOutputType | null;
};
type SearchLogMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    query: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type SearchLogMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    query: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type SearchLogCountAggregateOutputType = {
    id: number;
    userId: number;
    query: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type SearchLogMinAggregateInputType = {
    id?: true;
    userId?: true;
    query?: true;
    createdAt?: true;
    updatedAt?: true;
};
type SearchLogMaxAggregateInputType = {
    id?: true;
    userId?: true;
    query?: true;
    createdAt?: true;
    updatedAt?: true;
};
type SearchLogCountAggregateInputType = {
    id?: true;
    userId?: true;
    query?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type SearchLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which SearchLog to aggregate.
     */
    where?: SearchLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SearchLogs to fetch.
     */
    orderBy?: SearchLogOrderByWithRelationInput | SearchLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SearchLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SearchLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SearchLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SearchLogs
    **/
    _count?: true | SearchLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SearchLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SearchLogMaxAggregateInputType;
};
type GetSearchLogAggregateType<T extends SearchLogAggregateArgs> = {
    [P in keyof T & keyof AggregateSearchLog]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSearchLog[P]> : GetScalarType<T[P], AggregateSearchLog[P]>;
};
type SearchLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SearchLogWhereInput;
    orderBy?: SearchLogOrderByWithAggregationInput | SearchLogOrderByWithAggregationInput[];
    by: SearchLogScalarFieldEnum[] | SearchLogScalarFieldEnum;
    having?: SearchLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SearchLogCountAggregateInputType | true;
    _min?: SearchLogMinAggregateInputType;
    _max?: SearchLogMaxAggregateInputType;
};
type SearchLogGroupByOutputType = {
    id: string;
    userId: string;
    query: string;
    createdAt: Date;
    updatedAt: Date;
    _count: SearchLogCountAggregateOutputType | null;
    _min: SearchLogMinAggregateOutputType | null;
    _max: SearchLogMaxAggregateOutputType | null;
};
type GetSearchLogGroupByPayload<T extends SearchLogGroupByArgs> = PrismaPromise<Array<PickEnumerable<SearchLogGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof SearchLogGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], SearchLogGroupByOutputType[P]> : GetScalarType<T[P], SearchLogGroupByOutputType[P]>;
}>>;
type SearchLogWhereInput = {
    AND?: SearchLogWhereInput | SearchLogWhereInput[];
    OR?: SearchLogWhereInput[];
    NOT?: SearchLogWhereInput | SearchLogWhereInput[];
    id?: StringFilter<"SearchLog"> | string;
    userId?: StringFilter<"SearchLog"> | string;
    query?: StringFilter<"SearchLog"> | string;
    createdAt?: DateTimeFilter<"SearchLog"> | Date | string;
    updatedAt?: DateTimeFilter<"SearchLog"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type SearchLogOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    query?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    User?: UserOrderByWithRelationInput;
};
type SearchLogWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: SearchLogWhereInput | SearchLogWhereInput[];
    OR?: SearchLogWhereInput[];
    NOT?: SearchLogWhereInput | SearchLogWhereInput[];
    userId?: StringFilter<"SearchLog"> | string;
    query?: StringFilter<"SearchLog"> | string;
    createdAt?: DateTimeFilter<"SearchLog"> | Date | string;
    updatedAt?: DateTimeFilter<"SearchLog"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id">;
type SearchLogOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    query?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SearchLogCountOrderByAggregateInput;
    _max?: SearchLogMaxOrderByAggregateInput;
    _min?: SearchLogMinOrderByAggregateInput;
};
type SearchLogScalarWhereWithAggregatesInput = {
    AND?: SearchLogScalarWhereWithAggregatesInput | SearchLogScalarWhereWithAggregatesInput[];
    OR?: SearchLogScalarWhereWithAggregatesInput[];
    NOT?: SearchLogScalarWhereWithAggregatesInput | SearchLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SearchLog"> | string;
    userId?: StringWithAggregatesFilter<"SearchLog"> | string;
    query?: StringWithAggregatesFilter<"SearchLog"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"SearchLog"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"SearchLog"> | Date | string;
};
type SearchLogCreateInput = {
    id?: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutSearchLogInput;
};
type SearchLogUncheckedCreateInput = {
    id?: string;
    userId: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SearchLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutSearchLogNestedInput;
};
type SearchLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogCreateManyInput = {
    id?: string;
    userId: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SearchLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    query?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SearchLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    query?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SearchLogMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    query?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type SearchLogListRelationFilter = {
    every?: SearchLogWhereInput;
    some?: SearchLogWhereInput;
    none?: SearchLogWhereInput;
};
type SearchLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type SearchLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput> | SearchLogCreateWithoutUserInput[] | SearchLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SearchLogCreateOrConnectWithoutUserInput | SearchLogCreateOrConnectWithoutUserInput[];
    createMany?: SearchLogCreateManyUserInputEnvelope;
    connect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
};
type SearchLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput> | SearchLogCreateWithoutUserInput[] | SearchLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SearchLogCreateOrConnectWithoutUserInput | SearchLogCreateOrConnectWithoutUserInput[];
    createMany?: SearchLogCreateManyUserInputEnvelope;
    connect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
};
type SearchLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput> | SearchLogCreateWithoutUserInput[] | SearchLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SearchLogCreateOrConnectWithoutUserInput | SearchLogCreateOrConnectWithoutUserInput[];
    upsert?: SearchLogUpsertWithWhereUniqueWithoutUserInput | SearchLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SearchLogCreateManyUserInputEnvelope;
    set?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    disconnect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    delete?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    connect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    update?: SearchLogUpdateWithWhereUniqueWithoutUserInput | SearchLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: SearchLogUpdateManyWithWhereWithoutUserInput | SearchLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SearchLogScalarWhereInput | SearchLogScalarWhereInput[];
};
type SearchLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput> | SearchLogCreateWithoutUserInput[] | SearchLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?: SearchLogCreateOrConnectWithoutUserInput | SearchLogCreateOrConnectWithoutUserInput[];
    upsert?: SearchLogUpsertWithWhereUniqueWithoutUserInput | SearchLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SearchLogCreateManyUserInputEnvelope;
    set?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    disconnect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    delete?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    connect?: SearchLogWhereUniqueInput | SearchLogWhereUniqueInput[];
    update?: SearchLogUpdateWithWhereUniqueWithoutUserInput | SearchLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: SearchLogUpdateManyWithWhereWithoutUserInput | SearchLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SearchLogScalarWhereInput | SearchLogScalarWhereInput[];
};
type SearchLogCreateWithoutUserInput = {
    id?: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SearchLogUncheckedCreateWithoutUserInput = {
    id?: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SearchLogCreateOrConnectWithoutUserInput = {
    where: SearchLogWhereUniqueInput;
    create: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput>;
};
type SearchLogCreateManyUserInputEnvelope = {
    data: SearchLogCreateManyUserInput | SearchLogCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type SearchLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchLogWhereUniqueInput;
    update: XOR<SearchLogUpdateWithoutUserInput, SearchLogUncheckedUpdateWithoutUserInput>;
    create: XOR<SearchLogCreateWithoutUserInput, SearchLogUncheckedCreateWithoutUserInput>;
};
type SearchLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchLogWhereUniqueInput;
    data: XOR<SearchLogUpdateWithoutUserInput, SearchLogUncheckedUpdateWithoutUserInput>;
};
type SearchLogUpdateManyWithWhereWithoutUserInput = {
    where: SearchLogScalarWhereInput;
    data: XOR<SearchLogUpdateManyMutationInput, SearchLogUncheckedUpdateManyWithoutUserInput>;
};
type SearchLogScalarWhereInput = {
    AND?: SearchLogScalarWhereInput | SearchLogScalarWhereInput[];
    OR?: SearchLogScalarWhereInput[];
    NOT?: SearchLogScalarWhereInput | SearchLogScalarWhereInput[];
    id?: StringFilter<"SearchLog"> | string;
    userId?: StringFilter<"SearchLog"> | string;
    query?: StringFilter<"SearchLog"> | string;
    createdAt?: DateTimeFilter<"SearchLog"> | Date | string;
    updatedAt?: DateTimeFilter<"SearchLog"> | Date | string;
};
type SearchLogCreateManyUserInput = {
    id?: string;
    query: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type SearchLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    query?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SearchLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    query?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["searchLog"]>;
type SearchLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    query?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["searchLog"]>;
type SearchLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    userId?: boolean;
    query?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["searchLog"]>;
type SearchLogSelectScalar = {
    id?: boolean;
    userId?: boolean;
    query?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type SearchLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "query" | "createdAt" | "updatedAt", ExtArgs["result"]["searchLog"]>;
type SearchLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type SearchLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type SearchLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $SearchLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "SearchLog";
    objects: {
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        userId: string;
        query: string;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["searchLog"]>;
    composites: {};
};
type SearchLogGetPayload<S extends boolean | null | undefined | SearchLogDefaultArgs> = runtime.Types.Result.GetResult<$SearchLogPayload, S>;
type SearchLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<SearchLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SearchLogCountAggregateInputType | true;
};
interface SearchLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['SearchLog'];
        meta: {
            name: 'SearchLog';
        };
    };
    /**
     * Find zero or one SearchLog that matches the filter.
     * @param {SearchLogFindUniqueArgs} args - Arguments to find a SearchLog
     * @example
     * // Get one SearchLog
     * const searchLog = await prisma.searchLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchLogFindUniqueArgs>(args: SelectSubset<T, SearchLogFindUniqueArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one SearchLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchLogFindUniqueOrThrowArgs} args - Arguments to find a SearchLog
     * @example
     * // Get one SearchLog
     * const searchLog = await prisma.searchLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first SearchLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogFindFirstArgs} args - Arguments to find a SearchLog
     * @example
     * // Get one SearchLog
     * const searchLog = await prisma.searchLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchLogFindFirstArgs>(args?: SelectSubset<T, SearchLogFindFirstArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first SearchLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogFindFirstOrThrowArgs} args - Arguments to find a SearchLog
     * @example
     * // Get one SearchLog
     * const searchLog = await prisma.searchLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more SearchLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchLogs
     * const searchLogs = await prisma.searchLog.findMany()
     *
     * // Get first 10 SearchLogs
     * const searchLogs = await prisma.searchLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const searchLogWithIdOnly = await prisma.searchLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SearchLogFindManyArgs>(args?: SelectSubset<T, SearchLogFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a SearchLog.
     * @param {SearchLogCreateArgs} args - Arguments to create a SearchLog.
     * @example
     * // Create one SearchLog
     * const SearchLog = await prisma.searchLog.create({
     *   data: {
     *     // ... data to create a SearchLog
     *   }
     * })
     *
     */
    create<T extends SearchLogCreateArgs>(args: SelectSubset<T, SearchLogCreateArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many SearchLogs.
     * @param {SearchLogCreateManyArgs} args - Arguments to create many SearchLogs.
     * @example
     * // Create many SearchLogs
     * const searchLog = await prisma.searchLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SearchLogCreateManyArgs>(args?: SelectSubset<T, SearchLogCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many SearchLogs and returns the data saved in the database.
     * @param {SearchLogCreateManyAndReturnArgs} args - Arguments to create many SearchLogs.
     * @example
     * // Create many SearchLogs
     * const searchLog = await prisma.searchLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SearchLogs and only return the `id`
     * const searchLogWithIdOnly = await prisma.searchLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SearchLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchLogCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a SearchLog.
     * @param {SearchLogDeleteArgs} args - Arguments to delete one SearchLog.
     * @example
     * // Delete one SearchLog
     * const SearchLog = await prisma.searchLog.delete({
     *   where: {
     *     // ... filter to delete one SearchLog
     *   }
     * })
     *
     */
    delete<T extends SearchLogDeleteArgs>(args: SelectSubset<T, SearchLogDeleteArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one SearchLog.
     * @param {SearchLogUpdateArgs} args - Arguments to update one SearchLog.
     * @example
     * // Update one SearchLog
     * const searchLog = await prisma.searchLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SearchLogUpdateArgs>(args: SelectSubset<T, SearchLogUpdateArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more SearchLogs.
     * @param {SearchLogDeleteManyArgs} args - Arguments to filter SearchLogs to delete.
     * @example
     * // Delete a few SearchLogs
     * const { count } = await prisma.searchLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SearchLogDeleteManyArgs>(args?: SelectSubset<T, SearchLogDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more SearchLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchLogs
     * const searchLog = await prisma.searchLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SearchLogUpdateManyArgs>(args: SelectSubset<T, SearchLogUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more SearchLogs and returns the data updated in the database.
     * @param {SearchLogUpdateManyAndReturnArgs} args - Arguments to update many SearchLogs.
     * @example
     * // Update many SearchLogs
     * const searchLog = await prisma.searchLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SearchLogs and only return the `id`
     * const searchLogWithIdOnly = await prisma.searchLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SearchLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchLogUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one SearchLog.
     * @param {SearchLogUpsertArgs} args - Arguments to update or create a SearchLog.
     * @example
     * // Update or create a SearchLog
     * const searchLog = await prisma.searchLog.upsert({
     *   create: {
     *     // ... data to create a SearchLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchLog we want to update
     *   }
     * })
     */
    upsert<T extends SearchLogUpsertArgs>(args: SelectSubset<T, SearchLogUpsertArgs<ExtArgs>>): Prisma__SearchLogClient<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of SearchLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogCountArgs} args - Arguments to filter SearchLogs to count.
     * @example
     * // Count the number of SearchLogs
     * const count = await prisma.searchLog.count({
     *   where: {
     *     // ... the filter for the SearchLogs we want to count
     *   }
     * })
    **/
    count<T extends SearchLogCountArgs>(args?: Subset<T, SearchLogCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], SearchLogCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a SearchLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchLogAggregateArgs>(args: Subset<T, SearchLogAggregateArgs>): PrismaPromise<GetSearchLogAggregateType<T>>;
    /**
     * Group by SearchLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends SearchLogGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: SearchLogGroupByArgs['orderBy'];
    } : {
        orderBy?: SearchLogGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, SearchLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchLogGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the SearchLog model
     */
    readonly fields: SearchLogFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for SearchLog.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__SearchLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the SearchLog model
 */
interface SearchLogFieldRefs {
    readonly id: FieldRef<"SearchLog", 'String'>;
    readonly userId: FieldRef<"SearchLog", 'String'>;
    readonly query: FieldRef<"SearchLog", 'String'>;
    readonly createdAt: FieldRef<"SearchLog", 'DateTime'>;
    readonly updatedAt: FieldRef<"SearchLog", 'DateTime'>;
}
/**
 * SearchLog findUnique
 */
type SearchLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter, which SearchLog to fetch.
     */
    where: SearchLogWhereUniqueInput;
};
/**
 * SearchLog findUniqueOrThrow
 */
type SearchLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter, which SearchLog to fetch.
     */
    where: SearchLogWhereUniqueInput;
};
/**
 * SearchLog findFirst
 */
type SearchLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter, which SearchLog to fetch.
     */
    where?: SearchLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SearchLogs to fetch.
     */
    orderBy?: SearchLogOrderByWithRelationInput | SearchLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SearchLogs.
     */
    cursor?: SearchLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SearchLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SearchLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SearchLogs.
     */
    distinct?: SearchLogScalarFieldEnum | SearchLogScalarFieldEnum[];
};
/**
 * SearchLog findFirstOrThrow
 */
type SearchLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter, which SearchLog to fetch.
     */
    where?: SearchLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SearchLogs to fetch.
     */
    orderBy?: SearchLogOrderByWithRelationInput | SearchLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SearchLogs.
     */
    cursor?: SearchLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SearchLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SearchLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SearchLogs.
     */
    distinct?: SearchLogScalarFieldEnum | SearchLogScalarFieldEnum[];
};
/**
 * SearchLog findMany
 */
type SearchLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter, which SearchLogs to fetch.
     */
    where?: SearchLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SearchLogs to fetch.
     */
    orderBy?: SearchLogOrderByWithRelationInput | SearchLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SearchLogs.
     */
    cursor?: SearchLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` SearchLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SearchLogs.
     */
    skip?: number;
    distinct?: SearchLogScalarFieldEnum | SearchLogScalarFieldEnum[];
};
/**
 * SearchLog create
 */
type SearchLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a SearchLog.
     */
    data: XOR<SearchLogCreateInput, SearchLogUncheckedCreateInput>;
};
/**
 * SearchLog createMany
 */
type SearchLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchLogs.
     */
    data: SearchLogCreateManyInput | SearchLogCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * SearchLog createManyAndReturn
 */
type SearchLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * The data used to create many SearchLogs.
     */
    data: SearchLogCreateManyInput | SearchLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * SearchLog update
 */
type SearchLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a SearchLog.
     */
    data: XOR<SearchLogUpdateInput, SearchLogUncheckedUpdateInput>;
    /**
     * Choose, which SearchLog to update.
     */
    where: SearchLogWhereUniqueInput;
};
/**
 * SearchLog updateMany
 */
type SearchLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchLogs.
     */
    data: XOR<SearchLogUpdateManyMutationInput, SearchLogUncheckedUpdateManyInput>;
    /**
     * Filter which SearchLogs to update
     */
    where?: SearchLogWhereInput;
    /**
     * Limit how many SearchLogs to update.
     */
    limit?: number;
};
/**
 * SearchLog updateManyAndReturn
 */
type SearchLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * The data used to update SearchLogs.
     */
    data: XOR<SearchLogUpdateManyMutationInput, SearchLogUncheckedUpdateManyInput>;
    /**
     * Filter which SearchLogs to update
     */
    where?: SearchLogWhereInput;
    /**
     * Limit how many SearchLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * SearchLog upsert
 */
type SearchLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the SearchLog to update in case it exists.
     */
    where: SearchLogWhereUniqueInput;
    /**
     * In case the SearchLog found by the `where` argument doesn't exist, create a new SearchLog with this data.
     */
    create: XOR<SearchLogCreateInput, SearchLogUncheckedCreateInput>;
    /**
     * In case the SearchLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchLogUpdateInput, SearchLogUncheckedUpdateInput>;
};
/**
 * SearchLog delete
 */
type SearchLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    /**
     * Filter which SearchLog to delete.
     */
    where: SearchLogWhereUniqueInput;
};
/**
 * SearchLog deleteMany
 */
type SearchLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which SearchLogs to delete
     */
    where?: SearchLogWhereInput;
    /**
     * Limit how many SearchLogs to delete.
     */
    limit?: number;
};
/**
 * SearchLog without action
 */
type SearchLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
};

/**
 * Model Slot
 *
 */
type SlotModel = runtime.Types.Result.DefaultSelection<$SlotPayload>;
type AggregateSlot = {
    _count: SlotCountAggregateOutputType | null;
    _min: SlotMinAggregateOutputType | null;
    _max: SlotMaxAggregateOutputType | null;
};
type SlotMinAggregateOutputType = {
    id: string | null;
    scheduleId: string | null;
    slotStart: Date | null;
    slotEnd: Date | null;
    status: SlotStatus | null;
    appointmentId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    date: Date | null;
};
type SlotMaxAggregateOutputType = {
    id: string | null;
    scheduleId: string | null;
    slotStart: Date | null;
    slotEnd: Date | null;
    status: SlotStatus | null;
    appointmentId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    date: Date | null;
};
type SlotCountAggregateOutputType = {
    id: number;
    scheduleId: number;
    slotStart: number;
    slotEnd: number;
    status: number;
    appointmentId: number;
    createdAt: number;
    updatedAt: number;
    date: number;
    _all: number;
};
type SlotMinAggregateInputType = {
    id?: true;
    scheduleId?: true;
    slotStart?: true;
    slotEnd?: true;
    status?: true;
    appointmentId?: true;
    createdAt?: true;
    updatedAt?: true;
    date?: true;
};
type SlotMaxAggregateInputType = {
    id?: true;
    scheduleId?: true;
    slotStart?: true;
    slotEnd?: true;
    status?: true;
    appointmentId?: true;
    createdAt?: true;
    updatedAt?: true;
    date?: true;
};
type SlotCountAggregateInputType = {
    id?: true;
    scheduleId?: true;
    slotStart?: true;
    slotEnd?: true;
    status?: true;
    appointmentId?: true;
    createdAt?: true;
    updatedAt?: true;
    date?: true;
    _all?: true;
};
type SlotAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Slot to aggregate.
     */
    where?: SlotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SlotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Slots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Slots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Slots
    **/
    _count?: true | SlotCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SlotMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SlotMaxAggregateInputType;
};
type GetSlotAggregateType<T extends SlotAggregateArgs> = {
    [P in keyof T & keyof AggregateSlot]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSlot[P]> : GetScalarType<T[P], AggregateSlot[P]>;
};
type SlotGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SlotWhereInput;
    orderBy?: SlotOrderByWithAggregationInput | SlotOrderByWithAggregationInput[];
    by: SlotScalarFieldEnum[] | SlotScalarFieldEnum;
    having?: SlotScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SlotCountAggregateInputType | true;
    _min?: SlotMinAggregateInputType;
    _max?: SlotMaxAggregateInputType;
};
type SlotGroupByOutputType = {
    id: string;
    scheduleId: string;
    slotStart: Date;
    slotEnd: Date;
    status: SlotStatus;
    appointmentId: string | null;
    createdAt: Date;
    updatedAt: Date;
    date: Date;
    _count: SlotCountAggregateOutputType | null;
    _min: SlotMinAggregateOutputType | null;
    _max: SlotMaxAggregateOutputType | null;
};
type GetSlotGroupByPayload<T extends SlotGroupByArgs> = PrismaPromise<Array<PickEnumerable<SlotGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof SlotGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], SlotGroupByOutputType[P]> : GetScalarType<T[P], SlotGroupByOutputType[P]>;
}>>;
type SlotWhereInput = {
    AND?: SlotWhereInput | SlotWhereInput[];
    OR?: SlotWhereInput[];
    NOT?: SlotWhereInput | SlotWhereInput[];
    id?: StringFilter<"Slot"> | string;
    scheduleId?: StringFilter<"Slot"> | string;
    slotStart?: DateTimeFilter<"Slot"> | Date | string;
    slotEnd?: DateTimeFilter<"Slot"> | Date | string;
    status?: EnumSlotStatusFilter<"Slot"> | SlotStatus;
    appointmentId?: StringNullableFilter<"Slot"> | string | null;
    createdAt?: DateTimeFilter<"Slot"> | Date | string;
    updatedAt?: DateTimeFilter<"Slot"> | Date | string;
    date?: DateTimeFilter<"Slot"> | Date | string;
    Appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null;
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>;
};
type SlotOrderByWithRelationInput = {
    id?: SortOrder;
    scheduleId?: SortOrder;
    slotStart?: SortOrder;
    slotEnd?: SortOrder;
    status?: SortOrder;
    appointmentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    date?: SortOrder;
    Appointment?: AppointmentOrderByWithRelationInput;
    Schedule?: ScheduleOrderByWithRelationInput;
};
type SlotWhereUniqueInput = AtLeast<{
    id?: string;
    appointmentId?: string;
    slotStart_scheduleId_date?: SlotSlotStartScheduleIdDateCompoundUniqueInput;
    AND?: SlotWhereInput | SlotWhereInput[];
    OR?: SlotWhereInput[];
    NOT?: SlotWhereInput | SlotWhereInput[];
    scheduleId?: StringFilter<"Slot"> | string;
    slotStart?: DateTimeFilter<"Slot"> | Date | string;
    slotEnd?: DateTimeFilter<"Slot"> | Date | string;
    status?: EnumSlotStatusFilter<"Slot"> | SlotStatus;
    createdAt?: DateTimeFilter<"Slot"> | Date | string;
    updatedAt?: DateTimeFilter<"Slot"> | Date | string;
    date?: DateTimeFilter<"Slot"> | Date | string;
    Appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null;
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>;
}, "id" | "appointmentId" | "slotStart_scheduleId_date">;
type SlotOrderByWithAggregationInput = {
    id?: SortOrder;
    scheduleId?: SortOrder;
    slotStart?: SortOrder;
    slotEnd?: SortOrder;
    status?: SortOrder;
    appointmentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    date?: SortOrder;
    _count?: SlotCountOrderByAggregateInput;
    _max?: SlotMaxOrderByAggregateInput;
    _min?: SlotMinOrderByAggregateInput;
};
type SlotScalarWhereWithAggregatesInput = {
    AND?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[];
    OR?: SlotScalarWhereWithAggregatesInput[];
    NOT?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Slot"> | string;
    scheduleId?: StringWithAggregatesFilter<"Slot"> | string;
    slotStart?: DateTimeWithAggregatesFilter<"Slot"> | Date | string;
    slotEnd?: DateTimeWithAggregatesFilter<"Slot"> | Date | string;
    status?: EnumSlotStatusWithAggregatesFilter<"Slot"> | SlotStatus;
    appointmentId?: StringNullableWithAggregatesFilter<"Slot"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string;
    date?: DateTimeWithAggregatesFilter<"Slot"> | Date | string;
};
type SlotCreateInput = {
    id?: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
    Appointment?: AppointmentCreateNestedOneWithoutSlotInput;
    Schedule: ScheduleCreateNestedOneWithoutSlotInput;
};
type SlotUncheckedCreateInput = {
    id?: string;
    scheduleId: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    appointmentId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
};
type SlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    Appointment?: AppointmentUpdateOneWithoutSlotNestedInput;
    Schedule?: ScheduleUpdateOneRequiredWithoutSlotNestedInput;
};
type SlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotCreateManyInput = {
    id?: string;
    scheduleId: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    appointmentId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
};
type SlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotNullableScalarRelationFilter = {
    is?: SlotWhereInput | null;
    isNot?: SlotWhereInput | null;
};
type SlotListRelationFilter = {
    every?: SlotWhereInput;
    some?: SlotWhereInput;
    none?: SlotWhereInput;
};
type SlotOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type SlotSlotStartScheduleIdDateCompoundUniqueInput = {
    slotStart: Date | string;
    scheduleId: string;
    date: Date | string;
};
type SlotCountOrderByAggregateInput = {
    id?: SortOrder;
    scheduleId?: SortOrder;
    slotStart?: SortOrder;
    slotEnd?: SortOrder;
    status?: SortOrder;
    appointmentId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    date?: SortOrder;
};
type SlotMaxOrderByAggregateInput = {
    id?: SortOrder;
    scheduleId?: SortOrder;
    slotStart?: SortOrder;
    slotEnd?: SortOrder;
    status?: SortOrder;
    appointmentId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    date?: SortOrder;
};
type SlotMinOrderByAggregateInput = {
    id?: SortOrder;
    scheduleId?: SortOrder;
    slotStart?: SortOrder;
    slotEnd?: SortOrder;
    status?: SortOrder;
    appointmentId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    date?: SortOrder;
};
type SlotCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput;
    connect?: SlotWhereUniqueInput;
};
type SlotUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput;
    connect?: SlotWhereUniqueInput;
};
type SlotUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput;
    upsert?: SlotUpsertWithoutAppointmentInput;
    disconnect?: SlotWhereInput | boolean;
    delete?: SlotWhereInput | boolean;
    connect?: SlotWhereUniqueInput;
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutAppointmentInput, SlotUpdateWithoutAppointmentInput>, SlotUncheckedUpdateWithoutAppointmentInput>;
};
type SlotUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
    connectOrCreate?: SlotCreateOrConnectWithoutAppointmentInput;
    upsert?: SlotUpsertWithoutAppointmentInput;
    disconnect?: SlotWhereInput | boolean;
    delete?: SlotWhereInput | boolean;
    connect?: SlotWhereUniqueInput;
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutAppointmentInput, SlotUpdateWithoutAppointmentInput>, SlotUncheckedUpdateWithoutAppointmentInput>;
};
type SlotCreateNestedManyWithoutScheduleInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[];
    createMany?: SlotCreateManyScheduleInputEnvelope;
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
};
type SlotUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[];
    createMany?: SlotCreateManyScheduleInputEnvelope;
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
};
type SlotUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[];
    upsert?: SlotUpsertWithWhereUniqueWithoutScheduleInput | SlotUpsertWithWhereUniqueWithoutScheduleInput[];
    createMany?: SlotCreateManyScheduleInputEnvelope;
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    update?: SlotUpdateWithWhereUniqueWithoutScheduleInput | SlotUpdateWithWhereUniqueWithoutScheduleInput[];
    updateMany?: SlotUpdateManyWithWhereWithoutScheduleInput | SlotUpdateManyWithWhereWithoutScheduleInput[];
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[];
};
type SlotUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput> | SlotCreateWithoutScheduleInput[] | SlotUncheckedCreateWithoutScheduleInput[];
    connectOrCreate?: SlotCreateOrConnectWithoutScheduleInput | SlotCreateOrConnectWithoutScheduleInput[];
    upsert?: SlotUpsertWithWhereUniqueWithoutScheduleInput | SlotUpsertWithWhereUniqueWithoutScheduleInput[];
    createMany?: SlotCreateManyScheduleInputEnvelope;
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[];
    update?: SlotUpdateWithWhereUniqueWithoutScheduleInput | SlotUpdateWithWhereUniqueWithoutScheduleInput[];
    updateMany?: SlotUpdateManyWithWhereWithoutScheduleInput | SlotUpdateManyWithWhereWithoutScheduleInput[];
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[];
};
type EnumSlotStatusFieldUpdateOperationsInput = {
    set?: SlotStatus;
};
type SlotCreateWithoutAppointmentInput = {
    id?: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
    Schedule: ScheduleCreateNestedOneWithoutSlotInput;
};
type SlotUncheckedCreateWithoutAppointmentInput = {
    id?: string;
    scheduleId: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
};
type SlotCreateOrConnectWithoutAppointmentInput = {
    where: SlotWhereUniqueInput;
    create: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
};
type SlotUpsertWithoutAppointmentInput = {
    update: XOR<SlotUpdateWithoutAppointmentInput, SlotUncheckedUpdateWithoutAppointmentInput>;
    create: XOR<SlotCreateWithoutAppointmentInput, SlotUncheckedCreateWithoutAppointmentInput>;
    where?: SlotWhereInput;
};
type SlotUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: SlotWhereInput;
    data: XOR<SlotUpdateWithoutAppointmentInput, SlotUncheckedUpdateWithoutAppointmentInput>;
};
type SlotUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    Schedule?: ScheduleUpdateOneRequiredWithoutSlotNestedInput;
};
type SlotUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scheduleId?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotCreateWithoutScheduleInput = {
    id?: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
    Appointment?: AppointmentCreateNestedOneWithoutSlotInput;
};
type SlotUncheckedCreateWithoutScheduleInput = {
    id?: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    appointmentId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
};
type SlotCreateOrConnectWithoutScheduleInput = {
    where: SlotWhereUniqueInput;
    create: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput>;
};
type SlotCreateManyScheduleInputEnvelope = {
    data: SlotCreateManyScheduleInput | SlotCreateManyScheduleInput[];
    skipDuplicates?: boolean;
};
type SlotUpsertWithWhereUniqueWithoutScheduleInput = {
    where: SlotWhereUniqueInput;
    update: XOR<SlotUpdateWithoutScheduleInput, SlotUncheckedUpdateWithoutScheduleInput>;
    create: XOR<SlotCreateWithoutScheduleInput, SlotUncheckedCreateWithoutScheduleInput>;
};
type SlotUpdateWithWhereUniqueWithoutScheduleInput = {
    where: SlotWhereUniqueInput;
    data: XOR<SlotUpdateWithoutScheduleInput, SlotUncheckedUpdateWithoutScheduleInput>;
};
type SlotUpdateManyWithWhereWithoutScheduleInput = {
    where: SlotScalarWhereInput;
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyWithoutScheduleInput>;
};
type SlotScalarWhereInput = {
    AND?: SlotScalarWhereInput | SlotScalarWhereInput[];
    OR?: SlotScalarWhereInput[];
    NOT?: SlotScalarWhereInput | SlotScalarWhereInput[];
    id?: StringFilter<"Slot"> | string;
    scheduleId?: StringFilter<"Slot"> | string;
    slotStart?: DateTimeFilter<"Slot"> | Date | string;
    slotEnd?: DateTimeFilter<"Slot"> | Date | string;
    status?: EnumSlotStatusFilter<"Slot"> | SlotStatus;
    appointmentId?: StringNullableFilter<"Slot"> | string | null;
    createdAt?: DateTimeFilter<"Slot"> | Date | string;
    updatedAt?: DateTimeFilter<"Slot"> | Date | string;
    date?: DateTimeFilter<"Slot"> | Date | string;
};
type SlotCreateManyScheduleInput = {
    id?: string;
    slotStart: Date | string;
    slotEnd: Date | string;
    status: SlotStatus;
    appointmentId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    date: Date | string;
};
type SlotUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    Appointment?: AppointmentUpdateOneWithoutSlotNestedInput;
};
type SlotUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slotStart?: DateTimeFieldUpdateOperationsInput | Date | string;
    slotEnd?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: EnumSlotStatusFieldUpdateOperationsInput | SlotStatus;
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SlotSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    scheduleId?: boolean;
    slotStart?: boolean;
    slotEnd?: boolean;
    status?: boolean;
    appointmentId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    date?: boolean;
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["slot"]>;
type SlotSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    scheduleId?: boolean;
    slotStart?: boolean;
    slotEnd?: boolean;
    status?: boolean;
    appointmentId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    date?: boolean;
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["slot"]>;
type SlotSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    scheduleId?: boolean;
    slotStart?: boolean;
    slotEnd?: boolean;
    status?: boolean;
    appointmentId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    date?: boolean;
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["slot"]>;
type SlotSelectScalar = {
    id?: boolean;
    scheduleId?: boolean;
    slotStart?: boolean;
    slotEnd?: boolean;
    status?: boolean;
    appointmentId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    date?: boolean;
};
type SlotOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "scheduleId" | "slotStart" | "slotEnd" | "status" | "appointmentId" | "createdAt" | "updatedAt" | "date", ExtArgs["result"]["slot"]>;
type SlotInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
};
type SlotIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
};
type SlotIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment?: boolean | Slot$AppointmentArgs<ExtArgs>;
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>;
};
type $SlotPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Slot";
    objects: {
        Appointment: $AppointmentPayload<ExtArgs> | null;
        Schedule: $SchedulePayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        scheduleId: string;
        slotStart: Date;
        slotEnd: Date;
        status: SlotStatus;
        appointmentId: string | null;
        createdAt: Date;
        updatedAt: Date;
        date: Date;
    }, ExtArgs["result"]["slot"]>;
    composites: {};
};
type SlotGetPayload<S extends boolean | null | undefined | SlotDefaultArgs> = runtime.Types.Result.GetResult<$SlotPayload, S>;
type SlotCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<SlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SlotCountAggregateInputType | true;
};
interface SlotDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Slot'];
        meta: {
            name: 'Slot';
        };
    };
    /**
     * Find zero or one Slot that matches the filter.
     * @param {SlotFindUniqueArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlotFindUniqueArgs>(args: SelectSubset<T, SlotFindUniqueArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Slot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlotFindUniqueOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlotFindUniqueOrThrowArgs>(args: SelectSubset<T, SlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Slot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlotFindFirstArgs>(args?: SelectSubset<T, SlotFindFirstArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Slot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlotFindFirstOrThrowArgs>(args?: SelectSubset<T, SlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slots
     * const slots = await prisma.slot.findMany()
     *
     * // Get first 10 Slots
     * const slots = await prisma.slot.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const slotWithIdOnly = await prisma.slot.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SlotFindManyArgs>(args?: SelectSubset<T, SlotFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Slot.
     * @param {SlotCreateArgs} args - Arguments to create a Slot.
     * @example
     * // Create one Slot
     * const Slot = await prisma.slot.create({
     *   data: {
     *     // ... data to create a Slot
     *   }
     * })
     *
     */
    create<T extends SlotCreateArgs>(args: SelectSubset<T, SlotCreateArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Slots.
     * @param {SlotCreateManyArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SlotCreateManyArgs>(args?: SelectSubset<T, SlotCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Slots and returns the data saved in the database.
     * @param {SlotCreateManyAndReturnArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SlotCreateManyAndReturnArgs>(args?: SelectSubset<T, SlotCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Slot.
     * @param {SlotDeleteArgs} args - Arguments to delete one Slot.
     * @example
     * // Delete one Slot
     * const Slot = await prisma.slot.delete({
     *   where: {
     *     // ... filter to delete one Slot
     *   }
     * })
     *
     */
    delete<T extends SlotDeleteArgs>(args: SelectSubset<T, SlotDeleteArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Slot.
     * @param {SlotUpdateArgs} args - Arguments to update one Slot.
     * @example
     * // Update one Slot
     * const slot = await prisma.slot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SlotUpdateArgs>(args: SelectSubset<T, SlotUpdateArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Slots.
     * @param {SlotDeleteManyArgs} args - Arguments to filter Slots to delete.
     * @example
     * // Delete a few Slots
     * const { count } = await prisma.slot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SlotDeleteManyArgs>(args?: SelectSubset<T, SlotDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SlotUpdateManyArgs>(args: SelectSubset<T, SlotUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Slots and returns the data updated in the database.
     * @param {SlotUpdateManyAndReturnArgs} args - Arguments to update many Slots.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SlotUpdateManyAndReturnArgs>(args: SelectSubset<T, SlotUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Slot.
     * @param {SlotUpsertArgs} args - Arguments to update or create a Slot.
     * @example
     * // Update or create a Slot
     * const slot = await prisma.slot.upsert({
     *   create: {
     *     // ... data to create a Slot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot we want to update
     *   }
     * })
     */
    upsert<T extends SlotUpsertArgs>(args: SelectSubset<T, SlotUpsertArgs<ExtArgs>>): Prisma__SlotClient<runtime.Types.Result.GetResult<$SlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotCountArgs} args - Arguments to filter Slots to count.
     * @example
     * // Count the number of Slots
     * const count = await prisma.slot.count({
     *   where: {
     *     // ... the filter for the Slots we want to count
     *   }
     * })
    **/
    count<T extends SlotCountArgs>(args?: Subset<T, SlotCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], SlotCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotAggregateArgs>(args: Subset<T, SlotAggregateArgs>): PrismaPromise<GetSlotAggregateType<T>>;
    /**
     * Group by Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends SlotGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: SlotGroupByArgs['orderBy'];
    } : {
        orderBy?: SlotGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, SlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Slot model
     */
    readonly fields: SlotFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Slot.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__SlotClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment<T extends Slot$AppointmentArgs<ExtArgs> = {}>(args?: Subset<T, Slot$AppointmentArgs<ExtArgs>>): Prisma__AppointmentClient<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    Schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Slot model
 */
interface SlotFieldRefs {
    readonly id: FieldRef<"Slot", 'String'>;
    readonly scheduleId: FieldRef<"Slot", 'String'>;
    readonly slotStart: FieldRef<"Slot", 'DateTime'>;
    readonly slotEnd: FieldRef<"Slot", 'DateTime'>;
    readonly status: FieldRef<"Slot", 'SlotStatus'>;
    readonly appointmentId: FieldRef<"Slot", 'String'>;
    readonly createdAt: FieldRef<"Slot", 'DateTime'>;
    readonly updatedAt: FieldRef<"Slot", 'DateTime'>;
    readonly date: FieldRef<"Slot", 'DateTime'>;
}
/**
 * Slot findUnique
 */
type SlotFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput;
};
/**
 * Slot findUniqueOrThrow
 */
type SlotFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput;
};
/**
 * Slot findFirst
 */
type SlotFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Slots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Slots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[];
};
/**
 * Slot findFirstOrThrow
 */
type SlotFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Slots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Slots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[];
};
/**
 * Slot findMany
 */
type SlotFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter, which Slots to fetch.
     */
    where?: SlotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Slots.
     */
    cursor?: SlotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Slots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Slots.
     */
    skip?: number;
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[];
};
/**
 * Slot create
 */
type SlotCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * The data needed to create a Slot.
     */
    data: XOR<SlotCreateInput, SlotUncheckedCreateInput>;
};
/**
 * Slot createMany
 */
type SlotCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Slot createManyAndReturn
 */
type SlotCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * Slot update
 */
type SlotUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * The data needed to update a Slot.
     */
    data: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>;
    /**
     * Choose, which Slot to update.
     */
    where: SlotWhereUniqueInput;
};
/**
 * Slot updateMany
 */
type SlotUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>;
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput;
    /**
     * Limit how many Slots to update.
     */
    limit?: number;
};
/**
 * Slot updateManyAndReturn
 */
type SlotUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>;
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput;
    /**
     * Limit how many Slots to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * Slot upsert
 */
type SlotUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * The filter to search for the Slot to update in case it exists.
     */
    where: SlotWhereUniqueInput;
    /**
     * In case the Slot found by the `where` argument doesn't exist, create a new Slot with this data.
     */
    create: XOR<SlotCreateInput, SlotUncheckedCreateInput>;
    /**
     * In case the Slot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>;
};
/**
 * Slot delete
 */
type SlotDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
    /**
     * Filter which Slot to delete.
     */
    where: SlotWhereUniqueInput;
};
/**
 * Slot deleteMany
 */
type SlotDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Slots to delete
     */
    where?: SlotWhereInput;
    /**
     * Limit how many Slots to delete.
     */
    limit?: number;
};
/**
 * Slot.Appointment
 */
type Slot$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
};
/**
 * Slot without action
 */
type SlotDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null;
};

/**
 * Model Specialization
 *
 */
type SpecializationModel = runtime.Types.Result.DefaultSelection<$SpecializationPayload>;
type AggregateSpecialization = {
    _count: SpecializationCountAggregateOutputType | null;
    _min: SpecializationMinAggregateOutputType | null;
    _max: SpecializationMaxAggregateOutputType | null;
};
type SpecializationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    createdAt: Date | null;
    description: string | null;
    imageURL: string | null;
    slug: string | null;
    updatedAt: Date | null;
};
type SpecializationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    createdAt: Date | null;
    description: string | null;
    imageURL: string | null;
    slug: string | null;
    updatedAt: Date | null;
};
type SpecializationCountAggregateOutputType = {
    id: number;
    name: number;
    createdAt: number;
    description: number;
    imageURL: number;
    slug: number;
    updatedAt: number;
    _all: number;
};
type SpecializationMinAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    description?: true;
    imageURL?: true;
    slug?: true;
    updatedAt?: true;
};
type SpecializationMaxAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    description?: true;
    imageURL?: true;
    slug?: true;
    updatedAt?: true;
};
type SpecializationCountAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    description?: true;
    imageURL?: true;
    slug?: true;
    updatedAt?: true;
    _all?: true;
};
type SpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Specialization to aggregate.
     */
    where?: SpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Specializations to fetch.
     */
    orderBy?: SpecializationOrderByWithRelationInput | SpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Specializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Specializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Specializations
    **/
    _count?: true | SpecializationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SpecializationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SpecializationMaxAggregateInputType;
};
type GetSpecializationAggregateType<T extends SpecializationAggregateArgs> = {
    [P in keyof T & keyof AggregateSpecialization]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSpecialization[P]> : GetScalarType<T[P], AggregateSpecialization[P]>;
};
type SpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SpecializationWhereInput;
    orderBy?: SpecializationOrderByWithAggregationInput | SpecializationOrderByWithAggregationInput[];
    by: SpecializationScalarFieldEnum[] | SpecializationScalarFieldEnum;
    having?: SpecializationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SpecializationCountAggregateInputType | true;
    _min?: SpecializationMinAggregateInputType;
    _max?: SpecializationMaxAggregateInputType;
};
type SpecializationGroupByOutputType = {
    id: string;
    name: string;
    createdAt: Date;
    description: string;
    imageURL: string | null;
    slug: string | null;
    updatedAt: Date;
    _count: SpecializationCountAggregateOutputType | null;
    _min: SpecializationMinAggregateOutputType | null;
    _max: SpecializationMaxAggregateOutputType | null;
};
type GetSpecializationGroupByPayload<T extends SpecializationGroupByArgs> = PrismaPromise<Array<PickEnumerable<SpecializationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof SpecializationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], SpecializationGroupByOutputType[P]> : GetScalarType<T[P], SpecializationGroupByOutputType[P]>;
}>>;
type SpecializationWhereInput = {
    AND?: SpecializationWhereInput | SpecializationWhereInput[];
    OR?: SpecializationWhereInput[];
    NOT?: SpecializationWhereInput | SpecializationWhereInput[];
    id?: StringFilter<"Specialization"> | string;
    name?: StringFilter<"Specialization"> | string;
    createdAt?: DateTimeFilter<"Specialization"> | Date | string;
    description?: StringFilter<"Specialization"> | string;
    imageURL?: StringNullableFilter<"Specialization"> | string | null;
    slug?: StringNullableFilter<"Specialization"> | string | null;
    updatedAt?: DateTimeFilter<"Specialization"> | Date | string;
    DoctorSpecialization?: DoctorSpecializationListRelationFilter;
    HospitalSpecialization?: HospitalSpecializationListRelationFilter;
};
type SpecializationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    description?: SortOrder;
    imageURL?: SortOrderInput | SortOrder;
    slug?: SortOrderInput | SortOrder;
    updatedAt?: SortOrder;
    DoctorSpecialization?: DoctorSpecializationOrderByRelationAggregateInput;
    HospitalSpecialization?: HospitalSpecializationOrderByRelationAggregateInput;
};
type SpecializationWhereUniqueInput = AtLeast<{
    id?: string;
    name?: string;
    AND?: SpecializationWhereInput | SpecializationWhereInput[];
    OR?: SpecializationWhereInput[];
    NOT?: SpecializationWhereInput | SpecializationWhereInput[];
    createdAt?: DateTimeFilter<"Specialization"> | Date | string;
    description?: StringFilter<"Specialization"> | string;
    imageURL?: StringNullableFilter<"Specialization"> | string | null;
    slug?: StringNullableFilter<"Specialization"> | string | null;
    updatedAt?: DateTimeFilter<"Specialization"> | Date | string;
    DoctorSpecialization?: DoctorSpecializationListRelationFilter;
    HospitalSpecialization?: HospitalSpecializationListRelationFilter;
}, "id" | "name">;
type SpecializationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    description?: SortOrder;
    imageURL?: SortOrderInput | SortOrder;
    slug?: SortOrderInput | SortOrder;
    updatedAt?: SortOrder;
    _count?: SpecializationCountOrderByAggregateInput;
    _max?: SpecializationMaxOrderByAggregateInput;
    _min?: SpecializationMinOrderByAggregateInput;
};
type SpecializationScalarWhereWithAggregatesInput = {
    AND?: SpecializationScalarWhereWithAggregatesInput | SpecializationScalarWhereWithAggregatesInput[];
    OR?: SpecializationScalarWhereWithAggregatesInput[];
    NOT?: SpecializationScalarWhereWithAggregatesInput | SpecializationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Specialization"> | string;
    name?: StringWithAggregatesFilter<"Specialization"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Specialization"> | Date | string;
    description?: StringWithAggregatesFilter<"Specialization"> | string;
    imageURL?: StringNullableWithAggregatesFilter<"Specialization"> | string | null;
    slug?: StringNullableWithAggregatesFilter<"Specialization"> | string | null;
    updatedAt?: DateTimeWithAggregatesFilter<"Specialization"> | Date | string;
};
type SpecializationCreateInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutSpecializationInput;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutSpecializationInput;
};
type SpecializationUncheckedCreateInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
};
type SpecializationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutSpecializationNestedInput;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutSpecializationNestedInput;
};
type SpecializationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
};
type SpecializationCreateManyInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
};
type SpecializationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SpecializationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type SpecializationScalarRelationFilter = {
    is?: SpecializationWhereInput;
    isNot?: SpecializationWhereInput;
};
type SpecializationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    description?: SortOrder;
    imageURL?: SortOrder;
    slug?: SortOrder;
    updatedAt?: SortOrder;
};
type SpecializationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    description?: SortOrder;
    imageURL?: SortOrder;
    slug?: SortOrder;
    updatedAt?: SortOrder;
};
type SpecializationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    description?: SortOrder;
    imageURL?: SortOrder;
    slug?: SortOrder;
    updatedAt?: SortOrder;
};
type SpecializationCreateNestedOneWithoutDoctorSpecializationInput = {
    create?: XOR<SpecializationCreateWithoutDoctorSpecializationInput, SpecializationUncheckedCreateWithoutDoctorSpecializationInput>;
    connectOrCreate?: SpecializationCreateOrConnectWithoutDoctorSpecializationInput;
    connect?: SpecializationWhereUniqueInput;
};
type SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput = {
    create?: XOR<SpecializationCreateWithoutDoctorSpecializationInput, SpecializationUncheckedCreateWithoutDoctorSpecializationInput>;
    connectOrCreate?: SpecializationCreateOrConnectWithoutDoctorSpecializationInput;
    upsert?: SpecializationUpsertWithoutDoctorSpecializationInput;
    connect?: SpecializationWhereUniqueInput;
    update?: XOR<XOR<SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput, SpecializationUpdateWithoutDoctorSpecializationInput>, SpecializationUncheckedUpdateWithoutDoctorSpecializationInput>;
};
type SpecializationCreateNestedOneWithoutHospitalSpecializationInput = {
    create?: XOR<SpecializationCreateWithoutHospitalSpecializationInput, SpecializationUncheckedCreateWithoutHospitalSpecializationInput>;
    connectOrCreate?: SpecializationCreateOrConnectWithoutHospitalSpecializationInput;
    connect?: SpecializationWhereUniqueInput;
};
type SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput = {
    create?: XOR<SpecializationCreateWithoutHospitalSpecializationInput, SpecializationUncheckedCreateWithoutHospitalSpecializationInput>;
    connectOrCreate?: SpecializationCreateOrConnectWithoutHospitalSpecializationInput;
    upsert?: SpecializationUpsertWithoutHospitalSpecializationInput;
    connect?: SpecializationWhereUniqueInput;
    update?: XOR<XOR<SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput, SpecializationUpdateWithoutHospitalSpecializationInput>, SpecializationUncheckedUpdateWithoutHospitalSpecializationInput>;
};
type SpecializationCreateWithoutDoctorSpecializationInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    HospitalSpecialization?: HospitalSpecializationCreateNestedManyWithoutSpecializationInput;
};
type SpecializationUncheckedCreateWithoutDoctorSpecializationInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    HospitalSpecialization?: HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
};
type SpecializationCreateOrConnectWithoutDoctorSpecializationInput = {
    where: SpecializationWhereUniqueInput;
    create: XOR<SpecializationCreateWithoutDoctorSpecializationInput, SpecializationUncheckedCreateWithoutDoctorSpecializationInput>;
};
type SpecializationUpsertWithoutDoctorSpecializationInput = {
    update: XOR<SpecializationUpdateWithoutDoctorSpecializationInput, SpecializationUncheckedUpdateWithoutDoctorSpecializationInput>;
    create: XOR<SpecializationCreateWithoutDoctorSpecializationInput, SpecializationUncheckedCreateWithoutDoctorSpecializationInput>;
    where?: SpecializationWhereInput;
};
type SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput = {
    where?: SpecializationWhereInput;
    data: XOR<SpecializationUpdateWithoutDoctorSpecializationInput, SpecializationUncheckedUpdateWithoutDoctorSpecializationInput>;
};
type SpecializationUpdateWithoutDoctorSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    HospitalSpecialization?: HospitalSpecializationUpdateManyWithoutSpecializationNestedInput;
};
type SpecializationUncheckedUpdateWithoutDoctorSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    HospitalSpecialization?: HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
};
type SpecializationCreateWithoutHospitalSpecializationInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    DoctorSpecialization?: DoctorSpecializationCreateNestedManyWithoutSpecializationInput;
};
type SpecializationUncheckedCreateWithoutHospitalSpecializationInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    description: string;
    imageURL?: string | null;
    slug?: string | null;
    updatedAt?: Date | string;
    DoctorSpecialization?: DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
};
type SpecializationCreateOrConnectWithoutHospitalSpecializationInput = {
    where: SpecializationWhereUniqueInput;
    create: XOR<SpecializationCreateWithoutHospitalSpecializationInput, SpecializationUncheckedCreateWithoutHospitalSpecializationInput>;
};
type SpecializationUpsertWithoutHospitalSpecializationInput = {
    update: XOR<SpecializationUpdateWithoutHospitalSpecializationInput, SpecializationUncheckedUpdateWithoutHospitalSpecializationInput>;
    create: XOR<SpecializationCreateWithoutHospitalSpecializationInput, SpecializationUncheckedCreateWithoutHospitalSpecializationInput>;
    where?: SpecializationWhereInput;
};
type SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput = {
    where?: SpecializationWhereInput;
    data: XOR<SpecializationUpdateWithoutHospitalSpecializationInput, SpecializationUncheckedUpdateWithoutHospitalSpecializationInput>;
};
type SpecializationUpdateWithoutHospitalSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    DoctorSpecialization?: DoctorSpecializationUpdateManyWithoutSpecializationNestedInput;
};
type SpecializationUncheckedUpdateWithoutHospitalSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    description?: StringFieldUpdateOperationsInput | string;
    imageURL?: NullableStringFieldUpdateOperationsInput | string | null;
    slug?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    DoctorSpecialization?: DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
};
/**
 * Count Type SpecializationCountOutputType
 */
type SpecializationCountOutputType = {
    DoctorSpecialization: number;
    HospitalSpecialization: number;
};
type SpecializationCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    DoctorSpecialization?: boolean | SpecializationCountOutputTypeCountDoctorSpecializationArgs;
    HospitalSpecialization?: boolean | SpecializationCountOutputTypeCountHospitalSpecializationArgs;
};
/**
 * SpecializationCountOutputType without action
 */
type SpecializationCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecializationCountOutputType
     */
    select?: SpecializationCountOutputTypeSelect<ExtArgs> | null;
};
/**
 * SpecializationCountOutputType without action
 */
type SpecializationCountOutputTypeCountDoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorSpecializationWhereInput;
};
/**
 * SpecializationCountOutputType without action
 */
type SpecializationCountOutputTypeCountHospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: HospitalSpecializationWhereInput;
};
type SpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    description?: boolean;
    imageURL?: boolean;
    slug?: boolean;
    updatedAt?: boolean;
    DoctorSpecialization?: boolean | Specialization$DoctorSpecializationArgs<ExtArgs>;
    HospitalSpecialization?: boolean | Specialization$HospitalSpecializationArgs<ExtArgs>;
    _count?: boolean | SpecializationCountOutputTypeDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["specialization"]>;
type SpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    description?: boolean;
    imageURL?: boolean;
    slug?: boolean;
    updatedAt?: boolean;
}, ExtArgs["result"]["specialization"]>;
type SpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    description?: boolean;
    imageURL?: boolean;
    slug?: boolean;
    updatedAt?: boolean;
}, ExtArgs["result"]["specialization"]>;
type SpecializationSelectScalar = {
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    description?: boolean;
    imageURL?: boolean;
    slug?: boolean;
    updatedAt?: boolean;
};
type SpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "name" | "createdAt" | "description" | "imageURL" | "slug" | "updatedAt", ExtArgs["result"]["specialization"]>;
type SpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    DoctorSpecialization?: boolean | Specialization$DoctorSpecializationArgs<ExtArgs>;
    HospitalSpecialization?: boolean | Specialization$HospitalSpecializationArgs<ExtArgs>;
    _count?: boolean | SpecializationCountOutputTypeDefaultArgs<ExtArgs>;
};
type SpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {};
type SpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {};
type $SpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "Specialization";
    objects: {
        DoctorSpecialization: $DoctorSpecializationPayload<ExtArgs>[];
        HospitalSpecialization: $HospitalSpecializationPayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        name: string;
        createdAt: Date;
        description: string;
        imageURL: string | null;
        slug: string | null;
        updatedAt: Date;
    }, ExtArgs["result"]["specialization"]>;
    composites: {};
};
type SpecializationGetPayload<S extends boolean | null | undefined | SpecializationDefaultArgs> = runtime.Types.Result.GetResult<$SpecializationPayload, S>;
type SpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<SpecializationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SpecializationCountAggregateInputType | true;
};
interface SpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['Specialization'];
        meta: {
            name: 'Specialization';
        };
    };
    /**
     * Find zero or one Specialization that matches the filter.
     * @param {SpecializationFindUniqueArgs} args - Arguments to find a Specialization
     * @example
     * // Get one Specialization
     * const specialization = await prisma.specialization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecializationFindUniqueArgs>(args: SelectSubset<T, SpecializationFindUniqueArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Specialization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecializationFindUniqueOrThrowArgs} args - Arguments to find a Specialization
     * @example
     * // Get one Specialization
     * const specialization = await prisma.specialization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecializationFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecializationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Specialization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationFindFirstArgs} args - Arguments to find a Specialization
     * @example
     * // Get one Specialization
     * const specialization = await prisma.specialization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecializationFindFirstArgs>(args?: SelectSubset<T, SpecializationFindFirstArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Specialization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationFindFirstOrThrowArgs} args - Arguments to find a Specialization
     * @example
     * // Get one Specialization
     * const specialization = await prisma.specialization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecializationFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecializationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Specializations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specializations
     * const specializations = await prisma.specialization.findMany()
     *
     * // Get first 10 Specializations
     * const specializations = await prisma.specialization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const specializationWithIdOnly = await prisma.specialization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SpecializationFindManyArgs>(args?: SelectSubset<T, SpecializationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Specialization.
     * @param {SpecializationCreateArgs} args - Arguments to create a Specialization.
     * @example
     * // Create one Specialization
     * const Specialization = await prisma.specialization.create({
     *   data: {
     *     // ... data to create a Specialization
     *   }
     * })
     *
     */
    create<T extends SpecializationCreateArgs>(args: SelectSubset<T, SpecializationCreateArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Specializations.
     * @param {SpecializationCreateManyArgs} args - Arguments to create many Specializations.
     * @example
     * // Create many Specializations
     * const specialization = await prisma.specialization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SpecializationCreateManyArgs>(args?: SelectSubset<T, SpecializationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Specializations and returns the data saved in the database.
     * @param {SpecializationCreateManyAndReturnArgs} args - Arguments to create many Specializations.
     * @example
     * // Create many Specializations
     * const specialization = await prisma.specialization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Specializations and only return the `id`
     * const specializationWithIdOnly = await prisma.specialization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SpecializationCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecializationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Specialization.
     * @param {SpecializationDeleteArgs} args - Arguments to delete one Specialization.
     * @example
     * // Delete one Specialization
     * const Specialization = await prisma.specialization.delete({
     *   where: {
     *     // ... filter to delete one Specialization
     *   }
     * })
     *
     */
    delete<T extends SpecializationDeleteArgs>(args: SelectSubset<T, SpecializationDeleteArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Specialization.
     * @param {SpecializationUpdateArgs} args - Arguments to update one Specialization.
     * @example
     * // Update one Specialization
     * const specialization = await prisma.specialization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SpecializationUpdateArgs>(args: SelectSubset<T, SpecializationUpdateArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Specializations.
     * @param {SpecializationDeleteManyArgs} args - Arguments to filter Specializations to delete.
     * @example
     * // Delete a few Specializations
     * const { count } = await prisma.specialization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SpecializationDeleteManyArgs>(args?: SelectSubset<T, SpecializationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Specializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specializations
     * const specialization = await prisma.specialization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SpecializationUpdateManyArgs>(args: SelectSubset<T, SpecializationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Specializations and returns the data updated in the database.
     * @param {SpecializationUpdateManyAndReturnArgs} args - Arguments to update many Specializations.
     * @example
     * // Update many Specializations
     * const specialization = await prisma.specialization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Specializations and only return the `id`
     * const specializationWithIdOnly = await prisma.specialization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SpecializationUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecializationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Specialization.
     * @param {SpecializationUpsertArgs} args - Arguments to update or create a Specialization.
     * @example
     * // Update or create a Specialization
     * const specialization = await prisma.specialization.upsert({
     *   create: {
     *     // ... data to create a Specialization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialization we want to update
     *   }
     * })
     */
    upsert<T extends SpecializationUpsertArgs>(args: SelectSubset<T, SpecializationUpsertArgs<ExtArgs>>): Prisma__SpecializationClient<runtime.Types.Result.GetResult<$SpecializationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Specializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationCountArgs} args - Arguments to filter Specializations to count.
     * @example
     * // Count the number of Specializations
     * const count = await prisma.specialization.count({
     *   where: {
     *     // ... the filter for the Specializations we want to count
     *   }
     * })
    **/
    count<T extends SpecializationCountArgs>(args?: Subset<T, SpecializationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], SpecializationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Specialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecializationAggregateArgs>(args: Subset<T, SpecializationAggregateArgs>): PrismaPromise<GetSpecializationAggregateType<T>>;
    /**
     * Group by Specialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecializationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends SpecializationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: SpecializationGroupByArgs['orderBy'];
    } : {
        orderBy?: SpecializationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, SpecializationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecializationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the Specialization model
     */
    readonly fields: SpecializationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for Specialization.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__SpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    DoctorSpecialization<T extends Specialization$DoctorSpecializationArgs<ExtArgs> = {}>(args?: Subset<T, Specialization$DoctorSpecializationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    HospitalSpecialization<T extends Specialization$HospitalSpecializationArgs<ExtArgs> = {}>(args?: Subset<T, Specialization$HospitalSpecializationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$HospitalSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the Specialization model
 */
interface SpecializationFieldRefs {
    readonly id: FieldRef<"Specialization", 'String'>;
    readonly name: FieldRef<"Specialization", 'String'>;
    readonly createdAt: FieldRef<"Specialization", 'DateTime'>;
    readonly description: FieldRef<"Specialization", 'String'>;
    readonly imageURL: FieldRef<"Specialization", 'String'>;
    readonly slug: FieldRef<"Specialization", 'String'>;
    readonly updatedAt: FieldRef<"Specialization", 'DateTime'>;
}
/**
 * Specialization findUnique
 */
type SpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which Specialization to fetch.
     */
    where: SpecializationWhereUniqueInput;
};
/**
 * Specialization findUniqueOrThrow
 */
type SpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which Specialization to fetch.
     */
    where: SpecializationWhereUniqueInput;
};
/**
 * Specialization findFirst
 */
type SpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which Specialization to fetch.
     */
    where?: SpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Specializations to fetch.
     */
    orderBy?: SpecializationOrderByWithRelationInput | SpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Specializations.
     */
    cursor?: SpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Specializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Specializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Specializations.
     */
    distinct?: SpecializationScalarFieldEnum | SpecializationScalarFieldEnum[];
};
/**
 * Specialization findFirstOrThrow
 */
type SpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which Specialization to fetch.
     */
    where?: SpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Specializations to fetch.
     */
    orderBy?: SpecializationOrderByWithRelationInput | SpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Specializations.
     */
    cursor?: SpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Specializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Specializations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Specializations.
     */
    distinct?: SpecializationScalarFieldEnum | SpecializationScalarFieldEnum[];
};
/**
 * Specialization findMany
 */
type SpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter, which Specializations to fetch.
     */
    where?: SpecializationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Specializations to fetch.
     */
    orderBy?: SpecializationOrderByWithRelationInput | SpecializationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Specializations.
     */
    cursor?: SpecializationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Specializations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Specializations.
     */
    skip?: number;
    distinct?: SpecializationScalarFieldEnum | SpecializationScalarFieldEnum[];
};
/**
 * Specialization create
 */
type SpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Specialization.
     */
    data: XOR<SpecializationCreateInput, SpecializationUncheckedCreateInput>;
};
/**
 * Specialization createMany
 */
type SpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specializations.
     */
    data: SpecializationCreateManyInput | SpecializationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Specialization createManyAndReturn
 */
type SpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * The data used to create many Specializations.
     */
    data: SpecializationCreateManyInput | SpecializationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * Specialization update
 */
type SpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Specialization.
     */
    data: XOR<SpecializationUpdateInput, SpecializationUncheckedUpdateInput>;
    /**
     * Choose, which Specialization to update.
     */
    where: SpecializationWhereUniqueInput;
};
/**
 * Specialization updateMany
 */
type SpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Specializations.
     */
    data: XOR<SpecializationUpdateManyMutationInput, SpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which Specializations to update
     */
    where?: SpecializationWhereInput;
    /**
     * Limit how many Specializations to update.
     */
    limit?: number;
};
/**
 * Specialization updateManyAndReturn
 */
type SpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * The data used to update Specializations.
     */
    data: XOR<SpecializationUpdateManyMutationInput, SpecializationUncheckedUpdateManyInput>;
    /**
     * Filter which Specializations to update
     */
    where?: SpecializationWhereInput;
    /**
     * Limit how many Specializations to update.
     */
    limit?: number;
};
/**
 * Specialization upsert
 */
type SpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Specialization to update in case it exists.
     */
    where: SpecializationWhereUniqueInput;
    /**
     * In case the Specialization found by the `where` argument doesn't exist, create a new Specialization with this data.
     */
    create: XOR<SpecializationCreateInput, SpecializationUncheckedCreateInput>;
    /**
     * In case the Specialization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecializationUpdateInput, SpecializationUncheckedUpdateInput>;
};
/**
 * Specialization delete
 */
type SpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
    /**
     * Filter which Specialization to delete.
     */
    where: SpecializationWhereUniqueInput;
};
/**
 * Specialization deleteMany
 */
type SpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Specializations to delete
     */
    where?: SpecializationWhereInput;
    /**
     * Limit how many Specializations to delete.
     */
    limit?: number;
};
/**
 * Specialization.DoctorSpecialization
 */
type Specialization$DoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSpecialization
     */
    select?: DoctorSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorSpecialization
     */
    omit?: DoctorSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorSpecializationInclude<ExtArgs> | null;
    where?: DoctorSpecializationWhereInput;
    orderBy?: DoctorSpecializationOrderByWithRelationInput | DoctorSpecializationOrderByWithRelationInput[];
    cursor?: DoctorSpecializationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorSpecializationScalarFieldEnum | DoctorSpecializationScalarFieldEnum[];
};
/**
 * Specialization.HospitalSpecialization
 */
type Specialization$HospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalSpecialization
     */
    select?: HospitalSpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the HospitalSpecialization
     */
    omit?: HospitalSpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalSpecializationInclude<ExtArgs> | null;
    where?: HospitalSpecializationWhereInput;
    orderBy?: HospitalSpecializationOrderByWithRelationInput | HospitalSpecializationOrderByWithRelationInput[];
    cursor?: HospitalSpecializationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: HospitalSpecializationScalarFieldEnum | HospitalSpecializationScalarFieldEnum[];
};
/**
 * Specialization without action
 */
type SpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialization
     */
    select?: SpecializationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Specialization
     */
    omit?: SpecializationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecializationInclude<ExtArgs> | null;
};

/**
 * Model User
 *
 */
type UserModel = runtime.Types.Result.DefaultSelection<$UserPayload>;
type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
};
type UserMinAggregateOutputType = {
    id: string | null;
    fullName: string | null;
    email: string | null;
    emailVerified: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    phoneNumber: string | null;
    phoneNumberVerified: boolean | null;
    gender: string | null;
    role: Role | null;
    dateOfBirth: string | null;
    imageUrl: string | null;
    imageId: string | null;
    banned: boolean | null;
    isOnboardingComplete: boolean | null;
};
type UserMaxAggregateOutputType = {
    id: string | null;
    fullName: string | null;
    email: string | null;
    emailVerified: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    phoneNumber: string | null;
    phoneNumberVerified: boolean | null;
    gender: string | null;
    role: Role | null;
    dateOfBirth: string | null;
    imageUrl: string | null;
    imageId: string | null;
    banned: boolean | null;
    isOnboardingComplete: boolean | null;
};
type UserCountAggregateOutputType = {
    id: number;
    fullName: number;
    email: number;
    emailVerified: number;
    createdAt: number;
    updatedAt: number;
    phoneNumber: number;
    phoneNumberVerified: number;
    gender: number;
    role: number;
    dateOfBirth: number;
    imageUrl: number;
    imageId: number;
    banned: number;
    isOnboardingComplete: number;
    _all: number;
};
type UserMinAggregateInputType = {
    id?: true;
    fullName?: true;
    email?: true;
    emailVerified?: true;
    createdAt?: true;
    updatedAt?: true;
    phoneNumber?: true;
    phoneNumberVerified?: true;
    gender?: true;
    role?: true;
    dateOfBirth?: true;
    imageUrl?: true;
    imageId?: true;
    banned?: true;
    isOnboardingComplete?: true;
};
type UserMaxAggregateInputType = {
    id?: true;
    fullName?: true;
    email?: true;
    emailVerified?: true;
    createdAt?: true;
    updatedAt?: true;
    phoneNumber?: true;
    phoneNumberVerified?: true;
    gender?: true;
    role?: true;
    dateOfBirth?: true;
    imageUrl?: true;
    imageId?: true;
    banned?: true;
    isOnboardingComplete?: true;
};
type UserCountAggregateInputType = {
    id?: true;
    fullName?: true;
    email?: true;
    emailVerified?: true;
    createdAt?: true;
    updatedAt?: true;
    phoneNumber?: true;
    phoneNumberVerified?: true;
    gender?: true;
    role?: true;
    dateOfBirth?: true;
    imageUrl?: true;
    imageId?: true;
    banned?: true;
    isOnboardingComplete?: true;
    _all?: true;
};
type UserAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType;
};
type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateUser[P]> : GetScalarType<T[P], AggregateUser[P]>;
};
type UserGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: UserWhereInput;
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
};
type UserGroupByOutputType = {
    id: string;
    fullName: string;
    email: string | null;
    emailVerified: boolean;
    createdAt: Date;
    updatedAt: Date;
    phoneNumber: string | null;
    phoneNumberVerified: boolean | null;
    gender: string | null;
    role: Role | null;
    dateOfBirth: string | null;
    imageUrl: string | null;
    imageId: string | null;
    banned: boolean;
    isOnboardingComplete: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
};
type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<Array<PickEnumerable<UserGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], UserGroupByOutputType[P]> : GetScalarType<T[P], UserGroupByOutputType[P]>;
}>>;
type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    fullName?: StringFilter<"User"> | string;
    email?: StringNullableFilter<"User"> | string | null;
    emailVerified?: BoolFilter<"User"> | boolean;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    phoneNumber?: StringNullableFilter<"User"> | string | null;
    phoneNumberVerified?: BoolNullableFilter<"User"> | boolean | null;
    gender?: StringNullableFilter<"User"> | string | null;
    role?: EnumRoleNullableFilter<"User"> | Role | null;
    dateOfBirth?: StringNullableFilter<"User"> | string | null;
    imageUrl?: StringNullableFilter<"User"> | string | null;
    imageId?: StringNullableFilter<"User"> | string | null;
    banned?: BoolFilter<"User"> | boolean;
    isOnboardingComplete?: BoolFilter<"User"> | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentListRelationFilter;
    Appointment_Appointment_customerIdToUser?: AppointmentListRelationFilter;
    AuditLog?: AuditLogListRelationFilter;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    DoctorApplication?: DoctorApplicationListRelationFilter;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
    Notification?: NotificationListRelationFilter;
    Payment?: PaymentListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
    SearchLog?: SearchLogListRelationFilter;
    account?: AccountListRelationFilter;
    session?: SessionListRelationFilter;
};
type UserOrderByWithRelationInput = {
    id?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    phoneNumberVerified?: SortOrderInput | SortOrder;
    gender?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    dateOfBirth?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    imageId?: SortOrderInput | SortOrder;
    banned?: SortOrder;
    isOnboardingComplete?: SortOrder;
    Appointment_Appointment_approvedByToUser?: AppointmentOrderByRelationAggregateInput;
    Appointment_Appointment_customerIdToUser?: AppointmentOrderByRelationAggregateInput;
    AuditLog?: AuditLogOrderByRelationAggregateInput;
    Doctor?: DoctorOrderByWithRelationInput;
    DoctorApplication?: DoctorApplicationOrderByRelationAggregateInput;
    Hospital?: HospitalOrderByWithRelationInput;
    Notification?: NotificationOrderByRelationAggregateInput;
    Payment?: PaymentOrderByRelationAggregateInput;
    Review?: ReviewOrderByRelationAggregateInput;
    SavedDoctorHospital?: SavedDoctorHospitalOrderByRelationAggregateInput;
    Schedule?: ScheduleOrderByRelationAggregateInput;
    SearchLog?: SearchLogOrderByRelationAggregateInput;
    account?: accountOrderByRelationAggregateInput;
    session?: sessionOrderByRelationAggregateInput;
};
type UserWhereUniqueInput = AtLeast<{
    id?: string;
    phoneNumber?: string;
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    fullName?: StringFilter<"User"> | string;
    email?: StringNullableFilter<"User"> | string | null;
    emailVerified?: BoolFilter<"User"> | boolean;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    phoneNumberVerified?: BoolNullableFilter<"User"> | boolean | null;
    gender?: StringNullableFilter<"User"> | string | null;
    role?: EnumRoleNullableFilter<"User"> | Role | null;
    dateOfBirth?: StringNullableFilter<"User"> | string | null;
    imageUrl?: StringNullableFilter<"User"> | string | null;
    imageId?: StringNullableFilter<"User"> | string | null;
    banned?: BoolFilter<"User"> | boolean;
    isOnboardingComplete?: BoolFilter<"User"> | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentListRelationFilter;
    Appointment_Appointment_customerIdToUser?: AppointmentListRelationFilter;
    AuditLog?: AuditLogListRelationFilter;
    Doctor?: XOR<DoctorNullableScalarRelationFilter, DoctorWhereInput> | null;
    DoctorApplication?: DoctorApplicationListRelationFilter;
    Hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null;
    Notification?: NotificationListRelationFilter;
    Payment?: PaymentListRelationFilter;
    Review?: ReviewListRelationFilter;
    SavedDoctorHospital?: SavedDoctorHospitalListRelationFilter;
    Schedule?: ScheduleListRelationFilter;
    SearchLog?: SearchLogListRelationFilter;
    account?: AccountListRelationFilter;
    session?: SessionListRelationFilter;
}, "id" | "phoneNumber">;
type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    phoneNumber?: SortOrderInput | SortOrder;
    phoneNumberVerified?: SortOrderInput | SortOrder;
    gender?: SortOrderInput | SortOrder;
    role?: SortOrderInput | SortOrder;
    dateOfBirth?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    imageId?: SortOrderInput | SortOrder;
    banned?: SortOrder;
    isOnboardingComplete?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
};
type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    fullName?: StringWithAggregatesFilter<"User"> | string;
    email?: StringNullableWithAggregatesFilter<"User"> | string | null;
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null;
    phoneNumberVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null;
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null;
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | Role | null;
    dateOfBirth?: StringNullableWithAggregatesFilter<"User"> | string | null;
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null;
    imageId?: StringNullableWithAggregatesFilter<"User"> | string | null;
    banned?: BoolWithAggregatesFilter<"User"> | boolean;
    isOnboardingComplete?: BoolWithAggregatesFilter<"User"> | boolean;
};
type UserCreateInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateManyInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
};
type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
};
type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
};
type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
};
type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
};
type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    phoneNumber?: SortOrder;
    phoneNumberVerified?: SortOrder;
    gender?: SortOrder;
    role?: SortOrder;
    dateOfBirth?: SortOrder;
    imageUrl?: SortOrder;
    imageId?: SortOrder;
    banned?: SortOrder;
    isOnboardingComplete?: SortOrder;
};
type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    phoneNumber?: SortOrder;
    phoneNumberVerified?: SortOrder;
    gender?: SortOrder;
    role?: SortOrder;
    dateOfBirth?: SortOrder;
    imageUrl?: SortOrder;
    imageId?: SortOrder;
    banned?: SortOrder;
    isOnboardingComplete?: SortOrder;
};
type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    phoneNumber?: SortOrder;
    phoneNumberVerified?: SortOrder;
    gender?: SortOrder;
    role?: SortOrder;
    dateOfBirth?: SortOrder;
    imageUrl?: SortOrder;
    imageId?: SortOrder;
    banned?: SortOrder;
    isOnboardingComplete?: SortOrder;
};
type UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput = {
    create?: XOR<UserCreateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput;
    connect?: UserWhereUniqueInput;
};
type UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput = {
    create?: XOR<UserCreateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput = {
    create?: XOR<UserCreateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput;
    upsert?: UserUpsertWithoutAppointment_Appointment_approvedByToUserInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput, UserUpdateWithoutAppointment_Appointment_approvedByToUserInput>, UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput>;
};
type UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput;
    upsert?: UserUpsertWithoutAppointment_Appointment_customerIdToUserInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput, UserUpdateWithoutAppointment_Appointment_customerIdToUserInput>, UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput>;
};
type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput;
    upsert?: UserUpsertWithoutAuditLogInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>;
};
type UserCreateNestedOneWithoutDoctorInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutDoctorNestedInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput;
    upsert?: UserUpsertWithoutDoctorInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorInput, UserUpdateWithoutDoctorInput>, UserUncheckedUpdateWithoutDoctorInput>;
};
type UserCreateNestedOneWithoutDoctorApplicationInput = {
    create?: XOR<UserCreateWithoutDoctorApplicationInput, UserUncheckedCreateWithoutDoctorApplicationInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDoctorApplicationInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutDoctorApplicationNestedInput = {
    create?: XOR<UserCreateWithoutDoctorApplicationInput, UserUncheckedCreateWithoutDoctorApplicationInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDoctorApplicationInput;
    upsert?: UserUpsertWithoutDoctorApplicationInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorApplicationInput, UserUpdateWithoutDoctorApplicationInput>, UserUncheckedUpdateWithoutDoctorApplicationInput>;
};
type UserCreateNestedOneWithoutHospitalInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>;
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutHospitalNestedInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>;
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput;
    upsert?: UserUpsertWithoutHospitalInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHospitalInput, UserUpdateWithoutHospitalInput>, UserUncheckedUpdateWithoutHospitalInput>;
};
type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput;
    upsert?: UserUpsertWithoutNotificationInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>;
};
type UserCreateNestedOneWithoutPaymentInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput;
    upsert?: UserUpsertWithoutPaymentInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentInput, UserUpdateWithoutPaymentInput>, UserUncheckedUpdateWithoutPaymentInput>;
};
type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput;
    upsert?: UserUpsertWithoutReviewInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>;
};
type UserCreateNestedOneWithoutSavedDoctorHospitalInput = {
    create?: XOR<UserCreateWithoutSavedDoctorHospitalInput, UserUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSavedDoctorHospitalInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput = {
    create?: XOR<UserCreateWithoutSavedDoctorHospitalInput, UserUncheckedCreateWithoutSavedDoctorHospitalInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSavedDoctorHospitalInput;
    upsert?: UserUpsertWithoutSavedDoctorHospitalInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, UserUpdateWithoutSavedDoctorHospitalInput>, UserUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type UserCreateNestedOneWithoutScheduleInput = {
    create?: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: UserCreateOrConnectWithoutScheduleInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>;
    connectOrCreate?: UserCreateOrConnectWithoutScheduleInput;
    upsert?: UserUpsertWithoutScheduleInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduleInput, UserUpdateWithoutScheduleInput>, UserUncheckedUpdateWithoutScheduleInput>;
};
type UserCreateNestedOneWithoutSearchLogInput = {
    create?: XOR<UserCreateWithoutSearchLogInput, UserUncheckedCreateWithoutSearchLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSearchLogInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutSearchLogNestedInput = {
    create?: XOR<UserCreateWithoutSearchLogInput, UserUncheckedCreateWithoutSearchLogInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSearchLogInput;
    upsert?: UserUpsertWithoutSearchLogInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchLogInput, UserUpdateWithoutSearchLogInput>, UserUncheckedUpdateWithoutSearchLogInput>;
};
type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null;
};
type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: Role | null;
};
type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput;
    upsert?: UserUpsertWithoutAccountInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>;
};
type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput;
    connect?: UserWhereUniqueInput;
};
type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput;
    upsert?: UserUpsertWithoutSessionInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>;
};
type UserCreateWithoutAppointment_Appointment_approvedByToUserInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput>;
};
type UserCreateWithoutAppointment_Appointment_customerIdToUserInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput>;
};
type UserUpsertWithoutAppointment_Appointment_approvedByToUserInput = {
    update: XOR<UserUpdateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput>;
    create: XOR<UserCreateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAppointment_Appointment_approvedByToUserInput, UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput>;
};
type UserUpdateWithoutAppointment_Appointment_approvedByToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserUpsertWithoutAppointment_Appointment_customerIdToUserInput = {
    update: XOR<UserUpdateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput>;
    create: XOR<UserCreateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAppointment_Appointment_customerIdToUserInput, UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput>;
};
type UserUpdateWithoutAppointment_Appointment_customerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutAuditLogInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutAuditLogInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
};
type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>;
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>;
};
type UserUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutDoctorInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutDoctorInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutDoctorInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>;
};
type UserUpsertWithoutDoctorInput = {
    update: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>;
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutDoctorInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>;
};
type UserUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutDoctorApplicationInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutDoctorApplicationInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutDoctorApplicationInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutDoctorApplicationInput, UserUncheckedCreateWithoutDoctorApplicationInput>;
};
type UserUpsertWithoutDoctorApplicationInput = {
    update: XOR<UserUpdateWithoutDoctorApplicationInput, UserUncheckedUpdateWithoutDoctorApplicationInput>;
    create: XOR<UserCreateWithoutDoctorApplicationInput, UserUncheckedCreateWithoutDoctorApplicationInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutDoctorApplicationInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutDoctorApplicationInput, UserUncheckedUpdateWithoutDoctorApplicationInput>;
};
type UserUpdateWithoutDoctorApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutDoctorApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutHospitalInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutHospitalInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutHospitalInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>;
};
type UserUpsertWithoutHospitalInput = {
    update: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>;
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutHospitalInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>;
};
type UserUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutNotificationInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutNotificationInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>;
};
type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>;
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>;
};
type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutPaymentInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutPaymentInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutPaymentInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>;
};
type UserUpsertWithoutPaymentInput = {
    update: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>;
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>;
};
type UserUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutReviewInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutReviewInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>;
};
type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>;
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>;
};
type UserUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutSavedDoctorHospitalInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutSavedDoctorHospitalInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSavedDoctorHospitalInput, UserUncheckedCreateWithoutSavedDoctorHospitalInput>;
};
type UserUpsertWithoutSavedDoctorHospitalInput = {
    update: XOR<UserUpdateWithoutSavedDoctorHospitalInput, UserUncheckedUpdateWithoutSavedDoctorHospitalInput>;
    create: XOR<UserCreateWithoutSavedDoctorHospitalInput, UserUncheckedCreateWithoutSavedDoctorHospitalInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSavedDoctorHospitalInput, UserUncheckedUpdateWithoutSavedDoctorHospitalInput>;
};
type UserUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutSavedDoctorHospitalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutScheduleInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutScheduleInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutScheduleInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>;
};
type UserUpsertWithoutScheduleInput = {
    update: XOR<UserUpdateWithoutScheduleInput, UserUncheckedUpdateWithoutScheduleInput>;
    create: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutScheduleInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutScheduleInput, UserUncheckedUpdateWithoutScheduleInput>;
};
type UserUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutSearchLogInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutSearchLogInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutSearchLogInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSearchLogInput, UserUncheckedCreateWithoutSearchLogInput>;
};
type UserUpsertWithoutSearchLogInput = {
    update: XOR<UserUpdateWithoutSearchLogInput, UserUncheckedUpdateWithoutSearchLogInput>;
    create: XOR<UserCreateWithoutSearchLogInput, UserUncheckedCreateWithoutSearchLogInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutSearchLogInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSearchLogInput, UserUncheckedUpdateWithoutSearchLogInput>;
};
type UserUpdateWithoutSearchLogInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutSearchLogInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutAccountInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    session?: sessionCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutAccountInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    session?: sessionUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>;
};
type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>;
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>;
};
type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    session?: sessionUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput;
};
type UserCreateWithoutSessionInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput;
    Doctor?: DoctorCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationCreateNestedManyWithoutUserInput;
    Hospital?: HospitalCreateNestedOneWithoutUserInput;
    Notification?: NotificationCreateNestedManyWithoutUserInput;
    Payment?: PaymentCreateNestedManyWithoutUserInput;
    Review?: ReviewCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogCreateNestedManyWithoutUserInput;
    account?: accountCreateNestedManyWithoutUserInput;
};
type UserUncheckedCreateWithoutSessionInput = {
    id?: string;
    fullName: string;
    email?: string | null;
    emailVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    phoneNumber?: string | null;
    phoneNumberVerified?: boolean | null;
    gender?: string | null;
    role?: Role | null;
    dateOfBirth?: string | null;
    imageUrl?: string | null;
    imageId?: string | null;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    Doctor?: DoctorUncheckedCreateNestedOneWithoutUserInput;
    DoctorApplication?: DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
    Hospital?: HospitalUncheckedCreateNestedOneWithoutUserInput;
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput;
    SearchLog?: SearchLogUncheckedCreateNestedManyWithoutUserInput;
    account?: accountUncheckedCreateNestedManyWithoutUserInput;
};
type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>;
};
type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>;
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>;
    where?: UserWhereInput;
};
type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>;
};
type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUpdateManyWithoutUserNestedInput;
    Review?: ReviewUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUpdateManyWithoutUserNestedInput;
    account?: accountUpdateManyWithoutUserNestedInput;
};
type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    phoneNumberVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: NullableEnumRoleFieldUpdateOperationsInput | Role | null;
    dateOfBirth?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    imageId?: NullableStringFieldUpdateOperationsInput | string | null;
    banned?: BoolFieldUpdateOperationsInput | boolean;
    isOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean;
    Appointment_Appointment_approvedByToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
    Appointment_Appointment_customerIdToUser?: AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    Doctor?: DoctorUncheckedUpdateOneWithoutUserNestedInput;
    DoctorApplication?: DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
    Hospital?: HospitalUncheckedUpdateOneWithoutUserNestedInput;
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
    SavedDoctorHospital?: SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput;
    SearchLog?: SearchLogUncheckedUpdateManyWithoutUserNestedInput;
    account?: accountUncheckedUpdateManyWithoutUserNestedInput;
};
/**
 * Count Type UserCountOutputType
 */
type UserCountOutputType = {
    Appointment_Appointment_approvedByToUser: number;
    Appointment_Appointment_customerIdToUser: number;
    AuditLog: number;
    DoctorApplication: number;
    Notification: number;
    Payment: number;
    Review: number;
    SavedDoctorHospital: number;
    Schedule: number;
    SearchLog: number;
    account: number;
    session: number;
};
type UserCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment_Appointment_approvedByToUser?: boolean | UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs;
    Appointment_Appointment_customerIdToUser?: boolean | UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs;
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs;
    DoctorApplication?: boolean | UserCountOutputTypeCountDoctorApplicationArgs;
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs;
    Payment?: boolean | UserCountOutputTypeCountPaymentArgs;
    Review?: boolean | UserCountOutputTypeCountReviewArgs;
    SavedDoctorHospital?: boolean | UserCountOutputTypeCountSavedDoctorHospitalArgs;
    Schedule?: boolean | UserCountOutputTypeCountScheduleArgs;
    SearchLog?: boolean | UserCountOutputTypeCountSearchLogArgs;
    account?: boolean | UserCountOutputTypeCountAccountArgs;
    session?: boolean | UserCountOutputTypeCountSessionArgs;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountDoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: DoctorApplicationWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountNotificationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: NotificationWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountPaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: PaymentWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ReviewWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SavedDoctorHospitalWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountSearchLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: SearchLogWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountAccountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: accountWhereInput;
};
/**
 * UserCountOutputType without action
 */
type UserCountOutputTypeCountSessionArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: sessionWhereInput;
};
type UserSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    fullName?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    phoneNumber?: boolean;
    phoneNumberVerified?: boolean;
    gender?: boolean;
    role?: boolean;
    dateOfBirth?: boolean;
    imageUrl?: boolean;
    imageId?: boolean;
    banned?: boolean;
    isOnboardingComplete?: boolean;
    Appointment_Appointment_approvedByToUser?: boolean | User$Appointment_Appointment_approvedByToUserArgs<ExtArgs>;
    Appointment_Appointment_customerIdToUser?: boolean | User$Appointment_Appointment_customerIdToUserArgs<ExtArgs>;
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>;
    Doctor?: boolean | User$DoctorArgs<ExtArgs>;
    DoctorApplication?: boolean | User$DoctorApplicationArgs<ExtArgs>;
    Hospital?: boolean | User$HospitalArgs<ExtArgs>;
    Notification?: boolean | User$NotificationArgs<ExtArgs>;
    Payment?: boolean | User$PaymentArgs<ExtArgs>;
    Review?: boolean | User$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | User$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | User$ScheduleArgs<ExtArgs>;
    SearchLog?: boolean | User$SearchLogArgs<ExtArgs>;
    account?: boolean | User$accountArgs<ExtArgs>;
    session?: boolean | User$sessionArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["user"]>;
type UserSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    fullName?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    phoneNumber?: boolean;
    phoneNumberVerified?: boolean;
    gender?: boolean;
    role?: boolean;
    dateOfBirth?: boolean;
    imageUrl?: boolean;
    imageId?: boolean;
    banned?: boolean;
    isOnboardingComplete?: boolean;
}, ExtArgs["result"]["user"]>;
type UserSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    fullName?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    phoneNumber?: boolean;
    phoneNumberVerified?: boolean;
    gender?: boolean;
    role?: boolean;
    dateOfBirth?: boolean;
    imageUrl?: boolean;
    imageId?: boolean;
    banned?: boolean;
    isOnboardingComplete?: boolean;
}, ExtArgs["result"]["user"]>;
type UserSelectScalar = {
    id?: boolean;
    fullName?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    phoneNumber?: boolean;
    phoneNumberVerified?: boolean;
    gender?: boolean;
    role?: boolean;
    dateOfBirth?: boolean;
    imageUrl?: boolean;
    imageId?: boolean;
    banned?: boolean;
    isOnboardingComplete?: boolean;
};
type UserOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "fullName" | "email" | "emailVerified" | "createdAt" | "updatedAt" | "phoneNumber" | "phoneNumberVerified" | "gender" | "role" | "dateOfBirth" | "imageUrl" | "imageId" | "banned" | "isOnboardingComplete", ExtArgs["result"]["user"]>;
type UserInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    Appointment_Appointment_approvedByToUser?: boolean | User$Appointment_Appointment_approvedByToUserArgs<ExtArgs>;
    Appointment_Appointment_customerIdToUser?: boolean | User$Appointment_Appointment_customerIdToUserArgs<ExtArgs>;
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>;
    Doctor?: boolean | User$DoctorArgs<ExtArgs>;
    DoctorApplication?: boolean | User$DoctorApplicationArgs<ExtArgs>;
    Hospital?: boolean | User$HospitalArgs<ExtArgs>;
    Notification?: boolean | User$NotificationArgs<ExtArgs>;
    Payment?: boolean | User$PaymentArgs<ExtArgs>;
    Review?: boolean | User$ReviewArgs<ExtArgs>;
    SavedDoctorHospital?: boolean | User$SavedDoctorHospitalArgs<ExtArgs>;
    Schedule?: boolean | User$ScheduleArgs<ExtArgs>;
    SearchLog?: boolean | User$SearchLogArgs<ExtArgs>;
    account?: boolean | User$accountArgs<ExtArgs>;
    session?: boolean | User$sessionArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
};
type UserIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {};
type UserIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {};
type $UserPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "User";
    objects: {
        Appointment_Appointment_approvedByToUser: $AppointmentPayload<ExtArgs>[];
        Appointment_Appointment_customerIdToUser: $AppointmentPayload<ExtArgs>[];
        AuditLog: $AuditLogPayload<ExtArgs>[];
        Doctor: $DoctorPayload<ExtArgs> | null;
        DoctorApplication: $DoctorApplicationPayload<ExtArgs>[];
        Hospital: $HospitalPayload<ExtArgs> | null;
        Notification: $NotificationPayload<ExtArgs>[];
        Payment: $PaymentPayload<ExtArgs>[];
        Review: $ReviewPayload<ExtArgs>[];
        SavedDoctorHospital: $SavedDoctorHospitalPayload<ExtArgs>[];
        Schedule: $SchedulePayload<ExtArgs>[];
        SearchLog: $SearchLogPayload<ExtArgs>[];
        account: $accountPayload<ExtArgs>[];
        session: $sessionPayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        fullName: string;
        email: string | null;
        emailVerified: boolean;
        createdAt: Date;
        updatedAt: Date;
        phoneNumber: string | null;
        phoneNumberVerified: boolean | null;
        gender: string | null;
        role: Role | null;
        dateOfBirth: string | null;
        imageUrl: string | null;
        imageId: string | null;
        banned: boolean;
        isOnboardingComplete: boolean;
    }, ExtArgs["result"]["user"]>;
    composites: {};
};
type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = runtime.Types.Result.GetResult<$UserPayload, S>;
type UserCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
};
interface UserDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['User'];
        meta: {
            name: 'User';
        };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(args?: Subset<T, UserCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], UserCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>;
    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends UserGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: UserGroupByArgs['orderBy'];
    } : {
        orderBy?: UserGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for User.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__UserClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    Appointment_Appointment_approvedByToUser<T extends User$Appointment_Appointment_approvedByToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Appointment_Appointment_approvedByToUserArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Appointment_Appointment_customerIdToUser<T extends User$Appointment_Appointment_customerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Appointment_Appointment_customerIdToUserArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Doctor<T extends User$DoctorArgs<ExtArgs> = {}>(args?: Subset<T, User$DoctorArgs<ExtArgs>>): Prisma__DoctorClient<runtime.Types.Result.GetResult<$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    DoctorApplication<T extends User$DoctorApplicationArgs<ExtArgs> = {}>(args?: Subset<T, User$DoctorApplicationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$DoctorApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Hospital<T extends User$HospitalArgs<ExtArgs> = {}>(args?: Subset<T, User$HospitalArgs<ExtArgs>>): Prisma__HospitalClient<runtime.Types.Result.GetResult<$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Payment<T extends User$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$PaymentArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Review<T extends User$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$ReviewArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    SavedDoctorHospital<T extends User$SavedDoctorHospitalArgs<ExtArgs> = {}>(args?: Subset<T, User$SavedDoctorHospitalArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SavedDoctorHospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    Schedule<T extends User$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, User$ScheduleArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    SearchLog<T extends User$SearchLogArgs<ExtArgs> = {}>(args?: Subset<T, User$SearchLogArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$SearchLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    account<T extends User$accountArgs<ExtArgs> = {}>(args?: Subset<T, User$accountArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the User model
 */
interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>;
    readonly fullName: FieldRef<"User", 'String'>;
    readonly email: FieldRef<"User", 'String'>;
    readonly emailVerified: FieldRef<"User", 'Boolean'>;
    readonly createdAt: FieldRef<"User", 'DateTime'>;
    readonly updatedAt: FieldRef<"User", 'DateTime'>;
    readonly phoneNumber: FieldRef<"User", 'String'>;
    readonly phoneNumberVerified: FieldRef<"User", 'Boolean'>;
    readonly gender: FieldRef<"User", 'String'>;
    readonly role: FieldRef<"User", 'Role'>;
    readonly dateOfBirth: FieldRef<"User", 'String'>;
    readonly imageUrl: FieldRef<"User", 'String'>;
    readonly imageId: FieldRef<"User", 'String'>;
    readonly banned: FieldRef<"User", 'Boolean'>;
    readonly isOnboardingComplete: FieldRef<"User", 'Boolean'>;
}
/**
 * User findUnique
 */
type UserFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
};
/**
 * User findUniqueOrThrow
 */
type UserFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
};
/**
 * User findFirst
 */
type UserFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
};
/**
 * User findFirstOrThrow
 */
type UserFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
};
/**
 * User findMany
 */
type UserFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
};
/**
 * User create
 */
type UserCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
};
/**
 * User createMany
 */
type UserCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * User createManyAndReturn
 */
type UserCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * User update
 */
type UserUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
};
/**
 * User updateMany
 */
type UserUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
};
/**
 * User updateManyAndReturn
 */
type UserUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
};
/**
 * User upsert
 */
type UserUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
};
/**
 * User delete
 */
type UserDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
};
/**
 * User deleteMany
 */
type UserDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
};
/**
 * User.Appointment_Appointment_approvedByToUser
 */
type User$Appointment_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    cursor?: AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * User.Appointment_Appointment_customerIdToUser
 */
type User$Appointment_Appointment_customerIdToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null;
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[];
    cursor?: AppointmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[];
};
/**
 * User.AuditLog
 */
type User$AuditLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
};
/**
 * User.Doctor
 */
type User$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Doctor
     */
    omit?: DoctorOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null;
    where?: DoctorWhereInput;
};
/**
 * User.DoctorApplication
 */
type User$DoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorApplication
     */
    select?: DoctorApplicationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DoctorApplication
     */
    omit?: DoctorApplicationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorApplicationInclude<ExtArgs> | null;
    where?: DoctorApplicationWhereInput;
    orderBy?: DoctorApplicationOrderByWithRelationInput | DoctorApplicationOrderByWithRelationInput[];
    cursor?: DoctorApplicationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DoctorApplicationScalarFieldEnum | DoctorApplicationScalarFieldEnum[];
};
/**
 * User.Hospital
 */
type User$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null;
    where?: HospitalWhereInput;
};
/**
 * User.Notification
 */
type User$NotificationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
};
/**
 * User.Payment
 */
type User$PaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    cursor?: PaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
};
/**
 * User.Review
 */
type User$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
};
/**
 * User.SavedDoctorHospital
 */
type User$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedDoctorHospital
     */
    select?: SavedDoctorHospitalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SavedDoctorHospital
     */
    omit?: SavedDoctorHospitalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedDoctorHospitalInclude<ExtArgs> | null;
    where?: SavedDoctorHospitalWhereInput;
    orderBy?: SavedDoctorHospitalOrderByWithRelationInput | SavedDoctorHospitalOrderByWithRelationInput[];
    cursor?: SavedDoctorHospitalWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SavedDoctorHospitalScalarFieldEnum | SavedDoctorHospitalScalarFieldEnum[];
};
/**
 * User.Schedule
 */
type User$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null;
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[];
    cursor?: ScheduleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[];
};
/**
 * User.SearchLog
 */
type User$SearchLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchLog
     */
    select?: SearchLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SearchLog
     */
    omit?: SearchLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchLogInclude<ExtArgs> | null;
    where?: SearchLogWhereInput;
    orderBy?: SearchLogOrderByWithRelationInput | SearchLogOrderByWithRelationInput[];
    cursor?: SearchLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SearchLogScalarFieldEnum | SearchLogScalarFieldEnum[];
};
/**
 * User.account
 */
type User$accountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    where?: accountWhereInput;
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[];
    cursor?: accountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
};
/**
 * User.session
 */
type User$sessionArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    where?: sessionWhereInput;
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[];
    cursor?: sessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
};
/**
 * User without action
 */
type UserDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
};

/**
 * Model account
 *
 */
type accountModel = runtime.Types.Result.DefaultSelection<$accountPayload>;
type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
};
type AccountMinAggregateOutputType = {
    id: string | null;
    accountId: string | null;
    providerId: string | null;
    userId: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type AccountMaxAggregateOutputType = {
    id: string | null;
    accountId: string | null;
    providerId: string | null;
    userId: string | null;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type AccountCountAggregateOutputType = {
    id: number;
    accountId: number;
    providerId: number;
    userId: number;
    accessToken: number;
    refreshToken: number;
    idToken: number;
    accessTokenExpiresAt: number;
    refreshTokenExpiresAt: number;
    scope: number;
    password: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type AccountMinAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
};
type AccountMaxAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
};
type AccountCountAggregateInputType = {
    id?: true;
    accountId?: true;
    providerId?: true;
    userId?: true;
    accessToken?: true;
    refreshToken?: true;
    idToken?: true;
    accessTokenExpiresAt?: true;
    refreshTokenExpiresAt?: true;
    scope?: true;
    password?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type AccountAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType;
};
type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateAccount[P]> : GetScalarType<T[P], AggregateAccount[P]>;
};
type accountGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: accountWhereInput;
    orderBy?: accountOrderByWithAggregationInput | accountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: accountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
};
type AccountGroupByOutputType = {
    id: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken: string | null;
    refreshToken: string | null;
    idToken: string | null;
    accessTokenExpiresAt: Date | null;
    refreshTokenExpiresAt: Date | null;
    scope: string | null;
    password: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AccountCountAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
};
type GetAccountGroupByPayload<T extends accountGroupByArgs> = PrismaPromise<Array<PickEnumerable<AccountGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], AccountGroupByOutputType[P]> : GetScalarType<T[P], AccountGroupByOutputType[P]>;
}>>;
type accountWhereInput = {
    AND?: accountWhereInput | accountWhereInput[];
    OR?: accountWhereInput[];
    NOT?: accountWhereInput | accountWhereInput[];
    id?: StringFilter<"account"> | string;
    accountId?: StringFilter<"account"> | string;
    providerId?: StringFilter<"account"> | string;
    userId?: StringFilter<"account"> | string;
    accessToken?: StringNullableFilter<"account"> | string | null;
    refreshToken?: StringNullableFilter<"account"> | string | null;
    idToken?: StringNullableFilter<"account"> | string | null;
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    scope?: StringNullableFilter<"account"> | string | null;
    password?: StringNullableFilter<"account"> | string | null;
    createdAt?: DateTimeFilter<"account"> | Date | string;
    updatedAt?: DateTimeFilter<"account"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type accountOrderByWithRelationInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    idToken?: SortOrderInput | SortOrder;
    accessTokenExpiresAt?: SortOrderInput | SortOrder;
    refreshTokenExpiresAt?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    User?: UserOrderByWithRelationInput;
};
type accountWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: accountWhereInput | accountWhereInput[];
    OR?: accountWhereInput[];
    NOT?: accountWhereInput | accountWhereInput[];
    accountId?: StringFilter<"account"> | string;
    providerId?: StringFilter<"account"> | string;
    userId?: StringFilter<"account"> | string;
    accessToken?: StringNullableFilter<"account"> | string | null;
    refreshToken?: StringNullableFilter<"account"> | string | null;
    idToken?: StringNullableFilter<"account"> | string | null;
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    scope?: StringNullableFilter<"account"> | string | null;
    password?: StringNullableFilter<"account"> | string | null;
    createdAt?: DateTimeFilter<"account"> | Date | string;
    updatedAt?: DateTimeFilter<"account"> | Date | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id">;
type accountOrderByWithAggregationInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrderInput | SortOrder;
    refreshToken?: SortOrderInput | SortOrder;
    idToken?: SortOrderInput | SortOrder;
    accessTokenExpiresAt?: SortOrderInput | SortOrder;
    refreshTokenExpiresAt?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: accountCountOrderByAggregateInput;
    _max?: accountMaxOrderByAggregateInput;
    _min?: accountMinOrderByAggregateInput;
};
type accountScalarWhereWithAggregatesInput = {
    AND?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[];
    OR?: accountScalarWhereWithAggregatesInput[];
    NOT?: accountScalarWhereWithAggregatesInput | accountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"account"> | string;
    accountId?: StringWithAggregatesFilter<"account"> | string;
    providerId?: StringWithAggregatesFilter<"account"> | string;
    userId?: StringWithAggregatesFilter<"account"> | string;
    accessToken?: StringNullableWithAggregatesFilter<"account"> | string | null;
    refreshToken?: StringNullableWithAggregatesFilter<"account"> | string | null;
    idToken?: StringNullableWithAggregatesFilter<"account"> | string | null;
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null;
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"account"> | Date | string | null;
    scope?: StringNullableWithAggregatesFilter<"account"> | string | null;
    password?: StringNullableWithAggregatesFilter<"account"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"account"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"account"> | Date | string;
};
type accountCreateInput = {
    id?: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    User: UserCreateNestedOneWithoutAccountInput;
};
type accountUncheckedCreateInput = {
    id?: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    User?: UserUpdateOneRequiredWithoutAccountNestedInput;
};
type accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type accountCreateManyInput = {
    id?: string;
    accountId: string;
    providerId: string;
    userId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type AccountListRelationFilter = {
    every?: accountWhereInput;
    some?: accountWhereInput;
    none?: accountWhereInput;
};
type accountOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type accountCountOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type accountMaxOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type accountMinOrderByAggregateInput = {
    id?: SortOrder;
    accountId?: SortOrder;
    providerId?: SortOrder;
    userId?: SortOrder;
    accessToken?: SortOrder;
    refreshToken?: SortOrder;
    idToken?: SortOrder;
    accessTokenExpiresAt?: SortOrder;
    refreshTokenExpiresAt?: SortOrder;
    scope?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type accountCreateNestedManyWithoutUserInput = {
    create?: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput> | accountCreateWithoutUserInput[] | accountUncheckedCreateWithoutUserInput[];
    connectOrCreate?: accountCreateOrConnectWithoutUserInput | accountCreateOrConnectWithoutUserInput[];
    createMany?: accountCreateManyUserInputEnvelope;
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[];
};
type accountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput> | accountCreateWithoutUserInput[] | accountUncheckedCreateWithoutUserInput[];
    connectOrCreate?: accountCreateOrConnectWithoutUserInput | accountCreateOrConnectWithoutUserInput[];
    createMany?: accountCreateManyUserInputEnvelope;
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[];
};
type accountUpdateManyWithoutUserNestedInput = {
    create?: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput> | accountCreateWithoutUserInput[] | accountUncheckedCreateWithoutUserInput[];
    connectOrCreate?: accountCreateOrConnectWithoutUserInput | accountCreateOrConnectWithoutUserInput[];
    upsert?: accountUpsertWithWhereUniqueWithoutUserInput | accountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: accountCreateManyUserInputEnvelope;
    set?: accountWhereUniqueInput | accountWhereUniqueInput[];
    disconnect?: accountWhereUniqueInput | accountWhereUniqueInput[];
    delete?: accountWhereUniqueInput | accountWhereUniqueInput[];
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[];
    update?: accountUpdateWithWhereUniqueWithoutUserInput | accountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: accountUpdateManyWithWhereWithoutUserInput | accountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: accountScalarWhereInput | accountScalarWhereInput[];
};
type accountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput> | accountCreateWithoutUserInput[] | accountUncheckedCreateWithoutUserInput[];
    connectOrCreate?: accountCreateOrConnectWithoutUserInput | accountCreateOrConnectWithoutUserInput[];
    upsert?: accountUpsertWithWhereUniqueWithoutUserInput | accountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: accountCreateManyUserInputEnvelope;
    set?: accountWhereUniqueInput | accountWhereUniqueInput[];
    disconnect?: accountWhereUniqueInput | accountWhereUniqueInput[];
    delete?: accountWhereUniqueInput | accountWhereUniqueInput[];
    connect?: accountWhereUniqueInput | accountWhereUniqueInput[];
    update?: accountUpdateWithWhereUniqueWithoutUserInput | accountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: accountUpdateManyWithWhereWithoutUserInput | accountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: accountScalarWhereInput | accountScalarWhereInput[];
};
type accountCreateWithoutUserInput = {
    id?: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type accountUncheckedCreateWithoutUserInput = {
    id?: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type accountCreateOrConnectWithoutUserInput = {
    where: accountWhereUniqueInput;
    create: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput>;
};
type accountCreateManyUserInputEnvelope = {
    data: accountCreateManyUserInput | accountCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type accountUpsertWithWhereUniqueWithoutUserInput = {
    where: accountWhereUniqueInput;
    update: XOR<accountUpdateWithoutUserInput, accountUncheckedUpdateWithoutUserInput>;
    create: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput>;
};
type accountUpdateWithWhereUniqueWithoutUserInput = {
    where: accountWhereUniqueInput;
    data: XOR<accountUpdateWithoutUserInput, accountUncheckedUpdateWithoutUserInput>;
};
type accountUpdateManyWithWhereWithoutUserInput = {
    where: accountScalarWhereInput;
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyWithoutUserInput>;
};
type accountScalarWhereInput = {
    AND?: accountScalarWhereInput | accountScalarWhereInput[];
    OR?: accountScalarWhereInput[];
    NOT?: accountScalarWhereInput | accountScalarWhereInput[];
    id?: StringFilter<"account"> | string;
    accountId?: StringFilter<"account"> | string;
    providerId?: StringFilter<"account"> | string;
    userId?: StringFilter<"account"> | string;
    accessToken?: StringNullableFilter<"account"> | string | null;
    refreshToken?: StringNullableFilter<"account"> | string | null;
    idToken?: StringNullableFilter<"account"> | string | null;
    accessTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    refreshTokenExpiresAt?: DateTimeNullableFilter<"account"> | Date | string | null;
    scope?: StringNullableFilter<"account"> | string | null;
    password?: StringNullableFilter<"account"> | string | null;
    createdAt?: DateTimeFilter<"account"> | Date | string;
    updatedAt?: DateTimeFilter<"account"> | Date | string;
};
type accountCreateManyUserInput = {
    id?: string;
    accountId: string;
    providerId: string;
    accessToken?: string | null;
    refreshToken?: string | null;
    idToken?: string | null;
    accessTokenExpiresAt?: Date | string | null;
    refreshTokenExpiresAt?: Date | string | null;
    scope?: string | null;
    password?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type accountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type accountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type accountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    accountId?: StringFieldUpdateOperationsInput | string;
    providerId?: StringFieldUpdateOperationsInput | string;
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null;
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null;
    idToken?: NullableStringFieldUpdateOperationsInput | string | null;
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type accountSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    accountId?: boolean;
    providerId?: boolean;
    userId?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    idToken?: boolean;
    accessTokenExpiresAt?: boolean;
    refreshTokenExpiresAt?: boolean;
    scope?: boolean;
    password?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["account"]>;
type accountSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    accountId?: boolean;
    providerId?: boolean;
    userId?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    idToken?: boolean;
    accessTokenExpiresAt?: boolean;
    refreshTokenExpiresAt?: boolean;
    scope?: boolean;
    password?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["account"]>;
type accountSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    accountId?: boolean;
    providerId?: boolean;
    userId?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    idToken?: boolean;
    accessTokenExpiresAt?: boolean;
    refreshTokenExpiresAt?: boolean;
    scope?: boolean;
    password?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["account"]>;
type accountSelectScalar = {
    id?: boolean;
    accountId?: boolean;
    providerId?: boolean;
    userId?: boolean;
    accessToken?: boolean;
    refreshToken?: boolean;
    idToken?: boolean;
    accessTokenExpiresAt?: boolean;
    refreshTokenExpiresAt?: boolean;
    scope?: boolean;
    password?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type accountOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>;
type accountInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type accountIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type accountIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $accountPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "account";
    objects: {
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        accountId: string;
        providerId: string;
        userId: string;
        accessToken: string | null;
        refreshToken: string | null;
        idToken: string | null;
        accessTokenExpiresAt: Date | null;
        refreshTokenExpiresAt: Date | null;
        scope: string | null;
        password: string | null;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["account"]>;
    composites: {};
};
type accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = runtime.Types.Result.GetResult<$accountPayload, S>;
type accountCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: AccountCountAggregateInputType | true;
};
interface accountDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['account'];
        meta: {
            name: 'account';
        };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountFindUniqueArgs>(args: SelectSubset<T, accountFindUniqueArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs>(args: SelectSubset<T, accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountFindFirstArgs>(args?: SelectSubset<T, accountFindFirstArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs>(args?: SelectSubset<T, accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends accountFindManyArgs>(args?: SelectSubset<T, accountFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends accountCreateArgs>(args: SelectSubset<T, accountCreateArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Accounts.
     * @param {accountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends accountCreateManyArgs>(args?: SelectSubset<T, accountCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {accountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends accountCreateManyAndReturnArgs>(args?: SelectSubset<T, accountCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends accountDeleteArgs>(args: SelectSubset<T, accountDeleteArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends accountUpdateArgs>(args: SelectSubset<T, accountUpdateArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends accountDeleteManyArgs>(args?: SelectSubset<T, accountDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends accountUpdateManyArgs>(args: SelectSubset<T, accountUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {accountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends accountUpdateManyAndReturnArgs>(args: SelectSubset<T, accountUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends accountUpsertArgs>(args: SelectSubset<T, accountUpsertArgs<ExtArgs>>): Prisma__accountClient<runtime.Types.Result.GetResult<$accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(args?: Subset<T, accountCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], AccountCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): PrismaPromise<GetAccountAggregateType<T>>;
    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends accountGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: accountGroupByArgs['orderBy'];
    } : {
        orderBy?: accountGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the account model
     */
    readonly fields: accountFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for account.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__accountClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the account model
 */
interface accountFieldRefs {
    readonly id: FieldRef<"account", 'String'>;
    readonly accountId: FieldRef<"account", 'String'>;
    readonly providerId: FieldRef<"account", 'String'>;
    readonly userId: FieldRef<"account", 'String'>;
    readonly accessToken: FieldRef<"account", 'String'>;
    readonly refreshToken: FieldRef<"account", 'String'>;
    readonly idToken: FieldRef<"account", 'String'>;
    readonly accessTokenExpiresAt: FieldRef<"account", 'DateTime'>;
    readonly refreshTokenExpiresAt: FieldRef<"account", 'DateTime'>;
    readonly scope: FieldRef<"account", 'String'>;
    readonly password: FieldRef<"account", 'String'>;
    readonly createdAt: FieldRef<"account", 'DateTime'>;
    readonly updatedAt: FieldRef<"account", 'DateTime'>;
}
/**
 * account findUnique
 */
type accountFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput;
};
/**
 * account findUniqueOrThrow
 */
type accountFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput;
};
/**
 * account findFirst
 */
type accountFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
};
/**
 * account findFirstOrThrow
 */
type accountFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
};
/**
 * account findMany
 */
type accountFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountOrderByWithRelationInput | accountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
};
/**
 * account create
 */
type accountCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * The data needed to create a account.
     */
    data: XOR<accountCreateInput, accountUncheckedCreateInput>;
};
/**
 * account createMany
 */
type accountCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * account createManyAndReturn
 */
type accountCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * The data used to create many accounts.
     */
    data: accountCreateManyInput | accountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * account update
 */
type accountUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>;
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput;
};
/**
 * account updateMany
 */
type accountUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>;
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput;
    /**
     * Limit how many accounts to update.
     */
    limit?: number;
};
/**
 * account updateManyAndReturn
 */
type accountUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>;
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput;
    /**
     * Limit how many accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * account upsert
 */
type accountUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput;
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>;
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>;
};
/**
 * account delete
 */
type accountDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput;
};
/**
 * account deleteMany
 */
type accountDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput;
    /**
     * Limit how many accounts to delete.
     */
    limit?: number;
};
/**
 * account without action
 */
type accountDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the account
     */
    omit?: accountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountInclude<ExtArgs> | null;
};

/**
 * Model session
 *
 */
type sessionModel = runtime.Types.Result.DefaultSelection<$sessionPayload>;
type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
};
type SessionMinAggregateOutputType = {
    id: string | null;
    expiresAt: Date | null;
    token: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
};
type SessionMaxAggregateOutputType = {
    id: string | null;
    expiresAt: Date | null;
    token: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string | null;
};
type SessionCountAggregateOutputType = {
    id: number;
    expiresAt: number;
    token: number;
    createdAt: number;
    updatedAt: number;
    ipAddress: number;
    userAgent: number;
    userId: number;
    _all: number;
};
type SessionMinAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
};
type SessionMaxAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
};
type SessionCountAggregateInputType = {
    id?: true;
    expiresAt?: true;
    token?: true;
    createdAt?: true;
    updatedAt?: true;
    ipAddress?: true;
    userAgent?: true;
    userId?: true;
    _all?: true;
};
type SessionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType;
};
type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateSession[P]> : GetScalarType<T[P], AggregateSession[P]>;
};
type sessionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: sessionWhereInput;
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: sessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
};
type SessionGroupByOutputType = {
    id: string;
    expiresAt: Date;
    token: string;
    createdAt: Date;
    updatedAt: Date;
    ipAddress: string | null;
    userAgent: string | null;
    userId: string;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
};
type GetSessionGroupByPayload<T extends sessionGroupByArgs> = PrismaPromise<Array<PickEnumerable<SessionGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], SessionGroupByOutputType[P]> : GetScalarType<T[P], SessionGroupByOutputType[P]>;
}>>;
type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[];
    OR?: sessionWhereInput[];
    NOT?: sessionWhereInput | sessionWhereInput[];
    id?: StringFilter<"session"> | string;
    expiresAt?: DateTimeFilter<"session"> | Date | string;
    token?: StringFilter<"session"> | string;
    createdAt?: DateTimeFilter<"session"> | Date | string;
    updatedAt?: DateTimeFilter<"session"> | Date | string;
    ipAddress?: StringNullableFilter<"session"> | string | null;
    userAgent?: StringNullableFilter<"session"> | string | null;
    userId?: StringFilter<"session"> | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
};
type sessionOrderByWithRelationInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    User?: UserOrderByWithRelationInput;
};
type sessionWhereUniqueInput = AtLeast<{
    id?: string;
    token?: string;
    AND?: sessionWhereInput | sessionWhereInput[];
    OR?: sessionWhereInput[];
    NOT?: sessionWhereInput | sessionWhereInput[];
    expiresAt?: DateTimeFilter<"session"> | Date | string;
    createdAt?: DateTimeFilter<"session"> | Date | string;
    updatedAt?: DateTimeFilter<"session"> | Date | string;
    ipAddress?: StringNullableFilter<"session"> | string | null;
    userAgent?: StringNullableFilter<"session"> | string | null;
    userId?: StringFilter<"session"> | string;
    User?: XOR<UserScalarRelationFilter, UserWhereInput>;
}, "id" | "token">;
type sessionOrderByWithAggregationInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    _count?: sessionCountOrderByAggregateInput;
    _max?: sessionMaxOrderByAggregateInput;
    _min?: sessionMinOrderByAggregateInput;
};
type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[];
    OR?: sessionScalarWhereWithAggregatesInput[];
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"session"> | string;
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string;
    token?: StringWithAggregatesFilter<"session"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"session"> | Date | string;
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null;
    userId?: StringWithAggregatesFilter<"session"> | string;
};
type sessionCreateInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    User: UserCreateNestedOneWithoutSessionInput;
};
type sessionUncheckedCreateInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
};
type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    User?: UserUpdateOneRequiredWithoutSessionNestedInput;
};
type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
};
type sessionCreateManyInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
    userId: string;
};
type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
};
type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
};
type SessionListRelationFilter = {
    every?: sessionWhereInput;
    some?: sessionWhereInput;
    none?: sessionWhereInput;
};
type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
};
type sessionCountOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
};
type sessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
};
type sessionMinOrderByAggregateInput = {
    id?: SortOrder;
    expiresAt?: SortOrder;
    token?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    userId?: SortOrder;
};
type sessionCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
};
type sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
};
type sessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[];
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[];
};
type sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[];
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[];
};
type sessionCreateWithoutUserInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
};
type sessionUncheckedCreateWithoutUserInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
};
type sessionCreateOrConnectWithoutUserInput = {
    where: sessionWhereUniqueInput;
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>;
};
type sessionCreateManyUserInputEnvelope = {
    data: sessionCreateManyUserInput | sessionCreateManyUserInput[];
    skipDuplicates?: boolean;
};
type sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput;
    update: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>;
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>;
};
type sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput;
    data: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>;
};
type sessionUpdateManyWithWhereWithoutUserInput = {
    where: sessionScalarWhereInput;
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutUserInput>;
};
type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[];
    OR?: sessionScalarWhereInput[];
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[];
    id?: StringFilter<"session"> | string;
    expiresAt?: DateTimeFilter<"session"> | Date | string;
    token?: StringFilter<"session"> | string;
    createdAt?: DateTimeFilter<"session"> | Date | string;
    updatedAt?: DateTimeFilter<"session"> | Date | string;
    ipAddress?: StringNullableFilter<"session"> | string | null;
    userAgent?: StringNullableFilter<"session"> | string | null;
    userId?: StringFilter<"session"> | string;
};
type sessionCreateManyUserInput = {
    id?: string;
    expiresAt: Date | string;
    token: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ipAddress?: string | null;
    userAgent?: string | null;
};
type sessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
};
type sessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
};
type sessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    token?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
};
type sessionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    expiresAt?: boolean;
    token?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["session"]>;
type sessionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    expiresAt?: boolean;
    token?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["session"]>;
type sessionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    expiresAt?: boolean;
    token?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
    User?: boolean | UserDefaultArgs<ExtArgs>;
}, ExtArgs["result"]["session"]>;
type sessionSelectScalar = {
    id?: boolean;
    expiresAt?: boolean;
    token?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    userId?: boolean;
};
type sessionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>;
type sessionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type sessionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type sessionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>;
};
type $sessionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "session";
    objects: {
        User: $UserPayload<ExtArgs>;
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        expiresAt: Date;
        token: string;
        createdAt: Date;
        updatedAt: Date;
        ipAddress: string | null;
        userAgent: string | null;
        userId: string;
    }, ExtArgs["result"]["session"]>;
    composites: {};
};
type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = runtime.Types.Result.GetResult<$sessionPayload, S>;
type sessionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SessionCountAggregateInputType | true;
};
interface sessionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['session'];
        meta: {
            name: 'session';
        };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<runtime.Types.Result.GetResult<$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(args?: Subset<T, sessionCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], SessionCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>;
    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends sessionGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: sessionGroupByArgs['orderBy'];
    } : {
        orderBy?: sessionGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the session model
     */
    readonly fields: sessionFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for session.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__sessionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<runtime.Types.Result.GetResult<$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the session model
 */
interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>;
    readonly expiresAt: FieldRef<"session", 'DateTime'>;
    readonly token: FieldRef<"session", 'String'>;
    readonly createdAt: FieldRef<"session", 'DateTime'>;
    readonly updatedAt: FieldRef<"session", 'DateTime'>;
    readonly ipAddress: FieldRef<"session", 'String'>;
    readonly userAgent: FieldRef<"session", 'String'>;
    readonly userId: FieldRef<"session", 'String'>;
}
/**
 * session findUnique
 */
type sessionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput;
};
/**
 * session findUniqueOrThrow
 */
type sessionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput;
};
/**
 * session findFirst
 */
type sessionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
};
/**
 * session findFirstOrThrow
 */
type sessionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
};
/**
 * session findMany
 */
type sessionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
};
/**
 * session create
 */
type sessionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>;
};
/**
 * session createMany
 */
type sessionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * session createManyAndReturn
 */
type sessionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeCreateManyAndReturn<ExtArgs> | null;
};
/**
 * session update
 */
type sessionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>;
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput;
};
/**
 * session updateMany
 */
type sessionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>;
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to update.
     */
    limit?: number;
};
/**
 * session updateManyAndReturn
 */
type sessionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>;
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeUpdateManyAndReturn<ExtArgs> | null;
};
/**
 * session upsert
 */
type sessionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput;
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>;
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>;
};
/**
 * session delete
 */
type sessionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput;
};
/**
 * session deleteMany
 */
type sessionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to delete.
     */
    limit?: number;
};
/**
 * session without action
 */
type sessionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
};

/**
 * Model verification
 *
 */
type verificationModel = runtime.Types.Result.DefaultSelection<$verificationPayload>;
type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null;
    _min: VerificationMinAggregateOutputType | null;
    _max: VerificationMaxAggregateOutputType | null;
};
type VerificationMinAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    value: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type VerificationMaxAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    value: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
};
type VerificationCountAggregateOutputType = {
    id: number;
    identifier: number;
    value: number;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
};
type VerificationMinAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
};
type VerificationMaxAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
};
type VerificationCountAggregateInputType = {
    id?: true;
    identifier?: true;
    value?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
};
type VerificationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which verification to aggregate.
     */
    where?: verificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: verificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned verifications
    **/
    _count?: true | VerificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType;
};
type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
    [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count' ? T[P] extends true ? number : GetScalarType<T[P], AggregateVerification[P]> : GetScalarType<T[P], AggregateVerification[P]>;
};
type verificationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    where?: verificationWhereInput;
    orderBy?: verificationOrderByWithAggregationInput | verificationOrderByWithAggregationInput[];
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum;
    having?: verificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationCountAggregateInputType | true;
    _min?: VerificationMinAggregateInputType;
    _max?: VerificationMaxAggregateInputType;
};
type VerificationGroupByOutputType = {
    id: string;
    identifier: string;
    value: string;
    expiresAt: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: VerificationCountAggregateOutputType | null;
    _min: VerificationMinAggregateOutputType | null;
    _max: VerificationMaxAggregateOutputType | null;
};
type GetVerificationGroupByPayload<T extends verificationGroupByArgs> = PrismaPromise<Array<PickEnumerable<VerificationGroupByOutputType, T['by']> & {
    [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count' ? T[P] extends boolean ? number : GetScalarType<T[P], VerificationGroupByOutputType[P]> : GetScalarType<T[P], VerificationGroupByOutputType[P]>;
}>>;
type verificationWhereInput = {
    AND?: verificationWhereInput | verificationWhereInput[];
    OR?: verificationWhereInput[];
    NOT?: verificationWhereInput | verificationWhereInput[];
    id?: StringFilter<"verification"> | string;
    identifier?: StringFilter<"verification"> | string;
    value?: StringFilter<"verification"> | string;
    expiresAt?: DateTimeFilter<"verification"> | Date | string;
    createdAt?: DateTimeFilter<"verification"> | Date | string;
    updatedAt?: DateTimeFilter<"verification"> | Date | string;
};
type verificationOrderByWithRelationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type verificationWhereUniqueInput = AtLeast<{
    id?: string;
    AND?: verificationWhereInput | verificationWhereInput[];
    OR?: verificationWhereInput[];
    NOT?: verificationWhereInput | verificationWhereInput[];
    identifier?: StringFilter<"verification"> | string;
    value?: StringFilter<"verification"> | string;
    expiresAt?: DateTimeFilter<"verification"> | Date | string;
    createdAt?: DateTimeFilter<"verification"> | Date | string;
    updatedAt?: DateTimeFilter<"verification"> | Date | string;
}, "id">;
type verificationOrderByWithAggregationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: verificationCountOrderByAggregateInput;
    _max?: verificationMaxOrderByAggregateInput;
    _min?: verificationMinOrderByAggregateInput;
};
type verificationScalarWhereWithAggregatesInput = {
    AND?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[];
    OR?: verificationScalarWhereWithAggregatesInput[];
    NOT?: verificationScalarWhereWithAggregatesInput | verificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"verification"> | string;
    identifier?: StringWithAggregatesFilter<"verification"> | string;
    value?: StringWithAggregatesFilter<"verification"> | string;
    expiresAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"verification"> | Date | string;
};
type verificationCreateInput = {
    id?: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type verificationUncheckedCreateInput = {
    id?: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type verificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type verificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type verificationCreateManyInput = {
    id?: string;
    identifier: string;
    value: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
};
type verificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type verificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
};
type verificationCountOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type verificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type verificationMinOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    value?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
};
type verificationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    identifier?: boolean;
    value?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
}, ExtArgs["result"]["verification"]>;
type verificationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    identifier?: boolean;
    value?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
}, ExtArgs["result"]["verification"]>;
type verificationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
    id?: boolean;
    identifier?: boolean;
    value?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
}, ExtArgs["result"]["verification"]>;
type verificationSelectScalar = {
    id?: boolean;
    identifier?: boolean;
    value?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
};
type verificationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>;
type $verificationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    name: "verification";
    objects: {};
    scalars: runtime.Types.Extensions.GetPayloadResult<{
        id: string;
        identifier: string;
        value: string;
        expiresAt: Date;
        createdAt: Date;
        updatedAt: Date;
    }, ExtArgs["result"]["verification"]>;
    composites: {};
};
type verificationGetPayload<S extends boolean | null | undefined | verificationDefaultArgs> = runtime.Types.Result.GetResult<$verificationPayload, S>;
type verificationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<verificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: VerificationCountAggregateInputType | true;
};
interface verificationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['model']['verification'];
        meta: {
            name: 'verification';
        };
    };
    /**
     * Find zero or one Verification that matches the filter.
     * @param {verificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verificationFindUniqueArgs>(args: SelectSubset<T, verificationFindUniqueArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verificationFindUniqueOrThrowArgs>(args: SelectSubset<T, verificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verificationFindFirstArgs>(args?: SelectSubset<T, verificationFindFirstArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>;
    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verificationFindFirstOrThrowArgs>(args?: SelectSubset<T, verificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     *
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends verificationFindManyArgs>(args?: SelectSubset<T, verificationFindManyArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;
    /**
     * Create a Verification.
     * @param {verificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     *
     */
    create<T extends verificationCreateArgs>(args: SelectSubset<T, verificationCreateArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Create many Verifications.
     * @param {verificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends verificationCreateManyArgs>(args?: SelectSubset<T, verificationCreateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {verificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends verificationCreateManyAndReturnArgs>(args?: SelectSubset<T, verificationCreateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>;
    /**
     * Delete a Verification.
     * @param {verificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     *
     */
    delete<T extends verificationDeleteArgs>(args: SelectSubset<T, verificationDeleteArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Update one Verification.
     * @param {verificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends verificationUpdateArgs>(args: SelectSubset<T, verificationUpdateArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Delete zero or more Verifications.
     * @param {verificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends verificationDeleteManyArgs>(args?: SelectSubset<T, verificationDeleteManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends verificationUpdateManyArgs>(args: SelectSubset<T, verificationUpdateManyArgs<ExtArgs>>): PrismaPromise<BatchPayload>;
    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {verificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends verificationUpdateManyAndReturnArgs>(args: SelectSubset<T, verificationUpdateManyAndReturnArgs<ExtArgs>>): PrismaPromise<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>;
    /**
     * Create or update one Verification.
     * @param {verificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends verificationUpsertArgs>(args: SelectSubset<T, verificationUpsertArgs<ExtArgs>>): Prisma__verificationClient<runtime.Types.Result.GetResult<$verificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>;
    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends verificationCountArgs>(args?: Subset<T, verificationCountArgs>): PrismaPromise<T extends runtime.Types.Utils.Record<'select', any> ? T['select'] extends true ? number : GetScalarType<T['select'], VerificationCountAggregateOutputType> : number>;
    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): PrismaPromise<GetVerificationAggregateType<T>>;
    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<T extends verificationGroupByArgs, HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>, OrderByArg extends True extends HasSelectOrTake ? {
        orderBy: verificationGroupByArgs['orderBy'];
    } : {
        orderBy?: verificationGroupByArgs['orderBy'];
    }, OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>, ByFields extends MaybeTupleToUnion<T['by']>, ByValid extends Has<ByFields, OrderFields>, HavingFields extends GetHavingFields<T['having']>, HavingValid extends Has<ByFields, HavingFields>, ByEmpty extends T['by'] extends never[] ? True : False, InputErrors extends ByEmpty extends True ? `Error: "by" must not be empty.` : HavingValid extends False ? {
        [P in HavingFields]: P extends ByFields ? never : P extends string ? `Error: Field "${P}" used in "having" needs to be provided in "by".` : [
            Error,
            'Field ',
            P,
            ` in "having" needs to be provided in "by"`
        ];
    }[HavingFields] : 'take' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "take", you also need to provide "orderBy"' : 'skip' extends Keys<T> ? 'orderBy' extends Keys<T> ? ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields] : 'Error: If you provide "skip", you also need to provide "orderBy"' : ByValid extends True ? {} : {
        [P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
    }[OrderFields]>(args: SubsetIntersection<T, verificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : PrismaPromise<InputErrors>;
    /**
     * Fields of the verification model
     */
    readonly fields: verificationFieldRefs;
}
/**
 * The delegate class that acts as a "Promise-like" for verification.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
interface Prisma__verificationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}
/**
 * Fields of the verification model
 */
interface verificationFieldRefs {
    readonly id: FieldRef<"verification", 'String'>;
    readonly identifier: FieldRef<"verification", 'String'>;
    readonly value: FieldRef<"verification", 'String'>;
    readonly expiresAt: FieldRef<"verification", 'DateTime'>;
    readonly createdAt: FieldRef<"verification", 'DateTime'>;
    readonly updatedAt: FieldRef<"verification", 'DateTime'>;
}
/**
 * verification findUnique
 */
type verificationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput;
};
/**
 * verification findUniqueOrThrow
 */
type verificationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter, which verification to fetch.
     */
    where: verificationWhereUniqueInput;
};
/**
 * verification findFirst
 */
type verificationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
};
/**
 * verification findFirstOrThrow
 */
type verificationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter, which verification to fetch.
     */
    where?: verificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for verifications.
     */
    cursor?: verificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` verifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
};
/**
 * verification findMany
 */
type verificationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter, which verifications to fetch.
     */
    where?: verificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of verifications to fetch.
     */
    orderBy?: verificationOrderByWithRelationInput | verificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing verifications.
     */
    cursor?: verificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` verifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` verifications.
     */
    skip?: number;
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[];
};
/**
 * verification create
 */
type verificationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * The data needed to create a verification.
     */
    data: XOR<verificationCreateInput, verificationUncheckedCreateInput>;
};
/**
 * verification createMany
 */
type verificationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to create many verifications.
     */
    data: verificationCreateManyInput | verificationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * verification createManyAndReturn
 */
type verificationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * The data used to create many verifications.
     */
    data: verificationCreateManyInput | verificationCreateManyInput[];
    skipDuplicates?: boolean;
};
/**
 * verification update
 */
type verificationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * The data needed to update a verification.
     */
    data: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>;
    /**
     * Choose, which verification to update.
     */
    where: verificationWhereUniqueInput;
};
/**
 * verification updateMany
 */
type verificationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * The data used to update verifications.
     */
    data: XOR<verificationUpdateManyMutationInput, verificationUncheckedUpdateManyInput>;
    /**
     * Filter which verifications to update
     */
    where?: verificationWhereInput;
    /**
     * Limit how many verifications to update.
     */
    limit?: number;
};
/**
 * verification updateManyAndReturn
 */
type verificationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * The data used to update verifications.
     */
    data: XOR<verificationUpdateManyMutationInput, verificationUncheckedUpdateManyInput>;
    /**
     * Filter which verifications to update
     */
    where?: verificationWhereInput;
    /**
     * Limit how many verifications to update.
     */
    limit?: number;
};
/**
 * verification upsert
 */
type verificationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * The filter to search for the verification to update in case it exists.
     */
    where: verificationWhereUniqueInput;
    /**
     * In case the verification found by the `where` argument doesn't exist, create a new verification with this data.
     */
    create: XOR<verificationCreateInput, verificationUncheckedCreateInput>;
    /**
     * In case the verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verificationUpdateInput, verificationUncheckedUpdateInput>;
};
/**
 * verification delete
 */
type verificationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
    /**
     * Filter which verification to delete.
     */
    where: verificationWhereUniqueInput;
};
/**
 * verification deleteMany
 */
type verificationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Filter which verifications to delete
     */
    where?: verificationWhereInput;
    /**
     * Limit how many verifications to delete.
     */
    limit?: number;
};
/**
 * verification without action
 */
type verificationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification
     */
    select?: verificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the verification
     */
    omit?: verificationOmit<ExtArgs> | null;
};

type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
};
type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>;
    in?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    notIn?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | AppointmentStatus;
};
type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
};
type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
};
type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
};
type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
};
type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
};
type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>;
    in?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    notIn?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | AppointmentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>;
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>;
};
type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
};
type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
};
type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
};
type JsonNullableFilter<$PrismaModel = never> = PatchUndefined<Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>, Required<JsonNullableFilterBase<$PrismaModel>>> | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;
type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
};
type JsonNullableWithAggregatesFilter<$PrismaModel = never> = PatchUndefined<Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>, Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>> | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;
type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
};
type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
};
type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
};
type EnumDoctorApplicationStatusFilter<$PrismaModel = never> = {
    equals?: DoctorApplicationStatus | EnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    in?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    notIn?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel> | DoctorApplicationStatus;
};
type EnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: DoctorApplicationStatus | EnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    in?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    notIn?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel> | DoctorApplicationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel>;
    _max?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel>;
};
type EnumDoctorTypeFilter<$PrismaModel = never> = {
    equals?: DoctorType | EnumDoctorTypeFieldRefInput<$PrismaModel>;
    in?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    notIn?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorTypeFilter<$PrismaModel> | DoctorType;
};
type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
};
type EnumDoctorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: DoctorType | EnumDoctorTypeFieldRefInput<$PrismaModel>;
    in?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    notIn?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorTypeWithAggregatesFilter<$PrismaModel> | DoctorType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDoctorTypeFilter<$PrismaModel>;
    _max?: NestedEnumDoctorTypeFilter<$PrismaModel>;
};
type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
};
type DecimalFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string;
};
type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
};
type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
};
type EnumHospitalTypeFilter<$PrismaModel = never> = {
    equals?: HospitalType | EnumHospitalTypeFieldRefInput<$PrismaModel>;
    in?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    notIn?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHospitalTypeFilter<$PrismaModel> | HospitalType;
};
type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
};
type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
};
type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
};
type EnumHospitalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: HospitalType | EnumHospitalTypeFieldRefInput<$PrismaModel>;
    in?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    notIn?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHospitalTypeWithAggregatesFilter<$PrismaModel> | HospitalType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHospitalTypeFilter<$PrismaModel>;
    _max?: NestedEnumHospitalTypeFilter<$PrismaModel>;
};
type EnumScheduleTypeFilter<$PrismaModel = never> = {
    equals?: ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>;
    in?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    notIn?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleTypeFilter<$PrismaModel> | ScheduleType;
};
type EnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>;
    in?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    notIn?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | ScheduleStatus;
};
type EnumSchedulePeriodFilter<$PrismaModel = never> = {
    equals?: SchedulePeriod | EnumSchedulePeriodFieldRefInput<$PrismaModel>;
    in?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    notIn?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumSchedulePeriodFilter<$PrismaModel> | SchedulePeriod;
};
type EnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>;
    in?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    notIn?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel> | ScheduleType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScheduleTypeFilter<$PrismaModel>;
    _max?: NestedEnumScheduleTypeFilter<$PrismaModel>;
};
type EnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>;
    in?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    notIn?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | ScheduleStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>;
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>;
};
type EnumSchedulePeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SchedulePeriod | EnumSchedulePeriodFieldRefInput<$PrismaModel>;
    in?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    notIn?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumSchedulePeriodWithAggregatesFilter<$PrismaModel> | SchedulePeriod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSchedulePeriodFilter<$PrismaModel>;
    _max?: NestedEnumSchedulePeriodFilter<$PrismaModel>;
};
type EnumSlotStatusFilter<$PrismaModel = never> = {
    equals?: SlotStatus | EnumSlotStatusFieldRefInput<$PrismaModel>;
    in?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    notIn?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlotStatusFilter<$PrismaModel> | SlotStatus;
};
type EnumSlotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SlotStatus | EnumSlotStatusFieldRefInput<$PrismaModel>;
    in?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    notIn?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlotStatusWithAggregatesFilter<$PrismaModel> | SlotStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSlotStatusFilter<$PrismaModel>;
    _max?: NestedEnumSlotStatusFilter<$PrismaModel>;
};
type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
};
type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | Role | null;
};
type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
};
type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | Role | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>;
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>;
};
type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
};
type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>;
    in?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    notIn?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | AppointmentStatus;
};
type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
};
type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
};
type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
};
type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
};
type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
};
type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>;
    in?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    notIn?: AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | AppointmentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>;
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>;
};
type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
};
type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
};
type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
};
type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
};
type NestedJsonNullableFilter<$PrismaModel = never> = PatchUndefined<Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>, Required<NestedJsonNullableFilterBase<$PrismaModel>>> | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;
type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: runtime.InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
};
type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
};
type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
};
type NestedEnumDoctorApplicationStatusFilter<$PrismaModel = never> = {
    equals?: DoctorApplicationStatus | EnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    in?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    notIn?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel> | DoctorApplicationStatus;
};
type NestedEnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: DoctorApplicationStatus | EnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    in?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    notIn?: DoctorApplicationStatus[] | ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel> | DoctorApplicationStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel>;
    _max?: NestedEnumDoctorApplicationStatusFilter<$PrismaModel>;
};
type NestedEnumDoctorTypeFilter<$PrismaModel = never> = {
    equals?: DoctorType | EnumDoctorTypeFieldRefInput<$PrismaModel>;
    in?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    notIn?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorTypeFilter<$PrismaModel> | DoctorType;
};
type NestedEnumDoctorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: DoctorType | EnumDoctorTypeFieldRefInput<$PrismaModel>;
    in?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    notIn?: DoctorType[] | ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumDoctorTypeWithAggregatesFilter<$PrismaModel> | DoctorType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDoctorTypeFilter<$PrismaModel>;
    _max?: NestedEnumDoctorTypeFilter<$PrismaModel>;
};
type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
};
type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
};
type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string;
};
type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
};
type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
};
type NestedEnumHospitalTypeFilter<$PrismaModel = never> = {
    equals?: HospitalType | EnumHospitalTypeFieldRefInput<$PrismaModel>;
    in?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    notIn?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHospitalTypeFilter<$PrismaModel> | HospitalType;
};
type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
};
type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
};
type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    notIn?: runtime.Decimal[] | runtime.DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null;
    lt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: runtime.Decimal | runtime.DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | runtime.Decimal | runtime.DecimalJsLike | number | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
};
type NestedEnumHospitalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: HospitalType | EnumHospitalTypeFieldRefInput<$PrismaModel>;
    in?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    notIn?: HospitalType[] | ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumHospitalTypeWithAggregatesFilter<$PrismaModel> | HospitalType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHospitalTypeFilter<$PrismaModel>;
    _max?: NestedEnumHospitalTypeFilter<$PrismaModel>;
};
type NestedEnumScheduleTypeFilter<$PrismaModel = never> = {
    equals?: ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>;
    in?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    notIn?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleTypeFilter<$PrismaModel> | ScheduleType;
};
type NestedEnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>;
    in?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    notIn?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | ScheduleStatus;
};
type NestedEnumSchedulePeriodFilter<$PrismaModel = never> = {
    equals?: SchedulePeriod | EnumSchedulePeriodFieldRefInput<$PrismaModel>;
    in?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    notIn?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumSchedulePeriodFilter<$PrismaModel> | SchedulePeriod;
};
type NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ScheduleType | EnumScheduleTypeFieldRefInput<$PrismaModel>;
    in?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    notIn?: ScheduleType[] | ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel> | ScheduleType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScheduleTypeFilter<$PrismaModel>;
    _max?: NestedEnumScheduleTypeFilter<$PrismaModel>;
};
type NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>;
    in?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    notIn?: ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | ScheduleStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>;
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>;
};
type NestedEnumSchedulePeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SchedulePeriod | EnumSchedulePeriodFieldRefInput<$PrismaModel>;
    in?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    notIn?: SchedulePeriod[] | ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumSchedulePeriodWithAggregatesFilter<$PrismaModel> | SchedulePeriod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSchedulePeriodFilter<$PrismaModel>;
    _max?: NestedEnumSchedulePeriodFilter<$PrismaModel>;
};
type NestedEnumSlotStatusFilter<$PrismaModel = never> = {
    equals?: SlotStatus | EnumSlotStatusFieldRefInput<$PrismaModel>;
    in?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    notIn?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlotStatusFilter<$PrismaModel> | SlotStatus;
};
type NestedEnumSlotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SlotStatus | EnumSlotStatusFieldRefInput<$PrismaModel>;
    in?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    notIn?: SlotStatus[] | ListEnumSlotStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSlotStatusWithAggregatesFilter<$PrismaModel> | SlotStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSlotStatusFilter<$PrismaModel>;
    _max?: NestedEnumSlotStatusFilter<$PrismaModel>;
};
type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null;
};
type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | Role | null;
};
type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null;
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedBoolNullableFilter<$PrismaModel>;
    _max?: NestedBoolNullableFilter<$PrismaModel>;
};
type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | Role | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>;
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>;
};

type DMMF = typeof runtime.DMMF;
type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;
/**
 * Prisma Errors
 */
declare const PrismaClientKnownRequestError: typeof runtime.PrismaClientKnownRequestError;
type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
declare const PrismaClientUnknownRequestError: typeof runtime.PrismaClientUnknownRequestError;
type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
declare const PrismaClientRustPanicError: typeof runtime.PrismaClientRustPanicError;
type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
declare const PrismaClientInitializationError: typeof runtime.PrismaClientInitializationError;
type PrismaClientInitializationError = runtime.PrismaClientInitializationError;
declare const PrismaClientValidationError: typeof runtime.PrismaClientValidationError;
type PrismaClientValidationError = runtime.PrismaClientValidationError;
/**
 * Re-export of sql-template-tag
 */
declare const sql: typeof runtime.sqltag;
declare const empty: runtime.Sql;
declare const join: typeof runtime.join;
declare const raw: typeof runtime.raw;
declare const Sql: typeof runtime.Sql;
type Sql = runtime.Sql;
/**
 * Decimal.js
 */
declare const Decimal: typeof runtime.Decimal;
type Decimal = runtime.Decimal;
type DecimalJsLike = runtime.DecimalJsLike;
/**
* Extensions
*/
type Extension = runtime.Types.Extensions.UserArgs;
declare const getExtensionContext: typeof runtime.Extensions.getExtensionContext;
type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>;
type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>;
type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>;
type Exact<A, W> = runtime.Types.Public.Exact<A, W>;
type PrismaVersion = {
    client: string;
    engine: string;
};
/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
declare const prismaVersion: PrismaVersion;
/**
 * Utility Types
 */
type Bytes = runtime.Bytes;
type JsonObject = runtime.JsonObject;
type JsonArray = runtime.JsonArray;
type JsonValue = runtime.JsonValue;
type InputJsonObject = runtime.InputJsonObject;
type InputJsonArray = runtime.InputJsonArray;
type InputJsonValue = runtime.InputJsonValue;
declare const NullTypes: {
    DbNull: (new (secret: never) => typeof runtime.DbNull);
    JsonNull: (new (secret: never) => typeof runtime.JsonNull);
    AnyNull: (new (secret: never) => typeof runtime.AnyNull);
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
declare const DbNull: runtime.DbNullClass;
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
declare const JsonNull: runtime.JsonNullClass;
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
declare const AnyNull: runtime.AnyNullClass;
type SelectAndInclude = {
    select: any;
    include: any;
};
type SelectAndOmit = {
    select: any;
    omit: any;
};
/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
type Enumerable<T> = T | Array<T>;
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude ? 'Please either choose `select` or `include`.' : T extends SelectAndOmit ? 'Please either choose `select` or `omit`.' : {});
/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;
type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = T extends object ? U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U : T;
/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any> ? False : T extends Date ? False : T extends Uint8Array ? False : T extends BigInt ? False : T extends object ? True : False;
/**
 * If it's T[], return T
 */
type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;
/**
 * From ts-toolbelt
 */
type __Either<O extends object, K extends Key> = Omit<O, K> & {
    [P in K]: Prisma__Pick<O, P & keyof O>;
}[K];
type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;
type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;
type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
}[strict];
type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown ? _Either<O, K, strict> : never;
type Union = any;
type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};
/** Helper Types for "Merge" **/
type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};
type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;
type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];
type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
} & {};
type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
} & {};
type _Record<K extends keyof any, T> = {
    [P in K]: T;
};
type NoExpand<T> = T extends unknown ? T : never;
type AtLeast<O extends object, K extends string> = NoExpand<O extends unknown ? (K extends keyof O ? {
    [P in K]: O[P];
} & O : O) | {
    [P in keyof O as P extends K ? P : never]-?: O[P];
} & O : never>;
type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;
type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/
type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;
type Boolean = True | False;
type True = 1;
type False = 0;
type Not<B extends Boolean> = {
    0: 1;
    1: 0;
}[B];
type Extends<A1 extends any, A2 extends any> = [A1] extends [never] ? 0 : A1 extends A2 ? 1 : 0;
type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;
type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
        0: 0;
        1: 1;
    };
    1: {
        0: 1;
        1: 1;
    };
}[B1][B2];
type Keys<U extends Union> = U extends unknown ? keyof U : never;
type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O ? O[P] : never;
} : never;
type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> = IsObject<T> extends True ? U : T;
type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True ? T[K] extends infer TK ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never> : never : {} extends FieldPaths<T[K]> ? never : K;
}[keyof T];
/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;
/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>;
/**
 * Exclude all keys with underscores
 */
type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;
type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;
type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>;
declare const ModelName: {
    readonly Appointment: "Appointment";
    readonly AuditLog: "AuditLog";
    readonly Doctor: "Doctor";
    readonly DoctorApplication: "DoctorApplication";
    readonly DoctorHospitalProfile: "DoctorHospitalProfile";
    readonly DoctorSpecialization: "DoctorSpecialization";
    readonly Hospital: "Hospital";
    readonly HospitalSpecialization: "HospitalSpecialization";
    readonly Notification: "Notification";
    readonly Payment: "Payment";
    readonly Review: "Review";
    readonly SavedDoctorHospital: "SavedDoctorHospital";
    readonly Schedule: "Schedule";
    readonly SearchLog: "SearchLog";
    readonly Slot: "Slot";
    readonly Specialization: "Specialization";
    readonly User: "User";
    readonly account: "account";
    readonly session: "session";
    readonly verification: "verification";
};
type ModelName = (typeof ModelName)[keyof typeof ModelName];
interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{
    extArgs: runtime.Types.Extensions.InternalArgs;
}, runtime.Types.Utils.Record<string, any>> {
    returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>;
}
type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
        omit: GlobalOmitOptions;
    };
    meta: {
        modelProps: "appointment" | "auditLog" | "doctor" | "doctorApplication" | "doctorHospitalProfile" | "doctorSpecialization" | "hospital" | "hospitalSpecialization" | "notification" | "payment" | "review" | "savedDoctorHospital" | "schedule" | "searchLog" | "slot" | "specialization" | "user" | "account" | "session" | "verification";
        txIsolationLevel: TransactionIsolationLevel;
    };
    model: {
        Appointment: {
            payload: $AppointmentPayload<ExtArgs>;
            fields: AppointmentFieldRefs;
            operations: {
                findUnique: {
                    args: AppointmentFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload> | null;
                };
                findUniqueOrThrow: {
                    args: AppointmentFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                findFirst: {
                    args: AppointmentFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload> | null;
                };
                findFirstOrThrow: {
                    args: AppointmentFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                findMany: {
                    args: AppointmentFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>[];
                };
                create: {
                    args: AppointmentCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                createMany: {
                    args: AppointmentCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: AppointmentCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>[];
                };
                delete: {
                    args: AppointmentDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                update: {
                    args: AppointmentUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                deleteMany: {
                    args: AppointmentDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: AppointmentUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: AppointmentUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>[];
                };
                upsert: {
                    args: AppointmentUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AppointmentPayload>;
                };
                aggregate: {
                    args: AppointmentAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateAppointment>;
                };
                groupBy: {
                    args: AppointmentGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AppointmentGroupByOutputType>[];
                };
                count: {
                    args: AppointmentCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AppointmentCountAggregateOutputType> | number;
                };
            };
        };
        AuditLog: {
            payload: $AuditLogPayload<ExtArgs>;
            fields: AuditLogFieldRefs;
            operations: {
                findUnique: {
                    args: AuditLogFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload> | null;
                };
                findUniqueOrThrow: {
                    args: AuditLogFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                findFirst: {
                    args: AuditLogFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload> | null;
                };
                findFirstOrThrow: {
                    args: AuditLogFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                findMany: {
                    args: AuditLogFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>[];
                };
                create: {
                    args: AuditLogCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                createMany: {
                    args: AuditLogCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: AuditLogCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>[];
                };
                delete: {
                    args: AuditLogDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                update: {
                    args: AuditLogUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                deleteMany: {
                    args: AuditLogDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: AuditLogUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: AuditLogUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>[];
                };
                upsert: {
                    args: AuditLogUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$AuditLogPayload>;
                };
                aggregate: {
                    args: AuditLogAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateAuditLog>;
                };
                groupBy: {
                    args: AuditLogGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AuditLogGroupByOutputType>[];
                };
                count: {
                    args: AuditLogCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AuditLogCountAggregateOutputType> | number;
                };
            };
        };
        Doctor: {
            payload: $DoctorPayload<ExtArgs>;
            fields: DoctorFieldRefs;
            operations: {
                findUnique: {
                    args: DoctorFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload> | null;
                };
                findUniqueOrThrow: {
                    args: DoctorFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                findFirst: {
                    args: DoctorFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload> | null;
                };
                findFirstOrThrow: {
                    args: DoctorFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                findMany: {
                    args: DoctorFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>[];
                };
                create: {
                    args: DoctorCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                createMany: {
                    args: DoctorCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: DoctorCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>[];
                };
                delete: {
                    args: DoctorDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                update: {
                    args: DoctorUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                deleteMany: {
                    args: DoctorDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: DoctorUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: DoctorUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>[];
                };
                upsert: {
                    args: DoctorUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorPayload>;
                };
                aggregate: {
                    args: DoctorAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateDoctor>;
                };
                groupBy: {
                    args: DoctorGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorGroupByOutputType>[];
                };
                count: {
                    args: DoctorCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorCountAggregateOutputType> | number;
                };
            };
        };
        DoctorApplication: {
            payload: $DoctorApplicationPayload<ExtArgs>;
            fields: DoctorApplicationFieldRefs;
            operations: {
                findUnique: {
                    args: DoctorApplicationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: DoctorApplicationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                findFirst: {
                    args: DoctorApplicationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload> | null;
                };
                findFirstOrThrow: {
                    args: DoctorApplicationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                findMany: {
                    args: DoctorApplicationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>[];
                };
                create: {
                    args: DoctorApplicationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                createMany: {
                    args: DoctorApplicationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: DoctorApplicationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>[];
                };
                delete: {
                    args: DoctorApplicationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                update: {
                    args: DoctorApplicationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                deleteMany: {
                    args: DoctorApplicationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: DoctorApplicationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: DoctorApplicationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>[];
                };
                upsert: {
                    args: DoctorApplicationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorApplicationPayload>;
                };
                aggregate: {
                    args: DoctorApplicationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateDoctorApplication>;
                };
                groupBy: {
                    args: DoctorApplicationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorApplicationGroupByOutputType>[];
                };
                count: {
                    args: DoctorApplicationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorApplicationCountAggregateOutputType> | number;
                };
            };
        };
        DoctorHospitalProfile: {
            payload: $DoctorHospitalProfilePayload<ExtArgs>;
            fields: DoctorHospitalProfileFieldRefs;
            operations: {
                findUnique: {
                    args: DoctorHospitalProfileFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload> | null;
                };
                findUniqueOrThrow: {
                    args: DoctorHospitalProfileFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                findFirst: {
                    args: DoctorHospitalProfileFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload> | null;
                };
                findFirstOrThrow: {
                    args: DoctorHospitalProfileFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                findMany: {
                    args: DoctorHospitalProfileFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>[];
                };
                create: {
                    args: DoctorHospitalProfileCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                createMany: {
                    args: DoctorHospitalProfileCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: DoctorHospitalProfileCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>[];
                };
                delete: {
                    args: DoctorHospitalProfileDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                update: {
                    args: DoctorHospitalProfileUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                deleteMany: {
                    args: DoctorHospitalProfileDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: DoctorHospitalProfileUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: DoctorHospitalProfileUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>[];
                };
                upsert: {
                    args: DoctorHospitalProfileUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorHospitalProfilePayload>;
                };
                aggregate: {
                    args: DoctorHospitalProfileAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateDoctorHospitalProfile>;
                };
                groupBy: {
                    args: DoctorHospitalProfileGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorHospitalProfileGroupByOutputType>[];
                };
                count: {
                    args: DoctorHospitalProfileCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorHospitalProfileCountAggregateOutputType> | number;
                };
            };
        };
        DoctorSpecialization: {
            payload: $DoctorSpecializationPayload<ExtArgs>;
            fields: DoctorSpecializationFieldRefs;
            operations: {
                findUnique: {
                    args: DoctorSpecializationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: DoctorSpecializationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                findFirst: {
                    args: DoctorSpecializationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload> | null;
                };
                findFirstOrThrow: {
                    args: DoctorSpecializationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                findMany: {
                    args: DoctorSpecializationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>[];
                };
                create: {
                    args: DoctorSpecializationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                createMany: {
                    args: DoctorSpecializationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: DoctorSpecializationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>[];
                };
                delete: {
                    args: DoctorSpecializationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                update: {
                    args: DoctorSpecializationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                deleteMany: {
                    args: DoctorSpecializationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: DoctorSpecializationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: DoctorSpecializationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>[];
                };
                upsert: {
                    args: DoctorSpecializationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$DoctorSpecializationPayload>;
                };
                aggregate: {
                    args: DoctorSpecializationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateDoctorSpecialization>;
                };
                groupBy: {
                    args: DoctorSpecializationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorSpecializationGroupByOutputType>[];
                };
                count: {
                    args: DoctorSpecializationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<DoctorSpecializationCountAggregateOutputType> | number;
                };
            };
        };
        Hospital: {
            payload: $HospitalPayload<ExtArgs>;
            fields: HospitalFieldRefs;
            operations: {
                findUnique: {
                    args: HospitalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: HospitalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                findFirst: {
                    args: HospitalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload> | null;
                };
                findFirstOrThrow: {
                    args: HospitalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                findMany: {
                    args: HospitalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>[];
                };
                create: {
                    args: HospitalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                createMany: {
                    args: HospitalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: HospitalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>[];
                };
                delete: {
                    args: HospitalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                update: {
                    args: HospitalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                deleteMany: {
                    args: HospitalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: HospitalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: HospitalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>[];
                };
                upsert: {
                    args: HospitalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalPayload>;
                };
                aggregate: {
                    args: HospitalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateHospital>;
                };
                groupBy: {
                    args: HospitalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<HospitalGroupByOutputType>[];
                };
                count: {
                    args: HospitalCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<HospitalCountAggregateOutputType> | number;
                };
            };
        };
        HospitalSpecialization: {
            payload: $HospitalSpecializationPayload<ExtArgs>;
            fields: HospitalSpecializationFieldRefs;
            operations: {
                findUnique: {
                    args: HospitalSpecializationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: HospitalSpecializationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                findFirst: {
                    args: HospitalSpecializationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload> | null;
                };
                findFirstOrThrow: {
                    args: HospitalSpecializationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                findMany: {
                    args: HospitalSpecializationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>[];
                };
                create: {
                    args: HospitalSpecializationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                createMany: {
                    args: HospitalSpecializationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: HospitalSpecializationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>[];
                };
                delete: {
                    args: HospitalSpecializationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                update: {
                    args: HospitalSpecializationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                deleteMany: {
                    args: HospitalSpecializationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: HospitalSpecializationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: HospitalSpecializationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>[];
                };
                upsert: {
                    args: HospitalSpecializationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$HospitalSpecializationPayload>;
                };
                aggregate: {
                    args: HospitalSpecializationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateHospitalSpecialization>;
                };
                groupBy: {
                    args: HospitalSpecializationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<HospitalSpecializationGroupByOutputType>[];
                };
                count: {
                    args: HospitalSpecializationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<HospitalSpecializationCountAggregateOutputType> | number;
                };
            };
        };
        Notification: {
            payload: $NotificationPayload<ExtArgs>;
            fields: NotificationFieldRefs;
            operations: {
                findUnique: {
                    args: NotificationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: NotificationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                findFirst: {
                    args: NotificationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload> | null;
                };
                findFirstOrThrow: {
                    args: NotificationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                findMany: {
                    args: NotificationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>[];
                };
                create: {
                    args: NotificationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                createMany: {
                    args: NotificationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: NotificationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>[];
                };
                delete: {
                    args: NotificationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                update: {
                    args: NotificationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                deleteMany: {
                    args: NotificationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: NotificationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: NotificationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>[];
                };
                upsert: {
                    args: NotificationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$NotificationPayload>;
                };
                aggregate: {
                    args: NotificationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateNotification>;
                };
                groupBy: {
                    args: NotificationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<NotificationGroupByOutputType>[];
                };
                count: {
                    args: NotificationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<NotificationCountAggregateOutputType> | number;
                };
            };
        };
        Payment: {
            payload: $PaymentPayload<ExtArgs>;
            fields: PaymentFieldRefs;
            operations: {
                findUnique: {
                    args: PaymentFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload> | null;
                };
                findUniqueOrThrow: {
                    args: PaymentFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                findFirst: {
                    args: PaymentFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload> | null;
                };
                findFirstOrThrow: {
                    args: PaymentFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                findMany: {
                    args: PaymentFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>[];
                };
                create: {
                    args: PaymentCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                createMany: {
                    args: PaymentCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: PaymentCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>[];
                };
                delete: {
                    args: PaymentDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                update: {
                    args: PaymentUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                deleteMany: {
                    args: PaymentDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: PaymentUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: PaymentUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>[];
                };
                upsert: {
                    args: PaymentUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$PaymentPayload>;
                };
                aggregate: {
                    args: PaymentAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregatePayment>;
                };
                groupBy: {
                    args: PaymentGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<PaymentGroupByOutputType>[];
                };
                count: {
                    args: PaymentCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<PaymentCountAggregateOutputType> | number;
                };
            };
        };
        Review: {
            payload: $ReviewPayload<ExtArgs>;
            fields: ReviewFieldRefs;
            operations: {
                findUnique: {
                    args: ReviewFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload> | null;
                };
                findUniqueOrThrow: {
                    args: ReviewFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                findFirst: {
                    args: ReviewFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload> | null;
                };
                findFirstOrThrow: {
                    args: ReviewFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                findMany: {
                    args: ReviewFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>[];
                };
                create: {
                    args: ReviewCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                createMany: {
                    args: ReviewCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: ReviewCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>[];
                };
                delete: {
                    args: ReviewDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                update: {
                    args: ReviewUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                deleteMany: {
                    args: ReviewDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: ReviewUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: ReviewUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>[];
                };
                upsert: {
                    args: ReviewUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$ReviewPayload>;
                };
                aggregate: {
                    args: ReviewAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateReview>;
                };
                groupBy: {
                    args: ReviewGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<ReviewGroupByOutputType>[];
                };
                count: {
                    args: ReviewCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<ReviewCountAggregateOutputType> | number;
                };
            };
        };
        SavedDoctorHospital: {
            payload: $SavedDoctorHospitalPayload<ExtArgs>;
            fields: SavedDoctorHospitalFieldRefs;
            operations: {
                findUnique: {
                    args: SavedDoctorHospitalFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload> | null;
                };
                findUniqueOrThrow: {
                    args: SavedDoctorHospitalFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                findFirst: {
                    args: SavedDoctorHospitalFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload> | null;
                };
                findFirstOrThrow: {
                    args: SavedDoctorHospitalFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                findMany: {
                    args: SavedDoctorHospitalFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>[];
                };
                create: {
                    args: SavedDoctorHospitalCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                createMany: {
                    args: SavedDoctorHospitalCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: SavedDoctorHospitalCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>[];
                };
                delete: {
                    args: SavedDoctorHospitalDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                update: {
                    args: SavedDoctorHospitalUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                deleteMany: {
                    args: SavedDoctorHospitalDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: SavedDoctorHospitalUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: SavedDoctorHospitalUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>[];
                };
                upsert: {
                    args: SavedDoctorHospitalUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SavedDoctorHospitalPayload>;
                };
                aggregate: {
                    args: SavedDoctorHospitalAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSavedDoctorHospital>;
                };
                groupBy: {
                    args: SavedDoctorHospitalGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SavedDoctorHospitalGroupByOutputType>[];
                };
                count: {
                    args: SavedDoctorHospitalCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SavedDoctorHospitalCountAggregateOutputType> | number;
                };
            };
        };
        Schedule: {
            payload: $SchedulePayload<ExtArgs>;
            fields: ScheduleFieldRefs;
            operations: {
                findUnique: {
                    args: ScheduleFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload> | null;
                };
                findUniqueOrThrow: {
                    args: ScheduleFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                findFirst: {
                    args: ScheduleFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload> | null;
                };
                findFirstOrThrow: {
                    args: ScheduleFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                findMany: {
                    args: ScheduleFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>[];
                };
                create: {
                    args: ScheduleCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                createMany: {
                    args: ScheduleCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: ScheduleCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>[];
                };
                delete: {
                    args: ScheduleDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                update: {
                    args: ScheduleUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                deleteMany: {
                    args: ScheduleDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: ScheduleUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: ScheduleUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>[];
                };
                upsert: {
                    args: ScheduleUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SchedulePayload>;
                };
                aggregate: {
                    args: ScheduleAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSchedule>;
                };
                groupBy: {
                    args: ScheduleGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<ScheduleGroupByOutputType>[];
                };
                count: {
                    args: ScheduleCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<ScheduleCountAggregateOutputType> | number;
                };
            };
        };
        SearchLog: {
            payload: $SearchLogPayload<ExtArgs>;
            fields: SearchLogFieldRefs;
            operations: {
                findUnique: {
                    args: SearchLogFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload> | null;
                };
                findUniqueOrThrow: {
                    args: SearchLogFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                findFirst: {
                    args: SearchLogFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload> | null;
                };
                findFirstOrThrow: {
                    args: SearchLogFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                findMany: {
                    args: SearchLogFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>[];
                };
                create: {
                    args: SearchLogCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                createMany: {
                    args: SearchLogCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: SearchLogCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>[];
                };
                delete: {
                    args: SearchLogDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                update: {
                    args: SearchLogUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                deleteMany: {
                    args: SearchLogDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: SearchLogUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: SearchLogUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>[];
                };
                upsert: {
                    args: SearchLogUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SearchLogPayload>;
                };
                aggregate: {
                    args: SearchLogAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSearchLog>;
                };
                groupBy: {
                    args: SearchLogGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SearchLogGroupByOutputType>[];
                };
                count: {
                    args: SearchLogCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SearchLogCountAggregateOutputType> | number;
                };
            };
        };
        Slot: {
            payload: $SlotPayload<ExtArgs>;
            fields: SlotFieldRefs;
            operations: {
                findUnique: {
                    args: SlotFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload> | null;
                };
                findUniqueOrThrow: {
                    args: SlotFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                findFirst: {
                    args: SlotFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload> | null;
                };
                findFirstOrThrow: {
                    args: SlotFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                findMany: {
                    args: SlotFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>[];
                };
                create: {
                    args: SlotCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                createMany: {
                    args: SlotCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: SlotCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>[];
                };
                delete: {
                    args: SlotDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                update: {
                    args: SlotUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                deleteMany: {
                    args: SlotDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: SlotUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: SlotUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>[];
                };
                upsert: {
                    args: SlotUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SlotPayload>;
                };
                aggregate: {
                    args: SlotAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSlot>;
                };
                groupBy: {
                    args: SlotGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SlotGroupByOutputType>[];
                };
                count: {
                    args: SlotCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SlotCountAggregateOutputType> | number;
                };
            };
        };
        Specialization: {
            payload: $SpecializationPayload<ExtArgs>;
            fields: SpecializationFieldRefs;
            operations: {
                findUnique: {
                    args: SpecializationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: SpecializationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                findFirst: {
                    args: SpecializationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload> | null;
                };
                findFirstOrThrow: {
                    args: SpecializationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                findMany: {
                    args: SpecializationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>[];
                };
                create: {
                    args: SpecializationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                createMany: {
                    args: SpecializationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: SpecializationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>[];
                };
                delete: {
                    args: SpecializationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                update: {
                    args: SpecializationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                deleteMany: {
                    args: SpecializationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: SpecializationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: SpecializationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>[];
                };
                upsert: {
                    args: SpecializationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$SpecializationPayload>;
                };
                aggregate: {
                    args: SpecializationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSpecialization>;
                };
                groupBy: {
                    args: SpecializationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SpecializationGroupByOutputType>[];
                };
                count: {
                    args: SpecializationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SpecializationCountAggregateOutputType> | number;
                };
            };
        };
        User: {
            payload: $UserPayload<ExtArgs>;
            fields: UserFieldRefs;
            operations: {
                findUnique: {
                    args: UserFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload> | null;
                };
                findUniqueOrThrow: {
                    args: UserFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                findFirst: {
                    args: UserFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload> | null;
                };
                findFirstOrThrow: {
                    args: UserFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                findMany: {
                    args: UserFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>[];
                };
                create: {
                    args: UserCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                createMany: {
                    args: UserCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: UserCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>[];
                };
                delete: {
                    args: UserDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                update: {
                    args: UserUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                deleteMany: {
                    args: UserDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: UserUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: UserUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>[];
                };
                upsert: {
                    args: UserUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$UserPayload>;
                };
                aggregate: {
                    args: UserAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateUser>;
                };
                groupBy: {
                    args: UserGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<UserGroupByOutputType>[];
                };
                count: {
                    args: UserCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<UserCountAggregateOutputType> | number;
                };
            };
        };
        account: {
            payload: $accountPayload<ExtArgs>;
            fields: accountFieldRefs;
            operations: {
                findUnique: {
                    args: accountFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload> | null;
                };
                findUniqueOrThrow: {
                    args: accountFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                findFirst: {
                    args: accountFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload> | null;
                };
                findFirstOrThrow: {
                    args: accountFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                findMany: {
                    args: accountFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>[];
                };
                create: {
                    args: accountCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                createMany: {
                    args: accountCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: accountCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>[];
                };
                delete: {
                    args: accountDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                update: {
                    args: accountUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                deleteMany: {
                    args: accountDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: accountUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: accountUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>[];
                };
                upsert: {
                    args: accountUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$accountPayload>;
                };
                aggregate: {
                    args: AccountAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateAccount>;
                };
                groupBy: {
                    args: accountGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AccountGroupByOutputType>[];
                };
                count: {
                    args: accountCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AccountCountAggregateOutputType> | number;
                };
            };
        };
        session: {
            payload: $sessionPayload<ExtArgs>;
            fields: sessionFieldRefs;
            operations: {
                findUnique: {
                    args: sessionFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload> | null;
                };
                findUniqueOrThrow: {
                    args: sessionFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                findFirst: {
                    args: sessionFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload> | null;
                };
                findFirstOrThrow: {
                    args: sessionFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                findMany: {
                    args: sessionFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>[];
                };
                create: {
                    args: sessionCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                createMany: {
                    args: sessionCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: sessionCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>[];
                };
                delete: {
                    args: sessionDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                update: {
                    args: sessionUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                deleteMany: {
                    args: sessionDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: sessionUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: sessionUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>[];
                };
                upsert: {
                    args: sessionUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$sessionPayload>;
                };
                aggregate: {
                    args: SessionAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateSession>;
                };
                groupBy: {
                    args: sessionGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SessionGroupByOutputType>[];
                };
                count: {
                    args: sessionCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<SessionCountAggregateOutputType> | number;
                };
            };
        };
        verification: {
            payload: $verificationPayload<ExtArgs>;
            fields: verificationFieldRefs;
            operations: {
                findUnique: {
                    args: verificationFindUniqueArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload> | null;
                };
                findUniqueOrThrow: {
                    args: verificationFindUniqueOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                findFirst: {
                    args: verificationFindFirstArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload> | null;
                };
                findFirstOrThrow: {
                    args: verificationFindFirstOrThrowArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                findMany: {
                    args: verificationFindManyArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>[];
                };
                create: {
                    args: verificationCreateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                createMany: {
                    args: verificationCreateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                createManyAndReturn: {
                    args: verificationCreateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>[];
                };
                delete: {
                    args: verificationDeleteArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                update: {
                    args: verificationUpdateArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                deleteMany: {
                    args: verificationDeleteManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateMany: {
                    args: verificationUpdateManyArgs<ExtArgs>;
                    result: BatchPayload;
                };
                updateManyAndReturn: {
                    args: verificationUpdateManyAndReturnArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>[];
                };
                upsert: {
                    args: verificationUpsertArgs<ExtArgs>;
                    result: runtime.Types.Utils.PayloadToResult<$verificationPayload>;
                };
                aggregate: {
                    args: VerificationAggregateArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<AggregateVerification>;
                };
                groupBy: {
                    args: verificationGroupByArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<VerificationGroupByOutputType>[];
                };
                count: {
                    args: verificationCountArgs<ExtArgs>;
                    result: runtime.Types.Utils.Optional<VerificationCountAggregateOutputType> | number;
                };
            };
        };
    };
} & {
    other: {
        payload: any;
        operations: {
            $executeRaw: {
                args: [query: TemplateStringsArray | Sql, ...values: any[]];
                result: any;
            };
            $executeRawUnsafe: {
                args: [query: string, ...values: any[]];
                result: any;
            };
            $queryRaw: {
                args: [query: TemplateStringsArray | Sql, ...values: any[]];
                result: any;
            };
            $queryRawUnsafe: {
                args: [query: string, ...values: any[]];
                result: any;
            };
        };
    };
};
/**
 * Enums
 */
declare const TransactionIsolationLevel: {
    readonly ReadUncommitted: "ReadUncommitted";
    readonly ReadCommitted: "ReadCommitted";
    readonly RepeatableRead: "RepeatableRead";
    readonly Serializable: "Serializable";
};
type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];
declare const AppointmentScalarFieldEnum: {
    readonly id: "id";
    readonly customerId: "customerId";
    readonly doctorId: "doctorId";
    readonly scheduleId: "scheduleId";
    readonly slotId: "slotId";
    readonly status: "status";
    readonly approvedSlotStart: "approvedSlotStart";
    readonly approvedSlotEnd: "approvedSlotEnd";
    readonly notes: "notes";
    readonly approvedBy: "approvedBy";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly tx_ref: "tx_ref";
    readonly hospitalId: "hospitalId";
    readonly isPaid: "isPaid";
};
type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum];
declare const AuditLogScalarFieldEnum: {
    readonly id: "id";
    readonly userId: "userId";
    readonly action: "action";
    readonly metadata: "metadata";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];
declare const DoctorScalarFieldEnum: {
    readonly id: "id";
    readonly userId: "userId";
    readonly yearsOfExperience: "yearsOfExperience";
    readonly bio: "bio";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly isDeactivated: "isDeactivated";
};
type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum];
declare const DoctorApplicationScalarFieldEnum: {
    readonly id: "id";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly userId: "userId";
    readonly hospitalId: "hospitalId";
    readonly yearsOfExperience: "yearsOfExperience";
    readonly bio: "bio";
    readonly status: "status";
    readonly specializationIds: "specializationIds";
};
type DoctorApplicationScalarFieldEnum = (typeof DoctorApplicationScalarFieldEnum)[keyof typeof DoctorApplicationScalarFieldEnum];
declare const DoctorHospitalProfileScalarFieldEnum: {
    readonly id: "id";
    readonly doctorId: "doctorId";
    readonly hospitalId: "hospitalId";
    readonly doctorType: "doctorType";
    readonly slotDuration: "slotDuration";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type DoctorHospitalProfileScalarFieldEnum = (typeof DoctorHospitalProfileScalarFieldEnum)[keyof typeof DoctorHospitalProfileScalarFieldEnum];
declare const DoctorSpecializationScalarFieldEnum: {
    readonly id: "id";
    readonly doctorId: "doctorId";
    readonly specializationId: "specializationId";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type DoctorSpecializationScalarFieldEnum = (typeof DoctorSpecializationScalarFieldEnum)[keyof typeof DoctorSpecializationScalarFieldEnum];
declare const HospitalScalarFieldEnum: {
    readonly id: "id";
    readonly adminId: "adminId";
    readonly name: "name";
    readonly description: "description";
    readonly address: "address";
    readonly city: "city";
    readonly latitude: "latitude";
    readonly longitude: "longitude";
    readonly phone: "phone";
    readonly email: "email";
    readonly website: "website";
    readonly openTime: "openTime";
    readonly closeTime: "closeTime";
    readonly is24Hours: "is24Hours";
    readonly emergencySupport: "emergencySupport";
    readonly rating: "rating";
    readonly reviewCount: "reviewCount";
    readonly logoUrl: "logoUrl";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly isDeactivated: "isDeactivated";
    readonly fee: "fee";
    readonly type: "type";
    readonly timezone: "timezone";
    readonly subAccountId: "subAccountId";
    readonly logoId: "logoId";
};
type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum];
declare const HospitalSpecializationScalarFieldEnum: {
    readonly id: "id";
    readonly hospitalId: "hospitalId";
    readonly specializationId: "specializationId";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type HospitalSpecializationScalarFieldEnum = (typeof HospitalSpecializationScalarFieldEnum)[keyof typeof HospitalSpecializationScalarFieldEnum];
declare const NotificationScalarFieldEnum: {
    readonly id: "id";
    readonly userId: "userId";
    readonly title: "title";
    readonly message: "message";
    readonly isRead: "isRead";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];
declare const PaymentScalarFieldEnum: {
    readonly id: "id";
    readonly appointmentId: "appointmentId";
    readonly customerId: "customerId";
    readonly amount: "amount";
    readonly status: "status";
    readonly method: "method";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];
declare const ReviewScalarFieldEnum: {
    readonly id: "id";
    readonly customerId: "customerId";
    readonly doctorId: "doctorId";
    readonly hospitalId: "hospitalId";
    readonly rating: "rating";
    readonly comment: "comment";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum];
declare const SavedDoctorHospitalScalarFieldEnum: {
    readonly id: "id";
    readonly userId: "userId";
    readonly doctorId: "doctorId";
    readonly hospitalId: "hospitalId";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type SavedDoctorHospitalScalarFieldEnum = (typeof SavedDoctorHospitalScalarFieldEnum)[keyof typeof SavedDoctorHospitalScalarFieldEnum];
declare const ScheduleScalarFieldEnum: {
    readonly id: "id";
    readonly type: "type";
    readonly startTime: "startTime";
    readonly endTime: "endTime";
    readonly status: "status";
    readonly createdBy: "createdBy";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly doctorId: "doctorId";
    readonly endDate: "endDate";
    readonly hospitalId: "hospitalId";
    readonly startDate: "startDate";
    readonly dayOfWeek: "dayOfWeek";
    readonly name: "name";
    readonly period: "period";
    readonly isDeactivated: "isDeactivated";
    readonly isExpired: "isExpired";
    readonly slotLastGeneratedDate: "slotLastGeneratedDate";
};
type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum];
declare const SearchLogScalarFieldEnum: {
    readonly id: "id";
    readonly userId: "userId";
    readonly query: "query";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type SearchLogScalarFieldEnum = (typeof SearchLogScalarFieldEnum)[keyof typeof SearchLogScalarFieldEnum];
declare const SlotScalarFieldEnum: {
    readonly id: "id";
    readonly scheduleId: "scheduleId";
    readonly slotStart: "slotStart";
    readonly slotEnd: "slotEnd";
    readonly status: "status";
    readonly appointmentId: "appointmentId";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly date: "date";
};
type SlotScalarFieldEnum = (typeof SlotScalarFieldEnum)[keyof typeof SlotScalarFieldEnum];
declare const SpecializationScalarFieldEnum: {
    readonly id: "id";
    readonly name: "name";
    readonly createdAt: "createdAt";
    readonly description: "description";
    readonly imageURL: "imageURL";
    readonly slug: "slug";
    readonly updatedAt: "updatedAt";
};
type SpecializationScalarFieldEnum = (typeof SpecializationScalarFieldEnum)[keyof typeof SpecializationScalarFieldEnum];
declare const UserScalarFieldEnum: {
    readonly id: "id";
    readonly fullName: "fullName";
    readonly email: "email";
    readonly emailVerified: "emailVerified";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly phoneNumber: "phoneNumber";
    readonly phoneNumberVerified: "phoneNumberVerified";
    readonly gender: "gender";
    readonly role: "role";
    readonly dateOfBirth: "dateOfBirth";
    readonly imageUrl: "imageUrl";
    readonly imageId: "imageId";
    readonly banned: "banned";
    readonly isOnboardingComplete: "isOnboardingComplete";
};
type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];
declare const AccountScalarFieldEnum: {
    readonly id: "id";
    readonly accountId: "accountId";
    readonly providerId: "providerId";
    readonly userId: "userId";
    readonly accessToken: "accessToken";
    readonly refreshToken: "refreshToken";
    readonly idToken: "idToken";
    readonly accessTokenExpiresAt: "accessTokenExpiresAt";
    readonly refreshTokenExpiresAt: "refreshTokenExpiresAt";
    readonly scope: "scope";
    readonly password: "password";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];
declare const SessionScalarFieldEnum: {
    readonly id: "id";
    readonly expiresAt: "expiresAt";
    readonly token: "token";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
    readonly ipAddress: "ipAddress";
    readonly userAgent: "userAgent";
    readonly userId: "userId";
};
type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];
declare const VerificationScalarFieldEnum: {
    readonly id: "id";
    readonly identifier: "identifier";
    readonly value: "value";
    readonly expiresAt: "expiresAt";
    readonly createdAt: "createdAt";
    readonly updatedAt: "updatedAt";
};
type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum];
declare const SortOrder: {
    readonly asc: "asc";
    readonly desc: "desc";
};
type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
declare const NullableJsonNullValueInput: {
    readonly DbNull: runtime.DbNullClass;
    readonly JsonNull: runtime.JsonNullClass;
};
type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];
declare const QueryMode: {
    readonly default: "default";
    readonly insensitive: "insensitive";
};
type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];
declare const NullsOrder: {
    readonly first: "first";
    readonly last: "last";
};
type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];
declare const JsonNullValueFilter: {
    readonly DbNull: runtime.DbNullClass;
    readonly JsonNull: runtime.JsonNullClass;
    readonly AnyNull: runtime.AnyNullClass;
};
type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];
/**
 * Field references
 */
/**
 * Reference to a field of type 'String'
 */
type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;
/**
 * Reference to a field of type 'String[]'
 */
type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;
/**
 * Reference to a field of type 'AppointmentStatus'
 */
type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>;
/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>;
/**
 * Reference to a field of type 'DateTime'
 */
type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;
/**
 * Reference to a field of type 'DateTime[]'
 */
type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>;
/**
 * Reference to a field of type 'Boolean'
 */
type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;
/**
 * Reference to a field of type 'Json'
 */
type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;
/**
 * Reference to a field of type 'QueryMode'
 */
type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>;
/**
 * Reference to a field of type 'Int'
 */
type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;
/**
 * Reference to a field of type 'Int[]'
 */
type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;
/**
 * Reference to a field of type 'DoctorApplicationStatus'
 */
type EnumDoctorApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DoctorApplicationStatus'>;
/**
 * Reference to a field of type 'DoctorApplicationStatus[]'
 */
type ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DoctorApplicationStatus[]'>;
/**
 * Reference to a field of type 'DoctorType'
 */
type EnumDoctorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DoctorType'>;
/**
 * Reference to a field of type 'DoctorType[]'
 */
type ListEnumDoctorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DoctorType[]'>;
/**
 * Reference to a field of type 'Decimal'
 */
type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>;
/**
 * Reference to a field of type 'Decimal[]'
 */
type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>;
/**
 * Reference to a field of type 'HospitalType'
 */
type EnumHospitalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HospitalType'>;
/**
 * Reference to a field of type 'HospitalType[]'
 */
type ListEnumHospitalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HospitalType[]'>;
/**
 * Reference to a field of type 'ScheduleType'
 */
type EnumScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleType'>;
/**
 * Reference to a field of type 'ScheduleType[]'
 */
type ListEnumScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleType[]'>;
/**
 * Reference to a field of type 'ScheduleStatus'
 */
type EnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus'>;
/**
 * Reference to a field of type 'ScheduleStatus[]'
 */
type ListEnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus[]'>;
/**
 * Reference to a field of type 'SchedulePeriod'
 */
type EnumSchedulePeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchedulePeriod'>;
/**
 * Reference to a field of type 'SchedulePeriod[]'
 */
type ListEnumSchedulePeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchedulePeriod[]'>;
/**
 * Reference to a field of type 'SlotStatus'
 */
type EnumSlotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotStatus'>;
/**
 * Reference to a field of type 'SlotStatus[]'
 */
type ListEnumSlotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotStatus[]'>;
/**
 * Reference to a field of type 'Role'
 */
type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>;
/**
 * Reference to a field of type 'Role[]'
 */
type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>;
/**
 * Reference to a field of type 'Float'
 */
type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;
/**
 * Reference to a field of type 'Float[]'
 */
type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;
/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
type BatchPayload = {
    count: number;
};
declare const defineExtension: runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>;
type DefaultPrismaClient = PrismaClient;
type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
type PrismaClientOptions = ({
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
     */
    adapter: runtime.SqlDriverAdapterFactory;
    accelerateUrl?: never;
} | {
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl: string;
    adapter?: never;
}) & {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
};
type GlobalOmitConfig = {
    appointment?: AppointmentOmit;
    auditLog?: AuditLogOmit;
    doctor?: DoctorOmit;
    doctorApplication?: DoctorApplicationOmit;
    doctorHospitalProfile?: DoctorHospitalProfileOmit;
    doctorSpecialization?: DoctorSpecializationOmit;
    hospital?: HospitalOmit;
    hospitalSpecialization?: HospitalSpecializationOmit;
    notification?: NotificationOmit;
    payment?: PaymentOmit;
    review?: ReviewOmit;
    savedDoctorHospital?: SavedDoctorHospitalOmit;
    schedule?: ScheduleOmit;
    searchLog?: SearchLogOmit;
    slot?: SlotOmit;
    specialization?: SpecializationOmit;
    user?: UserOmit;
    account?: accountOmit;
    session?: sessionOmit;
    verification?: verificationOmit;
};
type LogLevel = 'info' | 'query' | 'warn' | 'error';
type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
};
type CheckIsLogLevel<T> = T extends LogLevel ? T : never;
type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>;
type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;
type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
};
type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
};
type PrismaAction = 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'executeRaw' | 'queryRaw' | 'aggregate' | 'count' | 'runCommandRaw' | 'findRaw' | 'groupBy';
/**
 * `PrismaClient` proxy available in interactive transactions.
 */
type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>;

type prismaNamespace_$AppointmentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $AppointmentPayload<ExtArgs>;
type prismaNamespace_$AuditLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $AuditLogPayload<ExtArgs>;
type prismaNamespace_$DoctorApplicationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $DoctorApplicationPayload<ExtArgs>;
type prismaNamespace_$DoctorHospitalProfilePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $DoctorHospitalProfilePayload<ExtArgs>;
type prismaNamespace_$DoctorPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $DoctorPayload<ExtArgs>;
type prismaNamespace_$DoctorSpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $DoctorSpecializationPayload<ExtArgs>;
type prismaNamespace_$HospitalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $HospitalPayload<ExtArgs>;
type prismaNamespace_$HospitalSpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $HospitalSpecializationPayload<ExtArgs>;
type prismaNamespace_$NotificationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $NotificationPayload<ExtArgs>;
type prismaNamespace_$PaymentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $PaymentPayload<ExtArgs>;
type prismaNamespace_$ReviewPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $ReviewPayload<ExtArgs>;
type prismaNamespace_$SavedDoctorHospitalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $SavedDoctorHospitalPayload<ExtArgs>;
type prismaNamespace_$SchedulePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $SchedulePayload<ExtArgs>;
type prismaNamespace_$SearchLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $SearchLogPayload<ExtArgs>;
type prismaNamespace_$SlotPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $SlotPayload<ExtArgs>;
type prismaNamespace_$SpecializationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $SpecializationPayload<ExtArgs>;
type prismaNamespace_$UserPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $UserPayload<ExtArgs>;
type prismaNamespace_$accountPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $accountPayload<ExtArgs>;
type prismaNamespace_$sessionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $sessionPayload<ExtArgs>;
type prismaNamespace_$verificationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $verificationPayload<ExtArgs>;
type prismaNamespace_AccountAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AccountAggregateArgs<ExtArgs>;
type prismaNamespace_AccountCountAggregateInputType = AccountCountAggregateInputType;
type prismaNamespace_AccountCountAggregateOutputType = AccountCountAggregateOutputType;
type prismaNamespace_AccountGroupByOutputType = AccountGroupByOutputType;
type prismaNamespace_AccountListRelationFilter = AccountListRelationFilter;
type prismaNamespace_AccountMaxAggregateInputType = AccountMaxAggregateInputType;
type prismaNamespace_AccountMaxAggregateOutputType = AccountMaxAggregateOutputType;
type prismaNamespace_AccountMinAggregateInputType = AccountMinAggregateInputType;
type prismaNamespace_AccountMinAggregateOutputType = AccountMinAggregateOutputType;
type prismaNamespace_AccountScalarFieldEnum = AccountScalarFieldEnum;
type prismaNamespace_AggregateAccount = AggregateAccount;
type prismaNamespace_AggregateAppointment = AggregateAppointment;
type prismaNamespace_AggregateAuditLog = AggregateAuditLog;
type prismaNamespace_AggregateDoctor = AggregateDoctor;
type prismaNamespace_AggregateDoctorApplication = AggregateDoctorApplication;
type prismaNamespace_AggregateDoctorHospitalProfile = AggregateDoctorHospitalProfile;
type prismaNamespace_AggregateDoctorSpecialization = AggregateDoctorSpecialization;
type prismaNamespace_AggregateHospital = AggregateHospital;
type prismaNamespace_AggregateHospitalSpecialization = AggregateHospitalSpecialization;
type prismaNamespace_AggregateNotification = AggregateNotification;
type prismaNamespace_AggregatePayment = AggregatePayment;
type prismaNamespace_AggregateReview = AggregateReview;
type prismaNamespace_AggregateSavedDoctorHospital = AggregateSavedDoctorHospital;
type prismaNamespace_AggregateSchedule = AggregateSchedule;
type prismaNamespace_AggregateSearchLog = AggregateSearchLog;
type prismaNamespace_AggregateSession = AggregateSession;
type prismaNamespace_AggregateSlot = AggregateSlot;
type prismaNamespace_AggregateSpecialization = AggregateSpecialization;
type prismaNamespace_AggregateUser = AggregateUser;
type prismaNamespace_AggregateVerification = AggregateVerification;
declare const prismaNamespace_AnyNull: typeof AnyNull;
type prismaNamespace_Appointment$PaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Appointment$PaymentArgs<ExtArgs>;
type prismaNamespace_Appointment$SlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Appointment$SlotArgs<ExtArgs>;
type prismaNamespace_Appointment$User_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Appointment$User_Appointment_approvedByToUserArgs<ExtArgs>;
type prismaNamespace_AppointmentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentAggregateArgs<ExtArgs>;
type prismaNamespace_AppointmentCountAggregateInputType = AppointmentCountAggregateInputType;
type prismaNamespace_AppointmentCountAggregateOutputType = AppointmentCountAggregateOutputType;
type prismaNamespace_AppointmentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentCountArgs<ExtArgs>;
type prismaNamespace_AppointmentCountOrderByAggregateInput = AppointmentCountOrderByAggregateInput;
type prismaNamespace_AppointmentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentCreateArgs<ExtArgs>;
type prismaNamespace_AppointmentCreateInput = AppointmentCreateInput;
type prismaNamespace_AppointmentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_AppointmentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentCreateManyArgs<ExtArgs>;
type prismaNamespace_AppointmentCreateManyDoctorInput = AppointmentCreateManyDoctorInput;
type prismaNamespace_AppointmentCreateManyDoctorInputEnvelope = AppointmentCreateManyDoctorInputEnvelope;
type prismaNamespace_AppointmentCreateManyHospitalInput = AppointmentCreateManyHospitalInput;
type prismaNamespace_AppointmentCreateManyHospitalInputEnvelope = AppointmentCreateManyHospitalInputEnvelope;
type prismaNamespace_AppointmentCreateManyInput = AppointmentCreateManyInput;
type prismaNamespace_AppointmentCreateManyScheduleInput = AppointmentCreateManyScheduleInput;
type prismaNamespace_AppointmentCreateManyScheduleInputEnvelope = AppointmentCreateManyScheduleInputEnvelope;
type prismaNamespace_AppointmentCreateManyUser_Appointment_approvedByToUserInput = AppointmentCreateManyUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope = AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope;
type prismaNamespace_AppointmentCreateManyUser_Appointment_customerIdToUserInput = AppointmentCreateManyUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope = AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope;
type prismaNamespace_AppointmentCreateNestedManyWithoutDoctorInput = AppointmentCreateNestedManyWithoutDoctorInput;
type prismaNamespace_AppointmentCreateNestedManyWithoutHospitalInput = AppointmentCreateNestedManyWithoutHospitalInput;
type prismaNamespace_AppointmentCreateNestedManyWithoutScheduleInput = AppointmentCreateNestedManyWithoutScheduleInput;
type prismaNamespace_AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput = AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput = AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentCreateNestedOneWithoutPaymentInput = AppointmentCreateNestedOneWithoutPaymentInput;
type prismaNamespace_AppointmentCreateNestedOneWithoutSlotInput = AppointmentCreateNestedOneWithoutSlotInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutDoctorInput = AppointmentCreateOrConnectWithoutDoctorInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutHospitalInput = AppointmentCreateOrConnectWithoutHospitalInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutPaymentInput = AppointmentCreateOrConnectWithoutPaymentInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutScheduleInput = AppointmentCreateOrConnectWithoutScheduleInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutSlotInput = AppointmentCreateOrConnectWithoutSlotInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput = AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput = AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentCreateWithoutDoctorInput = AppointmentCreateWithoutDoctorInput;
type prismaNamespace_AppointmentCreateWithoutHospitalInput = AppointmentCreateWithoutHospitalInput;
type prismaNamespace_AppointmentCreateWithoutPaymentInput = AppointmentCreateWithoutPaymentInput;
type prismaNamespace_AppointmentCreateWithoutScheduleInput = AppointmentCreateWithoutScheduleInput;
type prismaNamespace_AppointmentCreateWithoutSlotInput = AppointmentCreateWithoutSlotInput;
type prismaNamespace_AppointmentCreateWithoutUser_Appointment_approvedByToUserInput = AppointmentCreateWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentCreateWithoutUser_Appointment_customerIdToUserInput = AppointmentCreateWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>;
type prismaNamespace_AppointmentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = AppointmentDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_AppointmentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentDeleteArgs<ExtArgs>;
type prismaNamespace_AppointmentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentDeleteManyArgs<ExtArgs>;
type prismaNamespace_AppointmentFieldRefs = AppointmentFieldRefs;
type prismaNamespace_AppointmentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentFindFirstArgs<ExtArgs>;
type prismaNamespace_AppointmentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_AppointmentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentFindManyArgs<ExtArgs>;
type prismaNamespace_AppointmentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentFindUniqueArgs<ExtArgs>;
type prismaNamespace_AppointmentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = AppointmentGetPayload<S>;
type prismaNamespace_AppointmentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentGroupByArgs<ExtArgs>;
type prismaNamespace_AppointmentGroupByOutputType = AppointmentGroupByOutputType;
type prismaNamespace_AppointmentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentInclude<ExtArgs>;
type prismaNamespace_AppointmentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_AppointmentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_AppointmentListRelationFilter = AppointmentListRelationFilter;
type prismaNamespace_AppointmentMaxAggregateInputType = AppointmentMaxAggregateInputType;
type prismaNamespace_AppointmentMaxAggregateOutputType = AppointmentMaxAggregateOutputType;
type prismaNamespace_AppointmentMaxOrderByAggregateInput = AppointmentMaxOrderByAggregateInput;
type prismaNamespace_AppointmentMinAggregateInputType = AppointmentMinAggregateInputType;
type prismaNamespace_AppointmentMinAggregateOutputType = AppointmentMinAggregateOutputType;
type prismaNamespace_AppointmentMinOrderByAggregateInput = AppointmentMinOrderByAggregateInput;
type prismaNamespace_AppointmentModel = AppointmentModel;
type prismaNamespace_AppointmentNullableScalarRelationFilter = AppointmentNullableScalarRelationFilter;
type prismaNamespace_AppointmentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentOmit<ExtArgs>;
type prismaNamespace_AppointmentOrderByRelationAggregateInput = AppointmentOrderByRelationAggregateInput;
type prismaNamespace_AppointmentOrderByWithAggregationInput = AppointmentOrderByWithAggregationInput;
type prismaNamespace_AppointmentOrderByWithRelationInput = AppointmentOrderByWithRelationInput;
type prismaNamespace_AppointmentScalarFieldEnum = AppointmentScalarFieldEnum;
type prismaNamespace_AppointmentScalarRelationFilter = AppointmentScalarRelationFilter;
type prismaNamespace_AppointmentScalarWhereInput = AppointmentScalarWhereInput;
type prismaNamespace_AppointmentScalarWhereWithAggregatesInput = AppointmentScalarWhereWithAggregatesInput;
type prismaNamespace_AppointmentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentSelect<ExtArgs>;
type prismaNamespace_AppointmentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_AppointmentSelectScalar = AppointmentSelectScalar;
type prismaNamespace_AppointmentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_AppointmentUncheckedCreateInput = AppointmentUncheckedCreateInput;
type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutDoctorInput = AppointmentUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutHospitalInput = AppointmentUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutScheduleInput = AppointmentUncheckedCreateNestedManyWithoutScheduleInput;
type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput = AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput = AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutDoctorInput = AppointmentUncheckedCreateWithoutDoctorInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutHospitalInput = AppointmentUncheckedCreateWithoutHospitalInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutPaymentInput = AppointmentUncheckedCreateWithoutPaymentInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutScheduleInput = AppointmentUncheckedCreateWithoutScheduleInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutSlotInput = AppointmentUncheckedCreateWithoutSlotInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput = AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput = AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUncheckedUpdateInput = AppointmentUncheckedUpdateInput;
type prismaNamespace_AppointmentUncheckedUpdateManyInput = AppointmentUncheckedUpdateManyInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutDoctorInput = AppointmentUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = AppointmentUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutHospitalInput = AppointmentUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutHospitalNestedInput = AppointmentUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutScheduleInput = AppointmentUncheckedUpdateManyWithoutScheduleInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutScheduleNestedInput = AppointmentUncheckedUpdateManyWithoutScheduleNestedInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput = AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput = AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput = AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput = AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutDoctorInput = AppointmentUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutHospitalInput = AppointmentUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutPaymentInput = AppointmentUncheckedUpdateWithoutPaymentInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutScheduleInput = AppointmentUncheckedUpdateWithoutScheduleInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutSlotInput = AppointmentUncheckedUpdateWithoutSlotInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput = AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput = AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentUpdateArgs<ExtArgs>;
type prismaNamespace_AppointmentUpdateInput = AppointmentUpdateInput;
type prismaNamespace_AppointmentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_AppointmentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentUpdateManyArgs<ExtArgs>;
type prismaNamespace_AppointmentUpdateManyMutationInput = AppointmentUpdateManyMutationInput;
type prismaNamespace_AppointmentUpdateManyWithWhereWithoutDoctorInput = AppointmentUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_AppointmentUpdateManyWithWhereWithoutHospitalInput = AppointmentUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_AppointmentUpdateManyWithWhereWithoutScheduleInput = AppointmentUpdateManyWithWhereWithoutScheduleInput;
type prismaNamespace_AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput = AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput = AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUpdateManyWithoutDoctorNestedInput = AppointmentUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_AppointmentUpdateManyWithoutHospitalNestedInput = AppointmentUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_AppointmentUpdateManyWithoutScheduleNestedInput = AppointmentUpdateManyWithoutScheduleNestedInput;
type prismaNamespace_AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput = AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput;
type prismaNamespace_AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput = AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput;
type prismaNamespace_AppointmentUpdateOneRequiredWithoutPaymentNestedInput = AppointmentUpdateOneRequiredWithoutPaymentNestedInput;
type prismaNamespace_AppointmentUpdateOneWithoutSlotNestedInput = AppointmentUpdateOneWithoutSlotNestedInput;
type prismaNamespace_AppointmentUpdateToOneWithWhereWithoutPaymentInput = AppointmentUpdateToOneWithWhereWithoutPaymentInput;
type prismaNamespace_AppointmentUpdateToOneWithWhereWithoutSlotInput = AppointmentUpdateToOneWithWhereWithoutSlotInput;
type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutDoctorInput = AppointmentUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutHospitalInput = AppointmentUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutScheduleInput = AppointmentUpdateWithWhereUniqueWithoutScheduleInput;
type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput = AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput = AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUpdateWithoutDoctorInput = AppointmentUpdateWithoutDoctorInput;
type prismaNamespace_AppointmentUpdateWithoutHospitalInput = AppointmentUpdateWithoutHospitalInput;
type prismaNamespace_AppointmentUpdateWithoutPaymentInput = AppointmentUpdateWithoutPaymentInput;
type prismaNamespace_AppointmentUpdateWithoutScheduleInput = AppointmentUpdateWithoutScheduleInput;
type prismaNamespace_AppointmentUpdateWithoutSlotInput = AppointmentUpdateWithoutSlotInput;
type prismaNamespace_AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput = AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput = AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AppointmentUpsertArgs<ExtArgs>;
type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutDoctorInput = AppointmentUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutHospitalInput = AppointmentUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutScheduleInput = AppointmentUpsertWithWhereUniqueWithoutScheduleInput;
type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput = AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput;
type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput = AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput;
type prismaNamespace_AppointmentUpsertWithoutPaymentInput = AppointmentUpsertWithoutPaymentInput;
type prismaNamespace_AppointmentUpsertWithoutSlotInput = AppointmentUpsertWithoutSlotInput;
type prismaNamespace_AppointmentWhereInput = AppointmentWhereInput;
type prismaNamespace_AppointmentWhereUniqueInput = AppointmentWhereUniqueInput;
type prismaNamespace_Args<T, F extends runtime.Operation> = Args<T, F>;
type prismaNamespace_At<O extends object, K extends Key, strict extends Boolean = 1> = At<O, K, strict>;
type prismaNamespace_AtLeast<O extends object, K extends string> = AtLeast<O, K>;
type prismaNamespace_AuditLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogAggregateArgs<ExtArgs>;
type prismaNamespace_AuditLogCountAggregateInputType = AuditLogCountAggregateInputType;
type prismaNamespace_AuditLogCountAggregateOutputType = AuditLogCountAggregateOutputType;
type prismaNamespace_AuditLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogCountArgs<ExtArgs>;
type prismaNamespace_AuditLogCountOrderByAggregateInput = AuditLogCountOrderByAggregateInput;
type prismaNamespace_AuditLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogCreateArgs<ExtArgs>;
type prismaNamespace_AuditLogCreateInput = AuditLogCreateInput;
type prismaNamespace_AuditLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_AuditLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogCreateManyArgs<ExtArgs>;
type prismaNamespace_AuditLogCreateManyInput = AuditLogCreateManyInput;
type prismaNamespace_AuditLogCreateManyUserInput = AuditLogCreateManyUserInput;
type prismaNamespace_AuditLogCreateManyUserInputEnvelope = AuditLogCreateManyUserInputEnvelope;
type prismaNamespace_AuditLogCreateNestedManyWithoutUserInput = AuditLogCreateNestedManyWithoutUserInput;
type prismaNamespace_AuditLogCreateOrConnectWithoutUserInput = AuditLogCreateOrConnectWithoutUserInput;
type prismaNamespace_AuditLogCreateWithoutUserInput = AuditLogCreateWithoutUserInput;
type prismaNamespace_AuditLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>;
type prismaNamespace_AuditLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = AuditLogDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_AuditLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogDeleteArgs<ExtArgs>;
type prismaNamespace_AuditLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogDeleteManyArgs<ExtArgs>;
type prismaNamespace_AuditLogFieldRefs = AuditLogFieldRefs;
type prismaNamespace_AuditLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogFindFirstArgs<ExtArgs>;
type prismaNamespace_AuditLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_AuditLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogFindManyArgs<ExtArgs>;
type prismaNamespace_AuditLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogFindUniqueArgs<ExtArgs>;
type prismaNamespace_AuditLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = AuditLogGetPayload<S>;
type prismaNamespace_AuditLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogGroupByArgs<ExtArgs>;
type prismaNamespace_AuditLogGroupByOutputType = AuditLogGroupByOutputType;
type prismaNamespace_AuditLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogInclude<ExtArgs>;
type prismaNamespace_AuditLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_AuditLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_AuditLogListRelationFilter = AuditLogListRelationFilter;
type prismaNamespace_AuditLogMaxAggregateInputType = AuditLogMaxAggregateInputType;
type prismaNamespace_AuditLogMaxAggregateOutputType = AuditLogMaxAggregateOutputType;
type prismaNamespace_AuditLogMaxOrderByAggregateInput = AuditLogMaxOrderByAggregateInput;
type prismaNamespace_AuditLogMinAggregateInputType = AuditLogMinAggregateInputType;
type prismaNamespace_AuditLogMinAggregateOutputType = AuditLogMinAggregateOutputType;
type prismaNamespace_AuditLogMinOrderByAggregateInput = AuditLogMinOrderByAggregateInput;
type prismaNamespace_AuditLogModel = AuditLogModel;
type prismaNamespace_AuditLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogOmit<ExtArgs>;
type prismaNamespace_AuditLogOrderByRelationAggregateInput = AuditLogOrderByRelationAggregateInput;
type prismaNamespace_AuditLogOrderByWithAggregationInput = AuditLogOrderByWithAggregationInput;
type prismaNamespace_AuditLogOrderByWithRelationInput = AuditLogOrderByWithRelationInput;
type prismaNamespace_AuditLogScalarFieldEnum = AuditLogScalarFieldEnum;
type prismaNamespace_AuditLogScalarWhereInput = AuditLogScalarWhereInput;
type prismaNamespace_AuditLogScalarWhereWithAggregatesInput = AuditLogScalarWhereWithAggregatesInput;
type prismaNamespace_AuditLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogSelect<ExtArgs>;
type prismaNamespace_AuditLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_AuditLogSelectScalar = AuditLogSelectScalar;
type prismaNamespace_AuditLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_AuditLogUncheckedCreateInput = AuditLogUncheckedCreateInput;
type prismaNamespace_AuditLogUncheckedCreateNestedManyWithoutUserInput = AuditLogUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_AuditLogUncheckedCreateWithoutUserInput = AuditLogUncheckedCreateWithoutUserInput;
type prismaNamespace_AuditLogUncheckedUpdateInput = AuditLogUncheckedUpdateInput;
type prismaNamespace_AuditLogUncheckedUpdateManyInput = AuditLogUncheckedUpdateManyInput;
type prismaNamespace_AuditLogUncheckedUpdateManyWithoutUserInput = AuditLogUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_AuditLogUncheckedUpdateManyWithoutUserNestedInput = AuditLogUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_AuditLogUncheckedUpdateWithoutUserInput = AuditLogUncheckedUpdateWithoutUserInput;
type prismaNamespace_AuditLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogUpdateArgs<ExtArgs>;
type prismaNamespace_AuditLogUpdateInput = AuditLogUpdateInput;
type prismaNamespace_AuditLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_AuditLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogUpdateManyArgs<ExtArgs>;
type prismaNamespace_AuditLogUpdateManyMutationInput = AuditLogUpdateManyMutationInput;
type prismaNamespace_AuditLogUpdateManyWithWhereWithoutUserInput = AuditLogUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_AuditLogUpdateManyWithoutUserNestedInput = AuditLogUpdateManyWithoutUserNestedInput;
type prismaNamespace_AuditLogUpdateWithWhereUniqueWithoutUserInput = AuditLogUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_AuditLogUpdateWithoutUserInput = AuditLogUpdateWithoutUserInput;
type prismaNamespace_AuditLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = AuditLogUpsertArgs<ExtArgs>;
type prismaNamespace_AuditLogUpsertWithWhereUniqueWithoutUserInput = AuditLogUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_AuditLogWhereInput = AuditLogWhereInput;
type prismaNamespace_AuditLogWhereUniqueInput = AuditLogWhereUniqueInput;
type prismaNamespace_BatchPayload = BatchPayload;
type prismaNamespace_BoolFieldUpdateOperationsInput = BoolFieldUpdateOperationsInput;
type prismaNamespace_BoolFilter<$PrismaModel = never> = BoolFilter<$PrismaModel>;
type prismaNamespace_BoolNullableFilter<$PrismaModel = never> = BoolNullableFilter<$PrismaModel>;
type prismaNamespace_BoolNullableWithAggregatesFilter<$PrismaModel = never> = BoolNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_BoolWithAggregatesFilter<$PrismaModel = never> = BoolWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_Boolean = Boolean;
type prismaNamespace_BooleanFieldRefInput<$PrismaModel> = BooleanFieldRefInput<$PrismaModel>;
type prismaNamespace_Bytes = Bytes;
type prismaNamespace_CheckIsLogLevel<T> = CheckIsLogLevel<T>;
type prismaNamespace_ComputeRaw<A extends any> = ComputeRaw<A>;
type prismaNamespace_DMMF = DMMF;
type prismaNamespace_DateTimeFieldRefInput<$PrismaModel> = DateTimeFieldRefInput<$PrismaModel>;
type prismaNamespace_DateTimeFieldUpdateOperationsInput = DateTimeFieldUpdateOperationsInput;
type prismaNamespace_DateTimeFilter<$PrismaModel = never> = DateTimeFilter<$PrismaModel>;
type prismaNamespace_DateTimeNullableFilter<$PrismaModel = never> = DateTimeNullableFilter<$PrismaModel>;
type prismaNamespace_DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = DateTimeNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_DateTimeWithAggregatesFilter<$PrismaModel = never> = DateTimeWithAggregatesFilter<$PrismaModel>;
declare const prismaNamespace_DbNull: typeof DbNull;
type prismaNamespace_Decimal = Decimal;
type prismaNamespace_DecimalFieldRefInput<$PrismaModel> = DecimalFieldRefInput<$PrismaModel>;
type prismaNamespace_DecimalFieldUpdateOperationsInput = DecimalFieldUpdateOperationsInput;
type prismaNamespace_DecimalFilter<$PrismaModel = never> = DecimalFilter<$PrismaModel>;
type prismaNamespace_DecimalJsLike = DecimalJsLike;
type prismaNamespace_DecimalNullableFilter<$PrismaModel = never> = DecimalNullableFilter<$PrismaModel>;
type prismaNamespace_DecimalNullableWithAggregatesFilter<$PrismaModel = never> = DecimalNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_DecimalWithAggregatesFilter<$PrismaModel = never> = DecimalWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_DefaultPrismaClient = DefaultPrismaClient;
type prismaNamespace_Doctor$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$AppointmentArgs<ExtArgs>;
type prismaNamespace_Doctor$DoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$DoctorHospitalProfileArgs<ExtArgs>;
type prismaNamespace_Doctor$DoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$DoctorSpecializationArgs<ExtArgs>;
type prismaNamespace_Doctor$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$ReviewArgs<ExtArgs>;
type prismaNamespace_Doctor$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$SavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_Doctor$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Doctor$ScheduleArgs<ExtArgs>;
type prismaNamespace_DoctorAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorAggregateArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationAggregateArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationAvgAggregateInputType = DoctorApplicationAvgAggregateInputType;
type prismaNamespace_DoctorApplicationAvgAggregateOutputType = DoctorApplicationAvgAggregateOutputType;
type prismaNamespace_DoctorApplicationAvgOrderByAggregateInput = DoctorApplicationAvgOrderByAggregateInput;
type prismaNamespace_DoctorApplicationCountAggregateInputType = DoctorApplicationCountAggregateInputType;
type prismaNamespace_DoctorApplicationCountAggregateOutputType = DoctorApplicationCountAggregateOutputType;
type prismaNamespace_DoctorApplicationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationCountArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationCountOrderByAggregateInput = DoctorApplicationCountOrderByAggregateInput;
type prismaNamespace_DoctorApplicationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationCreateArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationCreateInput = DoctorApplicationCreateInput;
type prismaNamespace_DoctorApplicationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationCreateManyArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationCreateManyHospitalInput = DoctorApplicationCreateManyHospitalInput;
type prismaNamespace_DoctorApplicationCreateManyHospitalInputEnvelope = DoctorApplicationCreateManyHospitalInputEnvelope;
type prismaNamespace_DoctorApplicationCreateManyInput = DoctorApplicationCreateManyInput;
type prismaNamespace_DoctorApplicationCreateManyUserInput = DoctorApplicationCreateManyUserInput;
type prismaNamespace_DoctorApplicationCreateManyUserInputEnvelope = DoctorApplicationCreateManyUserInputEnvelope;
type prismaNamespace_DoctorApplicationCreateNestedManyWithoutHospitalInput = DoctorApplicationCreateNestedManyWithoutHospitalInput;
type prismaNamespace_DoctorApplicationCreateNestedManyWithoutUserInput = DoctorApplicationCreateNestedManyWithoutUserInput;
type prismaNamespace_DoctorApplicationCreateOrConnectWithoutHospitalInput = DoctorApplicationCreateOrConnectWithoutHospitalInput;
type prismaNamespace_DoctorApplicationCreateOrConnectWithoutUserInput = DoctorApplicationCreateOrConnectWithoutUserInput;
type prismaNamespace_DoctorApplicationCreateWithoutHospitalInput = DoctorApplicationCreateWithoutHospitalInput;
type prismaNamespace_DoctorApplicationCreateWithoutUserInput = DoctorApplicationCreateWithoutUserInput;
type prismaNamespace_DoctorApplicationCreatespecializationIdsInput = DoctorApplicationCreatespecializationIdsInput;
type prismaNamespace_DoctorApplicationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationDefaultArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = DoctorApplicationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_DoctorApplicationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationDeleteArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationDeleteManyArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationFieldRefs = DoctorApplicationFieldRefs;
type prismaNamespace_DoctorApplicationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationFindFirstArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationFindManyArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationFindUniqueArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationGetPayload<S extends boolean | null | undefined | DoctorApplicationDefaultArgs> = DoctorApplicationGetPayload<S>;
type prismaNamespace_DoctorApplicationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationGroupByArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationGroupByOutputType = DoctorApplicationGroupByOutputType;
type prismaNamespace_DoctorApplicationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationInclude<ExtArgs>;
type prismaNamespace_DoctorApplicationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorApplicationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorApplicationListRelationFilter = DoctorApplicationListRelationFilter;
type prismaNamespace_DoctorApplicationMaxAggregateInputType = DoctorApplicationMaxAggregateInputType;
type prismaNamespace_DoctorApplicationMaxAggregateOutputType = DoctorApplicationMaxAggregateOutputType;
type prismaNamespace_DoctorApplicationMaxOrderByAggregateInput = DoctorApplicationMaxOrderByAggregateInput;
type prismaNamespace_DoctorApplicationMinAggregateInputType = DoctorApplicationMinAggregateInputType;
type prismaNamespace_DoctorApplicationMinAggregateOutputType = DoctorApplicationMinAggregateOutputType;
type prismaNamespace_DoctorApplicationMinOrderByAggregateInput = DoctorApplicationMinOrderByAggregateInput;
type prismaNamespace_DoctorApplicationModel = DoctorApplicationModel;
type prismaNamespace_DoctorApplicationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationOmit<ExtArgs>;
type prismaNamespace_DoctorApplicationOrderByRelationAggregateInput = DoctorApplicationOrderByRelationAggregateInput;
type prismaNamespace_DoctorApplicationOrderByWithAggregationInput = DoctorApplicationOrderByWithAggregationInput;
type prismaNamespace_DoctorApplicationOrderByWithRelationInput = DoctorApplicationOrderByWithRelationInput;
type prismaNamespace_DoctorApplicationScalarFieldEnum = DoctorApplicationScalarFieldEnum;
type prismaNamespace_DoctorApplicationScalarWhereInput = DoctorApplicationScalarWhereInput;
type prismaNamespace_DoctorApplicationScalarWhereWithAggregatesInput = DoctorApplicationScalarWhereWithAggregatesInput;
type prismaNamespace_DoctorApplicationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationSelect<ExtArgs>;
type prismaNamespace_DoctorApplicationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorApplicationSelectScalar = DoctorApplicationSelectScalar;
type prismaNamespace_DoctorApplicationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorApplicationSumAggregateInputType = DoctorApplicationSumAggregateInputType;
type prismaNamespace_DoctorApplicationSumAggregateOutputType = DoctorApplicationSumAggregateOutputType;
type prismaNamespace_DoctorApplicationSumOrderByAggregateInput = DoctorApplicationSumOrderByAggregateInput;
type prismaNamespace_DoctorApplicationUncheckedCreateInput = DoctorApplicationUncheckedCreateInput;
type prismaNamespace_DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput = DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUncheckedCreateNestedManyWithoutUserInput = DoctorApplicationUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_DoctorApplicationUncheckedCreateWithoutHospitalInput = DoctorApplicationUncheckedCreateWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUncheckedCreateWithoutUserInput = DoctorApplicationUncheckedCreateWithoutUserInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateInput = DoctorApplicationUncheckedUpdateInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateManyInput = DoctorApplicationUncheckedUpdateManyInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutHospitalInput = DoctorApplicationUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput = DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutUserInput = DoctorApplicationUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput = DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateWithoutHospitalInput = DoctorApplicationUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUncheckedUpdateWithoutUserInput = DoctorApplicationUncheckedUpdateWithoutUserInput;
type prismaNamespace_DoctorApplicationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationUpdateArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationUpdateInput = DoctorApplicationUpdateInput;
type prismaNamespace_DoctorApplicationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationUpdateManyArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationUpdateManyMutationInput = DoctorApplicationUpdateManyMutationInput;
type prismaNamespace_DoctorApplicationUpdateManyWithWhereWithoutHospitalInput = DoctorApplicationUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUpdateManyWithWhereWithoutUserInput = DoctorApplicationUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_DoctorApplicationUpdateManyWithoutHospitalNestedInput = DoctorApplicationUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_DoctorApplicationUpdateManyWithoutUserNestedInput = DoctorApplicationUpdateManyWithoutUserNestedInput;
type prismaNamespace_DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput = DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUpdateWithWhereUniqueWithoutUserInput = DoctorApplicationUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_DoctorApplicationUpdateWithoutHospitalInput = DoctorApplicationUpdateWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUpdateWithoutUserInput = DoctorApplicationUpdateWithoutUserInput;
type prismaNamespace_DoctorApplicationUpdatespecializationIdsInput = DoctorApplicationUpdatespecializationIdsInput;
type prismaNamespace_DoctorApplicationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorApplicationUpsertArgs<ExtArgs>;
type prismaNamespace_DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput = DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_DoctorApplicationUpsertWithWhereUniqueWithoutUserInput = DoctorApplicationUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_DoctorApplicationUserIdHospitalIdCompoundUniqueInput = DoctorApplicationUserIdHospitalIdCompoundUniqueInput;
type prismaNamespace_DoctorApplicationWhereInput = DoctorApplicationWhereInput;
type prismaNamespace_DoctorApplicationWhereUniqueInput = DoctorApplicationWhereUniqueInput;
type prismaNamespace_DoctorAvgAggregateInputType = DoctorAvgAggregateInputType;
type prismaNamespace_DoctorAvgAggregateOutputType = DoctorAvgAggregateOutputType;
type prismaNamespace_DoctorAvgOrderByAggregateInput = DoctorAvgOrderByAggregateInput;
type prismaNamespace_DoctorCountAggregateInputType = DoctorCountAggregateInputType;
type prismaNamespace_DoctorCountAggregateOutputType = DoctorCountAggregateOutputType;
type prismaNamespace_DoctorCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountArgs<ExtArgs>;
type prismaNamespace_DoctorCountOrderByAggregateInput = DoctorCountOrderByAggregateInput;
type prismaNamespace_DoctorCountOutputType = DoctorCountOutputType;
type prismaNamespace_DoctorCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountAppointmentArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeCountDoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountDoctorSpecializationArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountReviewArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeCountScheduleArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeDefaultArgs<ExtArgs>;
type prismaNamespace_DoctorCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCountOutputTypeSelect<ExtArgs>;
type prismaNamespace_DoctorCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCreateArgs<ExtArgs>;
type prismaNamespace_DoctorCreateInput = DoctorCreateInput;
type prismaNamespace_DoctorCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorCreateManyArgs<ExtArgs>;
type prismaNamespace_DoctorCreateManyInput = DoctorCreateManyInput;
type prismaNamespace_DoctorCreateNestedOneWithoutAppointmentInput = DoctorCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_DoctorCreateNestedOneWithoutDoctorHospitalProfileInput = DoctorCreateNestedOneWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorCreateNestedOneWithoutDoctorSpecializationInput = DoctorCreateNestedOneWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorCreateNestedOneWithoutReviewInput = DoctorCreateNestedOneWithoutReviewInput;
type prismaNamespace_DoctorCreateNestedOneWithoutSavedDoctorHospitalInput = DoctorCreateNestedOneWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorCreateNestedOneWithoutScheduleInput = DoctorCreateNestedOneWithoutScheduleInput;
type prismaNamespace_DoctorCreateNestedOneWithoutUserInput = DoctorCreateNestedOneWithoutUserInput;
type prismaNamespace_DoctorCreateOrConnectWithoutAppointmentInput = DoctorCreateOrConnectWithoutAppointmentInput;
type prismaNamespace_DoctorCreateOrConnectWithoutDoctorHospitalProfileInput = DoctorCreateOrConnectWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorCreateOrConnectWithoutDoctorSpecializationInput = DoctorCreateOrConnectWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorCreateOrConnectWithoutReviewInput = DoctorCreateOrConnectWithoutReviewInput;
type prismaNamespace_DoctorCreateOrConnectWithoutSavedDoctorHospitalInput = DoctorCreateOrConnectWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorCreateOrConnectWithoutScheduleInput = DoctorCreateOrConnectWithoutScheduleInput;
type prismaNamespace_DoctorCreateOrConnectWithoutUserInput = DoctorCreateOrConnectWithoutUserInput;
type prismaNamespace_DoctorCreateWithoutAppointmentInput = DoctorCreateWithoutAppointmentInput;
type prismaNamespace_DoctorCreateWithoutDoctorHospitalProfileInput = DoctorCreateWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorCreateWithoutDoctorSpecializationInput = DoctorCreateWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorCreateWithoutReviewInput = DoctorCreateWithoutReviewInput;
type prismaNamespace_DoctorCreateWithoutSavedDoctorHospitalInput = DoctorCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorCreateWithoutScheduleInput = DoctorCreateWithoutScheduleInput;
type prismaNamespace_DoctorCreateWithoutUserInput = DoctorCreateWithoutUserInput;
type prismaNamespace_DoctorDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorDefaultArgs<ExtArgs>;
type prismaNamespace_DoctorDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = DoctorDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_DoctorDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorDeleteArgs<ExtArgs>;
type prismaNamespace_DoctorDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorDeleteManyArgs<ExtArgs>;
type prismaNamespace_DoctorFieldRefs = DoctorFieldRefs;
type prismaNamespace_DoctorFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorFindFirstArgs<ExtArgs>;
type prismaNamespace_DoctorFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorFindManyArgs<ExtArgs>;
type prismaNamespace_DoctorFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorFindUniqueArgs<ExtArgs>;
type prismaNamespace_DoctorFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = DoctorGetPayload<S>;
type prismaNamespace_DoctorGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorGroupByArgs<ExtArgs>;
type prismaNamespace_DoctorGroupByOutputType = DoctorGroupByOutputType;
type prismaNamespace_DoctorHospitalProfileAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileAggregateArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileAvgAggregateInputType = DoctorHospitalProfileAvgAggregateInputType;
type prismaNamespace_DoctorHospitalProfileAvgAggregateOutputType = DoctorHospitalProfileAvgAggregateOutputType;
type prismaNamespace_DoctorHospitalProfileAvgOrderByAggregateInput = DoctorHospitalProfileAvgOrderByAggregateInput;
type prismaNamespace_DoctorHospitalProfileCountAggregateInputType = DoctorHospitalProfileCountAggregateInputType;
type prismaNamespace_DoctorHospitalProfileCountAggregateOutputType = DoctorHospitalProfileCountAggregateOutputType;
type prismaNamespace_DoctorHospitalProfileCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileCountArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileCountOrderByAggregateInput = DoctorHospitalProfileCountOrderByAggregateInput;
type prismaNamespace_DoctorHospitalProfileCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileCreateArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileCreateInput = DoctorHospitalProfileCreateInput;
type prismaNamespace_DoctorHospitalProfileCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileCreateManyArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileCreateManyDoctorInput = DoctorHospitalProfileCreateManyDoctorInput;
type prismaNamespace_DoctorHospitalProfileCreateManyDoctorInputEnvelope = DoctorHospitalProfileCreateManyDoctorInputEnvelope;
type prismaNamespace_DoctorHospitalProfileCreateManyHospitalInput = DoctorHospitalProfileCreateManyHospitalInput;
type prismaNamespace_DoctorHospitalProfileCreateManyHospitalInputEnvelope = DoctorHospitalProfileCreateManyHospitalInputEnvelope;
type prismaNamespace_DoctorHospitalProfileCreateManyInput = DoctorHospitalProfileCreateManyInput;
type prismaNamespace_DoctorHospitalProfileCreateNestedManyWithoutDoctorInput = DoctorHospitalProfileCreateNestedManyWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileCreateNestedManyWithoutHospitalInput = DoctorHospitalProfileCreateNestedManyWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileCreateOrConnectWithoutDoctorInput = DoctorHospitalProfileCreateOrConnectWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileCreateOrConnectWithoutHospitalInput = DoctorHospitalProfileCreateOrConnectWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileCreateWithoutDoctorInput = DoctorHospitalProfileCreateWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileCreateWithoutHospitalInput = DoctorHospitalProfileCreateWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileDefaultArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = DoctorHospitalProfileDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_DoctorHospitalProfileDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileDeleteArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileDeleteManyArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput = DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput;
type prismaNamespace_DoctorHospitalProfileFieldRefs = DoctorHospitalProfileFieldRefs;
type prismaNamespace_DoctorHospitalProfileFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileFindFirstArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileFindManyArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileFindUniqueArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileGetPayload<S extends boolean | null | undefined | DoctorHospitalProfileDefaultArgs> = DoctorHospitalProfileGetPayload<S>;
type prismaNamespace_DoctorHospitalProfileGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileGroupByArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileGroupByOutputType = DoctorHospitalProfileGroupByOutputType;
type prismaNamespace_DoctorHospitalProfileInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileInclude<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileListRelationFilter = DoctorHospitalProfileListRelationFilter;
type prismaNamespace_DoctorHospitalProfileMaxAggregateInputType = DoctorHospitalProfileMaxAggregateInputType;
type prismaNamespace_DoctorHospitalProfileMaxAggregateOutputType = DoctorHospitalProfileMaxAggregateOutputType;
type prismaNamespace_DoctorHospitalProfileMaxOrderByAggregateInput = DoctorHospitalProfileMaxOrderByAggregateInput;
type prismaNamespace_DoctorHospitalProfileMinAggregateInputType = DoctorHospitalProfileMinAggregateInputType;
type prismaNamespace_DoctorHospitalProfileMinAggregateOutputType = DoctorHospitalProfileMinAggregateOutputType;
type prismaNamespace_DoctorHospitalProfileMinOrderByAggregateInput = DoctorHospitalProfileMinOrderByAggregateInput;
type prismaNamespace_DoctorHospitalProfileModel = DoctorHospitalProfileModel;
type prismaNamespace_DoctorHospitalProfileOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileOmit<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileOrderByRelationAggregateInput = DoctorHospitalProfileOrderByRelationAggregateInput;
type prismaNamespace_DoctorHospitalProfileOrderByWithAggregationInput = DoctorHospitalProfileOrderByWithAggregationInput;
type prismaNamespace_DoctorHospitalProfileOrderByWithRelationInput = DoctorHospitalProfileOrderByWithRelationInput;
type prismaNamespace_DoctorHospitalProfileScalarFieldEnum = DoctorHospitalProfileScalarFieldEnum;
type prismaNamespace_DoctorHospitalProfileScalarWhereInput = DoctorHospitalProfileScalarWhereInput;
type prismaNamespace_DoctorHospitalProfileScalarWhereWithAggregatesInput = DoctorHospitalProfileScalarWhereWithAggregatesInput;
type prismaNamespace_DoctorHospitalProfileSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileSelect<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileSelectScalar = DoctorHospitalProfileSelectScalar;
type prismaNamespace_DoctorHospitalProfileSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileSumAggregateInputType = DoctorHospitalProfileSumAggregateInputType;
type prismaNamespace_DoctorHospitalProfileSumAggregateOutputType = DoctorHospitalProfileSumAggregateOutputType;
type prismaNamespace_DoctorHospitalProfileSumOrderByAggregateInput = DoctorHospitalProfileSumOrderByAggregateInput;
type prismaNamespace_DoctorHospitalProfileUncheckedCreateInput = DoctorHospitalProfileUncheckedCreateInput;
type prismaNamespace_DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput = DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput = DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUncheckedCreateWithoutDoctorInput = DoctorHospitalProfileUncheckedCreateWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUncheckedCreateWithoutHospitalInput = DoctorHospitalProfileUncheckedCreateWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateInput = DoctorHospitalProfileUncheckedUpdateInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyInput = DoctorHospitalProfileUncheckedUpdateManyInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput = DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput = DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput = DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput = DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput = DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput = DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileUpdateArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileUpdateInput = DoctorHospitalProfileUpdateInput;
type prismaNamespace_DoctorHospitalProfileUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileUpdateManyArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileUpdateManyMutationInput = DoctorHospitalProfileUpdateManyMutationInput;
type prismaNamespace_DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput = DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput = DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput = DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput = DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput = DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput = DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUpdateWithoutDoctorInput = DoctorHospitalProfileUpdateWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUpdateWithoutHospitalInput = DoctorHospitalProfileUpdateWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorHospitalProfileUpsertArgs<ExtArgs>;
type prismaNamespace_DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput = DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput = DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_DoctorHospitalProfileWhereInput = DoctorHospitalProfileWhereInput;
type prismaNamespace_DoctorHospitalProfileWhereUniqueInput = DoctorHospitalProfileWhereUniqueInput;
type prismaNamespace_DoctorInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorInclude<ExtArgs>;
type prismaNamespace_DoctorIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorMaxAggregateInputType = DoctorMaxAggregateInputType;
type prismaNamespace_DoctorMaxAggregateOutputType = DoctorMaxAggregateOutputType;
type prismaNamespace_DoctorMaxOrderByAggregateInput = DoctorMaxOrderByAggregateInput;
type prismaNamespace_DoctorMinAggregateInputType = DoctorMinAggregateInputType;
type prismaNamespace_DoctorMinAggregateOutputType = DoctorMinAggregateOutputType;
type prismaNamespace_DoctorMinOrderByAggregateInput = DoctorMinOrderByAggregateInput;
type prismaNamespace_DoctorModel = DoctorModel;
type prismaNamespace_DoctorNullableScalarRelationFilter = DoctorNullableScalarRelationFilter;
type prismaNamespace_DoctorOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorOmit<ExtArgs>;
type prismaNamespace_DoctorOrderByWithAggregationInput = DoctorOrderByWithAggregationInput;
type prismaNamespace_DoctorOrderByWithRelationInput = DoctorOrderByWithRelationInput;
type prismaNamespace_DoctorScalarFieldEnum = DoctorScalarFieldEnum;
type prismaNamespace_DoctorScalarRelationFilter = DoctorScalarRelationFilter;
type prismaNamespace_DoctorScalarWhereWithAggregatesInput = DoctorScalarWhereWithAggregatesInput;
type prismaNamespace_DoctorSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSelect<ExtArgs>;
type prismaNamespace_DoctorSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSelectScalar = DoctorSelectScalar;
type prismaNamespace_DoctorSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationAggregateArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationCountAggregateInputType = DoctorSpecializationCountAggregateInputType;
type prismaNamespace_DoctorSpecializationCountAggregateOutputType = DoctorSpecializationCountAggregateOutputType;
type prismaNamespace_DoctorSpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationCountArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationCountOrderByAggregateInput = DoctorSpecializationCountOrderByAggregateInput;
type prismaNamespace_DoctorSpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationCreateArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationCreateInput = DoctorSpecializationCreateInput;
type prismaNamespace_DoctorSpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationCreateManyArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationCreateManyDoctorInput = DoctorSpecializationCreateManyDoctorInput;
type prismaNamespace_DoctorSpecializationCreateManyDoctorInputEnvelope = DoctorSpecializationCreateManyDoctorInputEnvelope;
type prismaNamespace_DoctorSpecializationCreateManyInput = DoctorSpecializationCreateManyInput;
type prismaNamespace_DoctorSpecializationCreateManySpecializationInput = DoctorSpecializationCreateManySpecializationInput;
type prismaNamespace_DoctorSpecializationCreateManySpecializationInputEnvelope = DoctorSpecializationCreateManySpecializationInputEnvelope;
type prismaNamespace_DoctorSpecializationCreateNestedManyWithoutDoctorInput = DoctorSpecializationCreateNestedManyWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationCreateNestedManyWithoutSpecializationInput = DoctorSpecializationCreateNestedManyWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationCreateOrConnectWithoutDoctorInput = DoctorSpecializationCreateOrConnectWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationCreateOrConnectWithoutSpecializationInput = DoctorSpecializationCreateOrConnectWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationCreateWithoutDoctorInput = DoctorSpecializationCreateWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationCreateWithoutSpecializationInput = DoctorSpecializationCreateWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationDefaultArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = DoctorSpecializationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_DoctorSpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationDeleteArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationDeleteManyArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput = DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput;
type prismaNamespace_DoctorSpecializationFieldRefs = DoctorSpecializationFieldRefs;
type prismaNamespace_DoctorSpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationFindFirstArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationFindManyArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationFindUniqueArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationGetPayload<S extends boolean | null | undefined | DoctorSpecializationDefaultArgs> = DoctorSpecializationGetPayload<S>;
type prismaNamespace_DoctorSpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationGroupByArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationGroupByOutputType = DoctorSpecializationGroupByOutputType;
type prismaNamespace_DoctorSpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationInclude<ExtArgs>;
type prismaNamespace_DoctorSpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSpecializationListRelationFilter = DoctorSpecializationListRelationFilter;
type prismaNamespace_DoctorSpecializationMaxAggregateInputType = DoctorSpecializationMaxAggregateInputType;
type prismaNamespace_DoctorSpecializationMaxAggregateOutputType = DoctorSpecializationMaxAggregateOutputType;
type prismaNamespace_DoctorSpecializationMaxOrderByAggregateInput = DoctorSpecializationMaxOrderByAggregateInput;
type prismaNamespace_DoctorSpecializationMinAggregateInputType = DoctorSpecializationMinAggregateInputType;
type prismaNamespace_DoctorSpecializationMinAggregateOutputType = DoctorSpecializationMinAggregateOutputType;
type prismaNamespace_DoctorSpecializationMinOrderByAggregateInput = DoctorSpecializationMinOrderByAggregateInput;
type prismaNamespace_DoctorSpecializationModel = DoctorSpecializationModel;
type prismaNamespace_DoctorSpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationOmit<ExtArgs>;
type prismaNamespace_DoctorSpecializationOrderByRelationAggregateInput = DoctorSpecializationOrderByRelationAggregateInput;
type prismaNamespace_DoctorSpecializationOrderByWithAggregationInput = DoctorSpecializationOrderByWithAggregationInput;
type prismaNamespace_DoctorSpecializationOrderByWithRelationInput = DoctorSpecializationOrderByWithRelationInput;
type prismaNamespace_DoctorSpecializationScalarFieldEnum = DoctorSpecializationScalarFieldEnum;
type prismaNamespace_DoctorSpecializationScalarWhereInput = DoctorSpecializationScalarWhereInput;
type prismaNamespace_DoctorSpecializationScalarWhereWithAggregatesInput = DoctorSpecializationScalarWhereWithAggregatesInput;
type prismaNamespace_DoctorSpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationSelect<ExtArgs>;
type prismaNamespace_DoctorSpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSpecializationSelectScalar = DoctorSpecializationSelectScalar;
type prismaNamespace_DoctorSpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_DoctorSpecializationUncheckedCreateInput = DoctorSpecializationUncheckedCreateInput;
type prismaNamespace_DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput = DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput = DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUncheckedCreateWithoutDoctorInput = DoctorSpecializationUncheckedCreateWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUncheckedCreateWithoutSpecializationInput = DoctorSpecializationUncheckedCreateWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateInput = DoctorSpecializationUncheckedUpdateInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateManyInput = DoctorSpecializationUncheckedUpdateManyInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput = DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput = DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput = DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput = DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateWithoutDoctorInput = DoctorSpecializationUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUncheckedUpdateWithoutSpecializationInput = DoctorSpecializationUncheckedUpdateWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationUpdateArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationUpdateInput = DoctorSpecializationUpdateInput;
type prismaNamespace_DoctorSpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationUpdateManyArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationUpdateManyMutationInput = DoctorSpecializationUpdateManyMutationInput;
type prismaNamespace_DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput = DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput = DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUpdateManyWithoutDoctorNestedInput = DoctorSpecializationUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_DoctorSpecializationUpdateManyWithoutSpecializationNestedInput = DoctorSpecializationUpdateManyWithoutSpecializationNestedInput;
type prismaNamespace_DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput = DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput = DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUpdateWithoutDoctorInput = DoctorSpecializationUpdateWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUpdateWithoutSpecializationInput = DoctorSpecializationUpdateWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorSpecializationUpsertArgs<ExtArgs>;
type prismaNamespace_DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput = DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput = DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput;
type prismaNamespace_DoctorSpecializationWhereInput = DoctorSpecializationWhereInput;
type prismaNamespace_DoctorSpecializationWhereUniqueInput = DoctorSpecializationWhereUniqueInput;
type prismaNamespace_DoctorSumAggregateInputType = DoctorSumAggregateInputType;
type prismaNamespace_DoctorSumAggregateOutputType = DoctorSumAggregateOutputType;
type prismaNamespace_DoctorSumOrderByAggregateInput = DoctorSumOrderByAggregateInput;
type prismaNamespace_DoctorUncheckedCreateInput = DoctorUncheckedCreateInput;
type prismaNamespace_DoctorUncheckedCreateNestedOneWithoutUserInput = DoctorUncheckedCreateNestedOneWithoutUserInput;
type prismaNamespace_DoctorUncheckedCreateWithoutAppointmentInput = DoctorUncheckedCreateWithoutAppointmentInput;
type prismaNamespace_DoctorUncheckedCreateWithoutDoctorHospitalProfileInput = DoctorUncheckedCreateWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorUncheckedCreateWithoutDoctorSpecializationInput = DoctorUncheckedCreateWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorUncheckedCreateWithoutReviewInput = DoctorUncheckedCreateWithoutReviewInput;
type prismaNamespace_DoctorUncheckedCreateWithoutSavedDoctorHospitalInput = DoctorUncheckedCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorUncheckedCreateWithoutScheduleInput = DoctorUncheckedCreateWithoutScheduleInput;
type prismaNamespace_DoctorUncheckedCreateWithoutUserInput = DoctorUncheckedCreateWithoutUserInput;
type prismaNamespace_DoctorUncheckedUpdateInput = DoctorUncheckedUpdateInput;
type prismaNamespace_DoctorUncheckedUpdateManyInput = DoctorUncheckedUpdateManyInput;
type prismaNamespace_DoctorUncheckedUpdateOneWithoutUserNestedInput = DoctorUncheckedUpdateOneWithoutUserNestedInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutAppointmentInput = DoctorUncheckedUpdateWithoutAppointmentInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput = DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutDoctorSpecializationInput = DoctorUncheckedUpdateWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutReviewInput = DoctorUncheckedUpdateWithoutReviewInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput = DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutScheduleInput = DoctorUncheckedUpdateWithoutScheduleInput;
type prismaNamespace_DoctorUncheckedUpdateWithoutUserInput = DoctorUncheckedUpdateWithoutUserInput;
type prismaNamespace_DoctorUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorUpdateArgs<ExtArgs>;
type prismaNamespace_DoctorUpdateInput = DoctorUpdateInput;
type prismaNamespace_DoctorUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_DoctorUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorUpdateManyArgs<ExtArgs>;
type prismaNamespace_DoctorUpdateManyMutationInput = DoctorUpdateManyMutationInput;
type prismaNamespace_DoctorUpdateOneRequiredWithoutAppointmentNestedInput = DoctorUpdateOneRequiredWithoutAppointmentNestedInput;
type prismaNamespace_DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput = DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
type prismaNamespace_DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput = DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
type prismaNamespace_DoctorUpdateOneRequiredWithoutScheduleNestedInput = DoctorUpdateOneRequiredWithoutScheduleNestedInput;
type prismaNamespace_DoctorUpdateOneWithoutReviewNestedInput = DoctorUpdateOneWithoutReviewNestedInput;
type prismaNamespace_DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput = DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput;
type prismaNamespace_DoctorUpdateOneWithoutUserNestedInput = DoctorUpdateOneWithoutUserNestedInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutAppointmentInput = DoctorUpdateToOneWithWhereWithoutAppointmentInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput = DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput = DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutReviewInput = DoctorUpdateToOneWithWhereWithoutReviewInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutScheduleInput = DoctorUpdateToOneWithWhereWithoutScheduleInput;
type prismaNamespace_DoctorUpdateToOneWithWhereWithoutUserInput = DoctorUpdateToOneWithWhereWithoutUserInput;
type prismaNamespace_DoctorUpdateWithoutAppointmentInput = DoctorUpdateWithoutAppointmentInput;
type prismaNamespace_DoctorUpdateWithoutDoctorHospitalProfileInput = DoctorUpdateWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorUpdateWithoutDoctorSpecializationInput = DoctorUpdateWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorUpdateWithoutReviewInput = DoctorUpdateWithoutReviewInput;
type prismaNamespace_DoctorUpdateWithoutSavedDoctorHospitalInput = DoctorUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorUpdateWithoutScheduleInput = DoctorUpdateWithoutScheduleInput;
type prismaNamespace_DoctorUpdateWithoutUserInput = DoctorUpdateWithoutUserInput;
type prismaNamespace_DoctorUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = DoctorUpsertArgs<ExtArgs>;
type prismaNamespace_DoctorUpsertWithoutAppointmentInput = DoctorUpsertWithoutAppointmentInput;
type prismaNamespace_DoctorUpsertWithoutDoctorHospitalProfileInput = DoctorUpsertWithoutDoctorHospitalProfileInput;
type prismaNamespace_DoctorUpsertWithoutDoctorSpecializationInput = DoctorUpsertWithoutDoctorSpecializationInput;
type prismaNamespace_DoctorUpsertWithoutReviewInput = DoctorUpsertWithoutReviewInput;
type prismaNamespace_DoctorUpsertWithoutSavedDoctorHospitalInput = DoctorUpsertWithoutSavedDoctorHospitalInput;
type prismaNamespace_DoctorUpsertWithoutScheduleInput = DoctorUpsertWithoutScheduleInput;
type prismaNamespace_DoctorUpsertWithoutUserInput = DoctorUpsertWithoutUserInput;
type prismaNamespace_DoctorWhereInput = DoctorWhereInput;
type prismaNamespace_DoctorWhereUniqueInput = DoctorWhereUniqueInput;
type prismaNamespace_Either<O extends object, K extends Key, strict extends Boolean = 1> = Either<O, K, strict>;
type prismaNamespace_EnumAppointmentStatusFieldRefInput<$PrismaModel> = EnumAppointmentStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumAppointmentStatusFieldUpdateOperationsInput = EnumAppointmentStatusFieldUpdateOperationsInput;
type prismaNamespace_EnumAppointmentStatusFilter<$PrismaModel = never> = EnumAppointmentStatusFilter<$PrismaModel>;
type prismaNamespace_EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = EnumAppointmentStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumDoctorApplicationStatusFieldRefInput<$PrismaModel> = EnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumDoctorApplicationStatusFieldUpdateOperationsInput = EnumDoctorApplicationStatusFieldUpdateOperationsInput;
type prismaNamespace_EnumDoctorApplicationStatusFilter<$PrismaModel = never> = EnumDoctorApplicationStatusFilter<$PrismaModel>;
type prismaNamespace_EnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel = never> = EnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumDoctorTypeFieldRefInput<$PrismaModel> = EnumDoctorTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumDoctorTypeFieldUpdateOperationsInput = EnumDoctorTypeFieldUpdateOperationsInput;
type prismaNamespace_EnumDoctorTypeFilter<$PrismaModel = never> = EnumDoctorTypeFilter<$PrismaModel>;
type prismaNamespace_EnumDoctorTypeWithAggregatesFilter<$PrismaModel = never> = EnumDoctorTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumHospitalTypeFieldRefInput<$PrismaModel> = EnumHospitalTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumHospitalTypeFieldUpdateOperationsInput = EnumHospitalTypeFieldUpdateOperationsInput;
type prismaNamespace_EnumHospitalTypeFilter<$PrismaModel = never> = EnumHospitalTypeFilter<$PrismaModel>;
type prismaNamespace_EnumHospitalTypeWithAggregatesFilter<$PrismaModel = never> = EnumHospitalTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumQueryModeFieldRefInput<$PrismaModel> = EnumQueryModeFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumRoleFieldRefInput<$PrismaModel> = EnumRoleFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumRoleNullableFilter<$PrismaModel = never> = EnumRoleNullableFilter<$PrismaModel>;
type prismaNamespace_EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = EnumRoleNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumSchedulePeriodFieldRefInput<$PrismaModel> = EnumSchedulePeriodFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumSchedulePeriodFieldUpdateOperationsInput = EnumSchedulePeriodFieldUpdateOperationsInput;
type prismaNamespace_EnumSchedulePeriodFilter<$PrismaModel = never> = EnumSchedulePeriodFilter<$PrismaModel>;
type prismaNamespace_EnumSchedulePeriodWithAggregatesFilter<$PrismaModel = never> = EnumSchedulePeriodWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumScheduleStatusFieldRefInput<$PrismaModel> = EnumScheduleStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumScheduleStatusFieldUpdateOperationsInput = EnumScheduleStatusFieldUpdateOperationsInput;
type prismaNamespace_EnumScheduleStatusFilter<$PrismaModel = never> = EnumScheduleStatusFilter<$PrismaModel>;
type prismaNamespace_EnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = EnumScheduleStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumScheduleTypeFieldRefInput<$PrismaModel> = EnumScheduleTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumScheduleTypeFieldUpdateOperationsInput = EnumScheduleTypeFieldUpdateOperationsInput;
type prismaNamespace_EnumScheduleTypeFilter<$PrismaModel = never> = EnumScheduleTypeFilter<$PrismaModel>;
type prismaNamespace_EnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = EnumScheduleTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_EnumSlotStatusFieldRefInput<$PrismaModel> = EnumSlotStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_EnumSlotStatusFieldUpdateOperationsInput = EnumSlotStatusFieldUpdateOperationsInput;
type prismaNamespace_EnumSlotStatusFilter<$PrismaModel = never> = EnumSlotStatusFilter<$PrismaModel>;
type prismaNamespace_EnumSlotStatusWithAggregatesFilter<$PrismaModel = never> = EnumSlotStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_Enumerable<T> = Enumerable<T>;
type prismaNamespace_ErrorFormat = ErrorFormat;
type prismaNamespace_Exact<A, W> = Exact<A, W>;
type prismaNamespace_ExcludeUnderscoreKeys<T extends string> = ExcludeUnderscoreKeys<T>;
type prismaNamespace_Extends<A1 extends any, A2 extends any> = Extends<A1, A2>;
type prismaNamespace_Extension = Extension;
type prismaNamespace_False = False;
type prismaNamespace_FieldRef<Model, FieldType> = FieldRef<Model, FieldType>;
type prismaNamespace_FloatFieldRefInput<$PrismaModel> = FloatFieldRefInput<$PrismaModel>;
type prismaNamespace_GetAccountAggregateType<T extends AccountAggregateArgs> = GetAccountAggregateType<T>;
type prismaNamespace_GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = GetAppointmentAggregateType<T>;
type prismaNamespace_GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = GetAuditLogAggregateType<T>;
type prismaNamespace_GetDoctorAggregateType<T extends DoctorAggregateArgs> = GetDoctorAggregateType<T>;
type prismaNamespace_GetDoctorApplicationAggregateType<T extends DoctorApplicationAggregateArgs> = GetDoctorApplicationAggregateType<T>;
type prismaNamespace_GetDoctorHospitalProfileAggregateType<T extends DoctorHospitalProfileAggregateArgs> = GetDoctorHospitalProfileAggregateType<T>;
type prismaNamespace_GetDoctorSpecializationAggregateType<T extends DoctorSpecializationAggregateArgs> = GetDoctorSpecializationAggregateType<T>;
type prismaNamespace_GetEvents<T extends any[]> = GetEvents<T>;
type prismaNamespace_GetHavingFields<T> = GetHavingFields<T>;
type prismaNamespace_GetHospitalAggregateType<T extends HospitalAggregateArgs> = GetHospitalAggregateType<T>;
type prismaNamespace_GetHospitalSpecializationAggregateType<T extends HospitalSpecializationAggregateArgs> = GetHospitalSpecializationAggregateType<T>;
type prismaNamespace_GetLogType<T> = GetLogType<T>;
type prismaNamespace_GetNotificationAggregateType<T extends NotificationAggregateArgs> = GetNotificationAggregateType<T>;
type prismaNamespace_GetPaymentAggregateType<T extends PaymentAggregateArgs> = GetPaymentAggregateType<T>;
type prismaNamespace_GetReviewAggregateType<T extends ReviewAggregateArgs> = GetReviewAggregateType<T>;
type prismaNamespace_GetSavedDoctorHospitalAggregateType<T extends SavedDoctorHospitalAggregateArgs> = GetSavedDoctorHospitalAggregateType<T>;
type prismaNamespace_GetScalarType<T, O> = GetScalarType<T, O>;
type prismaNamespace_GetScheduleAggregateType<T extends ScheduleAggregateArgs> = GetScheduleAggregateType<T>;
type prismaNamespace_GetSearchLogAggregateType<T extends SearchLogAggregateArgs> = GetSearchLogAggregateType<T>;
type prismaNamespace_GetSessionAggregateType<T extends SessionAggregateArgs> = GetSessionAggregateType<T>;
type prismaNamespace_GetSlotAggregateType<T extends SlotAggregateArgs> = GetSlotAggregateType<T>;
type prismaNamespace_GetSpecializationAggregateType<T extends SpecializationAggregateArgs> = GetSpecializationAggregateType<T>;
type prismaNamespace_GetUserAggregateType<T extends UserAggregateArgs> = GetUserAggregateType<T>;
type prismaNamespace_GetVerificationAggregateType<T extends VerificationAggregateArgs> = GetVerificationAggregateType<T>;
type prismaNamespace_GlobalOmitConfig = GlobalOmitConfig;
type prismaNamespace_Has<U extends Union, U1 extends Union> = Has<U, U1>;
type prismaNamespace_Hospital$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$AppointmentArgs<ExtArgs>;
type prismaNamespace_Hospital$DoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$DoctorApplicationArgs<ExtArgs>;
type prismaNamespace_Hospital$DoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$DoctorHospitalProfileArgs<ExtArgs>;
type prismaNamespace_Hospital$HospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$HospitalSpecializationArgs<ExtArgs>;
type prismaNamespace_Hospital$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$ReviewArgs<ExtArgs>;
type prismaNamespace_Hospital$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$SavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_Hospital$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Hospital$ScheduleArgs<ExtArgs>;
type prismaNamespace_HospitalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalAggregateArgs<ExtArgs>;
type prismaNamespace_HospitalAvgAggregateInputType = HospitalAvgAggregateInputType;
type prismaNamespace_HospitalAvgAggregateOutputType = HospitalAvgAggregateOutputType;
type prismaNamespace_HospitalAvgOrderByAggregateInput = HospitalAvgOrderByAggregateInput;
type prismaNamespace_HospitalCountAggregateInputType = HospitalCountAggregateInputType;
type prismaNamespace_HospitalCountAggregateOutputType = HospitalCountAggregateOutputType;
type prismaNamespace_HospitalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountArgs<ExtArgs>;
type prismaNamespace_HospitalCountOrderByAggregateInput = HospitalCountOrderByAggregateInput;
type prismaNamespace_HospitalCountOutputType = HospitalCountOutputType;
type prismaNamespace_HospitalCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountAppointmentArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountDoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountDoctorApplicationArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountDoctorHospitalProfileArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountHospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountHospitalSpecializationArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountReviewArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeCountScheduleArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeDefaultArgs<ExtArgs>;
type prismaNamespace_HospitalCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCountOutputTypeSelect<ExtArgs>;
type prismaNamespace_HospitalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCreateArgs<ExtArgs>;
type prismaNamespace_HospitalCreateInput = HospitalCreateInput;
type prismaNamespace_HospitalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_HospitalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalCreateManyArgs<ExtArgs>;
type prismaNamespace_HospitalCreateManyInput = HospitalCreateManyInput;
type prismaNamespace_HospitalCreateNestedOneWithoutAppointmentInput = HospitalCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_HospitalCreateNestedOneWithoutDoctorApplicationInput = HospitalCreateNestedOneWithoutDoctorApplicationInput;
type prismaNamespace_HospitalCreateNestedOneWithoutDoctorHospitalProfileInput = HospitalCreateNestedOneWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalCreateNestedOneWithoutHospitalSpecializationInput = HospitalCreateNestedOneWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalCreateNestedOneWithoutReviewInput = HospitalCreateNestedOneWithoutReviewInput;
type prismaNamespace_HospitalCreateNestedOneWithoutSavedDoctorHospitalInput = HospitalCreateNestedOneWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalCreateNestedOneWithoutScheduleInput = HospitalCreateNestedOneWithoutScheduleInput;
type prismaNamespace_HospitalCreateNestedOneWithoutUserInput = HospitalCreateNestedOneWithoutUserInput;
type prismaNamespace_HospitalCreateOrConnectWithoutAppointmentInput = HospitalCreateOrConnectWithoutAppointmentInput;
type prismaNamespace_HospitalCreateOrConnectWithoutDoctorApplicationInput = HospitalCreateOrConnectWithoutDoctorApplicationInput;
type prismaNamespace_HospitalCreateOrConnectWithoutDoctorHospitalProfileInput = HospitalCreateOrConnectWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalCreateOrConnectWithoutHospitalSpecializationInput = HospitalCreateOrConnectWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalCreateOrConnectWithoutReviewInput = HospitalCreateOrConnectWithoutReviewInput;
type prismaNamespace_HospitalCreateOrConnectWithoutSavedDoctorHospitalInput = HospitalCreateOrConnectWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalCreateOrConnectWithoutScheduleInput = HospitalCreateOrConnectWithoutScheduleInput;
type prismaNamespace_HospitalCreateOrConnectWithoutUserInput = HospitalCreateOrConnectWithoutUserInput;
type prismaNamespace_HospitalCreateWithoutAppointmentInput = HospitalCreateWithoutAppointmentInput;
type prismaNamespace_HospitalCreateWithoutDoctorApplicationInput = HospitalCreateWithoutDoctorApplicationInput;
type prismaNamespace_HospitalCreateWithoutDoctorHospitalProfileInput = HospitalCreateWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalCreateWithoutHospitalSpecializationInput = HospitalCreateWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalCreateWithoutReviewInput = HospitalCreateWithoutReviewInput;
type prismaNamespace_HospitalCreateWithoutSavedDoctorHospitalInput = HospitalCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalCreateWithoutScheduleInput = HospitalCreateWithoutScheduleInput;
type prismaNamespace_HospitalCreateWithoutUserInput = HospitalCreateWithoutUserInput;
type prismaNamespace_HospitalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalDefaultArgs<ExtArgs>;
type prismaNamespace_HospitalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = HospitalDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_HospitalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalDeleteArgs<ExtArgs>;
type prismaNamespace_HospitalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalDeleteManyArgs<ExtArgs>;
type prismaNamespace_HospitalFieldRefs = HospitalFieldRefs;
type prismaNamespace_HospitalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalFindFirstArgs<ExtArgs>;
type prismaNamespace_HospitalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_HospitalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalFindManyArgs<ExtArgs>;
type prismaNamespace_HospitalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalFindUniqueArgs<ExtArgs>;
type prismaNamespace_HospitalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = HospitalGetPayload<S>;
type prismaNamespace_HospitalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalGroupByArgs<ExtArgs>;
type prismaNamespace_HospitalGroupByOutputType = HospitalGroupByOutputType;
type prismaNamespace_HospitalInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalInclude<ExtArgs>;
type prismaNamespace_HospitalIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalMaxAggregateInputType = HospitalMaxAggregateInputType;
type prismaNamespace_HospitalMaxAggregateOutputType = HospitalMaxAggregateOutputType;
type prismaNamespace_HospitalMaxOrderByAggregateInput = HospitalMaxOrderByAggregateInput;
type prismaNamespace_HospitalMinAggregateInputType = HospitalMinAggregateInputType;
type prismaNamespace_HospitalMinAggregateOutputType = HospitalMinAggregateOutputType;
type prismaNamespace_HospitalMinOrderByAggregateInput = HospitalMinOrderByAggregateInput;
type prismaNamespace_HospitalModel = HospitalModel;
type prismaNamespace_HospitalNullableScalarRelationFilter = HospitalNullableScalarRelationFilter;
type prismaNamespace_HospitalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalOmit<ExtArgs>;
type prismaNamespace_HospitalOrderByWithAggregationInput = HospitalOrderByWithAggregationInput;
type prismaNamespace_HospitalOrderByWithRelationInput = HospitalOrderByWithRelationInput;
type prismaNamespace_HospitalScalarFieldEnum = HospitalScalarFieldEnum;
type prismaNamespace_HospitalScalarRelationFilter = HospitalScalarRelationFilter;
type prismaNamespace_HospitalScalarWhereWithAggregatesInput = HospitalScalarWhereWithAggregatesInput;
type prismaNamespace_HospitalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSelect<ExtArgs>;
type prismaNamespace_HospitalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSelectScalar = HospitalSelectScalar;
type prismaNamespace_HospitalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationAggregateArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationCountAggregateInputType = HospitalSpecializationCountAggregateInputType;
type prismaNamespace_HospitalSpecializationCountAggregateOutputType = HospitalSpecializationCountAggregateOutputType;
type prismaNamespace_HospitalSpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationCountArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationCountOrderByAggregateInput = HospitalSpecializationCountOrderByAggregateInput;
type prismaNamespace_HospitalSpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationCreateArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationCreateInput = HospitalSpecializationCreateInput;
type prismaNamespace_HospitalSpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationCreateManyArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationCreateManyHospitalInput = HospitalSpecializationCreateManyHospitalInput;
type prismaNamespace_HospitalSpecializationCreateManyHospitalInputEnvelope = HospitalSpecializationCreateManyHospitalInputEnvelope;
type prismaNamespace_HospitalSpecializationCreateManyInput = HospitalSpecializationCreateManyInput;
type prismaNamespace_HospitalSpecializationCreateManySpecializationInput = HospitalSpecializationCreateManySpecializationInput;
type prismaNamespace_HospitalSpecializationCreateManySpecializationInputEnvelope = HospitalSpecializationCreateManySpecializationInputEnvelope;
type prismaNamespace_HospitalSpecializationCreateNestedManyWithoutHospitalInput = HospitalSpecializationCreateNestedManyWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationCreateNestedManyWithoutSpecializationInput = HospitalSpecializationCreateNestedManyWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationCreateOrConnectWithoutHospitalInput = HospitalSpecializationCreateOrConnectWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationCreateOrConnectWithoutSpecializationInput = HospitalSpecializationCreateOrConnectWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationCreateWithoutHospitalInput = HospitalSpecializationCreateWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationCreateWithoutSpecializationInput = HospitalSpecializationCreateWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationDefaultArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = HospitalSpecializationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_HospitalSpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationDeleteArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationDeleteManyArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationFieldRefs = HospitalSpecializationFieldRefs;
type prismaNamespace_HospitalSpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationFindFirstArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationFindManyArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationFindUniqueArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationGetPayload<S extends boolean | null | undefined | HospitalSpecializationDefaultArgs> = HospitalSpecializationGetPayload<S>;
type prismaNamespace_HospitalSpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationGroupByArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationGroupByOutputType = HospitalSpecializationGroupByOutputType;
type prismaNamespace_HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput = HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput;
type prismaNamespace_HospitalSpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationInclude<ExtArgs>;
type prismaNamespace_HospitalSpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSpecializationListRelationFilter = HospitalSpecializationListRelationFilter;
type prismaNamespace_HospitalSpecializationMaxAggregateInputType = HospitalSpecializationMaxAggregateInputType;
type prismaNamespace_HospitalSpecializationMaxAggregateOutputType = HospitalSpecializationMaxAggregateOutputType;
type prismaNamespace_HospitalSpecializationMaxOrderByAggregateInput = HospitalSpecializationMaxOrderByAggregateInput;
type prismaNamespace_HospitalSpecializationMinAggregateInputType = HospitalSpecializationMinAggregateInputType;
type prismaNamespace_HospitalSpecializationMinAggregateOutputType = HospitalSpecializationMinAggregateOutputType;
type prismaNamespace_HospitalSpecializationMinOrderByAggregateInput = HospitalSpecializationMinOrderByAggregateInput;
type prismaNamespace_HospitalSpecializationModel = HospitalSpecializationModel;
type prismaNamespace_HospitalSpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationOmit<ExtArgs>;
type prismaNamespace_HospitalSpecializationOrderByRelationAggregateInput = HospitalSpecializationOrderByRelationAggregateInput;
type prismaNamespace_HospitalSpecializationOrderByWithAggregationInput = HospitalSpecializationOrderByWithAggregationInput;
type prismaNamespace_HospitalSpecializationOrderByWithRelationInput = HospitalSpecializationOrderByWithRelationInput;
type prismaNamespace_HospitalSpecializationScalarFieldEnum = HospitalSpecializationScalarFieldEnum;
type prismaNamespace_HospitalSpecializationScalarWhereInput = HospitalSpecializationScalarWhereInput;
type prismaNamespace_HospitalSpecializationScalarWhereWithAggregatesInput = HospitalSpecializationScalarWhereWithAggregatesInput;
type prismaNamespace_HospitalSpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationSelect<ExtArgs>;
type prismaNamespace_HospitalSpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSpecializationSelectScalar = HospitalSpecializationSelectScalar;
type prismaNamespace_HospitalSpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_HospitalSpecializationUncheckedCreateInput = HospitalSpecializationUncheckedCreateInput;
type prismaNamespace_HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput = HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput = HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUncheckedCreateWithoutHospitalInput = HospitalSpecializationUncheckedCreateWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUncheckedCreateWithoutSpecializationInput = HospitalSpecializationUncheckedCreateWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateInput = HospitalSpecializationUncheckedUpdateInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateManyInput = HospitalSpecializationUncheckedUpdateManyInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput = HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput = HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput = HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput = HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateWithoutHospitalInput = HospitalSpecializationUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUncheckedUpdateWithoutSpecializationInput = HospitalSpecializationUncheckedUpdateWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationUpdateArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationUpdateInput = HospitalSpecializationUpdateInput;
type prismaNamespace_HospitalSpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationUpdateManyArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationUpdateManyMutationInput = HospitalSpecializationUpdateManyMutationInput;
type prismaNamespace_HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput = HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput = HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUpdateManyWithoutHospitalNestedInput = HospitalSpecializationUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_HospitalSpecializationUpdateManyWithoutSpecializationNestedInput = HospitalSpecializationUpdateManyWithoutSpecializationNestedInput;
type prismaNamespace_HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput = HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput = HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUpdateWithoutHospitalInput = HospitalSpecializationUpdateWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUpdateWithoutSpecializationInput = HospitalSpecializationUpdateWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalSpecializationUpsertArgs<ExtArgs>;
type prismaNamespace_HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput = HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput = HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput;
type prismaNamespace_HospitalSpecializationWhereInput = HospitalSpecializationWhereInput;
type prismaNamespace_HospitalSpecializationWhereUniqueInput = HospitalSpecializationWhereUniqueInput;
type prismaNamespace_HospitalSumAggregateInputType = HospitalSumAggregateInputType;
type prismaNamespace_HospitalSumAggregateOutputType = HospitalSumAggregateOutputType;
type prismaNamespace_HospitalSumOrderByAggregateInput = HospitalSumOrderByAggregateInput;
type prismaNamespace_HospitalUncheckedCreateInput = HospitalUncheckedCreateInput;
type prismaNamespace_HospitalUncheckedCreateNestedOneWithoutUserInput = HospitalUncheckedCreateNestedOneWithoutUserInput;
type prismaNamespace_HospitalUncheckedCreateWithoutAppointmentInput = HospitalUncheckedCreateWithoutAppointmentInput;
type prismaNamespace_HospitalUncheckedCreateWithoutDoctorApplicationInput = HospitalUncheckedCreateWithoutDoctorApplicationInput;
type prismaNamespace_HospitalUncheckedCreateWithoutDoctorHospitalProfileInput = HospitalUncheckedCreateWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalUncheckedCreateWithoutHospitalSpecializationInput = HospitalUncheckedCreateWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalUncheckedCreateWithoutReviewInput = HospitalUncheckedCreateWithoutReviewInput;
type prismaNamespace_HospitalUncheckedCreateWithoutSavedDoctorHospitalInput = HospitalUncheckedCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalUncheckedCreateWithoutScheduleInput = HospitalUncheckedCreateWithoutScheduleInput;
type prismaNamespace_HospitalUncheckedCreateWithoutUserInput = HospitalUncheckedCreateWithoutUserInput;
type prismaNamespace_HospitalUncheckedUpdateInput = HospitalUncheckedUpdateInput;
type prismaNamespace_HospitalUncheckedUpdateManyInput = HospitalUncheckedUpdateManyInput;
type prismaNamespace_HospitalUncheckedUpdateOneWithoutUserNestedInput = HospitalUncheckedUpdateOneWithoutUserNestedInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutAppointmentInput = HospitalUncheckedUpdateWithoutAppointmentInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutDoctorApplicationInput = HospitalUncheckedUpdateWithoutDoctorApplicationInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput = HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutHospitalSpecializationInput = HospitalUncheckedUpdateWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutReviewInput = HospitalUncheckedUpdateWithoutReviewInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput = HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutScheduleInput = HospitalUncheckedUpdateWithoutScheduleInput;
type prismaNamespace_HospitalUncheckedUpdateWithoutUserInput = HospitalUncheckedUpdateWithoutUserInput;
type prismaNamespace_HospitalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalUpdateArgs<ExtArgs>;
type prismaNamespace_HospitalUpdateInput = HospitalUpdateInput;
type prismaNamespace_HospitalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_HospitalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalUpdateManyArgs<ExtArgs>;
type prismaNamespace_HospitalUpdateManyMutationInput = HospitalUpdateManyMutationInput;
type prismaNamespace_HospitalUpdateOneRequiredWithoutAppointmentNestedInput = HospitalUpdateOneRequiredWithoutAppointmentNestedInput;
type prismaNamespace_HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput = HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput;
type prismaNamespace_HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput = HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput;
type prismaNamespace_HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput = HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
type prismaNamespace_HospitalUpdateOneRequiredWithoutScheduleNestedInput = HospitalUpdateOneRequiredWithoutScheduleNestedInput;
type prismaNamespace_HospitalUpdateOneWithoutReviewNestedInput = HospitalUpdateOneWithoutReviewNestedInput;
type prismaNamespace_HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput = HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput;
type prismaNamespace_HospitalUpdateOneWithoutUserNestedInput = HospitalUpdateOneWithoutUserNestedInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutAppointmentInput = HospitalUpdateToOneWithWhereWithoutAppointmentInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput = HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput = HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput = HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutReviewInput = HospitalUpdateToOneWithWhereWithoutReviewInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutScheduleInput = HospitalUpdateToOneWithWhereWithoutScheduleInput;
type prismaNamespace_HospitalUpdateToOneWithWhereWithoutUserInput = HospitalUpdateToOneWithWhereWithoutUserInput;
type prismaNamespace_HospitalUpdateWithoutAppointmentInput = HospitalUpdateWithoutAppointmentInput;
type prismaNamespace_HospitalUpdateWithoutDoctorApplicationInput = HospitalUpdateWithoutDoctorApplicationInput;
type prismaNamespace_HospitalUpdateWithoutDoctorHospitalProfileInput = HospitalUpdateWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalUpdateWithoutHospitalSpecializationInput = HospitalUpdateWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalUpdateWithoutReviewInput = HospitalUpdateWithoutReviewInput;
type prismaNamespace_HospitalUpdateWithoutSavedDoctorHospitalInput = HospitalUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalUpdateWithoutScheduleInput = HospitalUpdateWithoutScheduleInput;
type prismaNamespace_HospitalUpdateWithoutUserInput = HospitalUpdateWithoutUserInput;
type prismaNamespace_HospitalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = HospitalUpsertArgs<ExtArgs>;
type prismaNamespace_HospitalUpsertWithoutAppointmentInput = HospitalUpsertWithoutAppointmentInput;
type prismaNamespace_HospitalUpsertWithoutDoctorApplicationInput = HospitalUpsertWithoutDoctorApplicationInput;
type prismaNamespace_HospitalUpsertWithoutDoctorHospitalProfileInput = HospitalUpsertWithoutDoctorHospitalProfileInput;
type prismaNamespace_HospitalUpsertWithoutHospitalSpecializationInput = HospitalUpsertWithoutHospitalSpecializationInput;
type prismaNamespace_HospitalUpsertWithoutReviewInput = HospitalUpsertWithoutReviewInput;
type prismaNamespace_HospitalUpsertWithoutSavedDoctorHospitalInput = HospitalUpsertWithoutSavedDoctorHospitalInput;
type prismaNamespace_HospitalUpsertWithoutScheduleInput = HospitalUpsertWithoutScheduleInput;
type prismaNamespace_HospitalUpsertWithoutUserInput = HospitalUpsertWithoutUserInput;
type prismaNamespace_HospitalWhereInput = HospitalWhereInput;
type prismaNamespace_HospitalWhereUniqueInput = HospitalWhereUniqueInput;
type prismaNamespace_InputJsonArray = InputJsonArray;
type prismaNamespace_InputJsonObject = InputJsonObject;
type prismaNamespace_InputJsonValue = InputJsonValue;
type prismaNamespace_IntFieldRefInput<$PrismaModel> = IntFieldRefInput<$PrismaModel>;
type prismaNamespace_IntFieldUpdateOperationsInput = IntFieldUpdateOperationsInput;
type prismaNamespace_IntFilter<$PrismaModel = never> = IntFilter<$PrismaModel>;
type prismaNamespace_IntNullableFilter<$PrismaModel = never> = IntNullableFilter<$PrismaModel>;
type prismaNamespace_IntNullableListFilter<$PrismaModel = never> = IntNullableListFilter<$PrismaModel>;
type prismaNamespace_IntNullableWithAggregatesFilter<$PrismaModel = never> = IntNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_IntWithAggregatesFilter<$PrismaModel = never> = IntWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_IntersectOf<U extends Union> = IntersectOf<U>;
type prismaNamespace_JsonArray = JsonArray;
type prismaNamespace_JsonFieldRefInput<$PrismaModel> = JsonFieldRefInput<$PrismaModel>;
declare const prismaNamespace_JsonNull: typeof JsonNull;
type prismaNamespace_JsonNullValueFilter = JsonNullValueFilter;
type prismaNamespace_JsonNullableFilter<$PrismaModel = never> = JsonNullableFilter<$PrismaModel>;
type prismaNamespace_JsonNullableFilterBase<$PrismaModel = never> = JsonNullableFilterBase<$PrismaModel>;
type prismaNamespace_JsonNullableWithAggregatesFilter<$PrismaModel = never> = JsonNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = JsonNullableWithAggregatesFilterBase<$PrismaModel>;
type prismaNamespace_JsonObject = JsonObject;
type prismaNamespace_JsonValue = JsonValue;
type prismaNamespace_Keys<U extends Union> = Keys<U>;
type prismaNamespace_ListDateTimeFieldRefInput<$PrismaModel> = ListDateTimeFieldRefInput<$PrismaModel>;
type prismaNamespace_ListDecimalFieldRefInput<$PrismaModel> = ListDecimalFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = ListEnumAppointmentStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel> = ListEnumDoctorApplicationStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumDoctorTypeFieldRefInput<$PrismaModel> = ListEnumDoctorTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumHospitalTypeFieldRefInput<$PrismaModel> = ListEnumHospitalTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumRoleFieldRefInput<$PrismaModel> = ListEnumRoleFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumSchedulePeriodFieldRefInput<$PrismaModel> = ListEnumSchedulePeriodFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumScheduleStatusFieldRefInput<$PrismaModel> = ListEnumScheduleStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumScheduleTypeFieldRefInput<$PrismaModel> = ListEnumScheduleTypeFieldRefInput<$PrismaModel>;
type prismaNamespace_ListEnumSlotStatusFieldRefInput<$PrismaModel> = ListEnumSlotStatusFieldRefInput<$PrismaModel>;
type prismaNamespace_ListFloatFieldRefInput<$PrismaModel> = ListFloatFieldRefInput<$PrismaModel>;
type prismaNamespace_ListIntFieldRefInput<$PrismaModel> = ListIntFieldRefInput<$PrismaModel>;
type prismaNamespace_ListStringFieldRefInput<$PrismaModel> = ListStringFieldRefInput<$PrismaModel>;
type prismaNamespace_LogDefinition = LogDefinition;
type prismaNamespace_LogEvent = LogEvent;
type prismaNamespace_LogLevel = LogLevel;
type prismaNamespace_MaybeTupleToUnion<T> = MaybeTupleToUnion<T>;
type prismaNamespace_Merge<U extends object> = Merge<U>;
type prismaNamespace_ModelName = ModelName;
type prismaNamespace_NestedBoolFilter<$PrismaModel = never> = NestedBoolFilter<$PrismaModel>;
type prismaNamespace_NestedBoolNullableFilter<$PrismaModel = never> = NestedBoolNullableFilter<$PrismaModel>;
type prismaNamespace_NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = NestedBoolNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedBoolWithAggregatesFilter<$PrismaModel = never> = NestedBoolWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedDateTimeFilter<$PrismaModel = never> = NestedDateTimeFilter<$PrismaModel>;
type prismaNamespace_NestedDateTimeNullableFilter<$PrismaModel = never> = NestedDateTimeNullableFilter<$PrismaModel>;
type prismaNamespace_NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = NestedDateTimeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedDecimalFilter<$PrismaModel = never> = NestedDecimalFilter<$PrismaModel>;
type prismaNamespace_NestedDecimalNullableFilter<$PrismaModel = never> = NestedDecimalNullableFilter<$PrismaModel>;
type prismaNamespace_NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = NestedDecimalNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedDecimalWithAggregatesFilter<$PrismaModel = never> = NestedDecimalWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumAppointmentStatusFilter<$PrismaModel = never> = NestedEnumAppointmentStatusFilter<$PrismaModel>;
type prismaNamespace_NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumDoctorApplicationStatusFilter<$PrismaModel = never> = NestedEnumDoctorApplicationStatusFilter<$PrismaModel>;
type prismaNamespace_NestedEnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel = never> = NestedEnumDoctorApplicationStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumDoctorTypeFilter<$PrismaModel = never> = NestedEnumDoctorTypeFilter<$PrismaModel>;
type prismaNamespace_NestedEnumDoctorTypeWithAggregatesFilter<$PrismaModel = never> = NestedEnumDoctorTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumHospitalTypeFilter<$PrismaModel = never> = NestedEnumHospitalTypeFilter<$PrismaModel>;
type prismaNamespace_NestedEnumHospitalTypeWithAggregatesFilter<$PrismaModel = never> = NestedEnumHospitalTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumRoleNullableFilter<$PrismaModel = never> = NestedEnumRoleNullableFilter<$PrismaModel>;
type prismaNamespace_NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumSchedulePeriodFilter<$PrismaModel = never> = NestedEnumSchedulePeriodFilter<$PrismaModel>;
type prismaNamespace_NestedEnumSchedulePeriodWithAggregatesFilter<$PrismaModel = never> = NestedEnumSchedulePeriodWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumScheduleStatusFilter<$PrismaModel = never> = NestedEnumScheduleStatusFilter<$PrismaModel>;
type prismaNamespace_NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumScheduleTypeFilter<$PrismaModel = never> = NestedEnumScheduleTypeFilter<$PrismaModel>;
type prismaNamespace_NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel = never> = NestedEnumScheduleTypeWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedEnumSlotStatusFilter<$PrismaModel = never> = NestedEnumSlotStatusFilter<$PrismaModel>;
type prismaNamespace_NestedEnumSlotStatusWithAggregatesFilter<$PrismaModel = never> = NestedEnumSlotStatusWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedFloatFilter<$PrismaModel = never> = NestedFloatFilter<$PrismaModel>;
type prismaNamespace_NestedFloatNullableFilter<$PrismaModel = never> = NestedFloatNullableFilter<$PrismaModel>;
type prismaNamespace_NestedIntFilter<$PrismaModel = never> = NestedIntFilter<$PrismaModel>;
type prismaNamespace_NestedIntNullableFilter<$PrismaModel = never> = NestedIntNullableFilter<$PrismaModel>;
type prismaNamespace_NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = NestedIntNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedIntWithAggregatesFilter<$PrismaModel = never> = NestedIntWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedJsonNullableFilter<$PrismaModel = never> = NestedJsonNullableFilter<$PrismaModel>;
type prismaNamespace_NestedJsonNullableFilterBase<$PrismaModel = never> = NestedJsonNullableFilterBase<$PrismaModel>;
type prismaNamespace_NestedStringFilter<$PrismaModel = never> = NestedStringFilter<$PrismaModel>;
type prismaNamespace_NestedStringNullableFilter<$PrismaModel = never> = NestedStringNullableFilter<$PrismaModel>;
type prismaNamespace_NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = NestedStringNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_NestedStringWithAggregatesFilter<$PrismaModel = never> = NestedStringWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_Not<B extends Boolean> = Not<B>;
type prismaNamespace_NotificationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationAggregateArgs<ExtArgs>;
type prismaNamespace_NotificationCountAggregateInputType = NotificationCountAggregateInputType;
type prismaNamespace_NotificationCountAggregateOutputType = NotificationCountAggregateOutputType;
type prismaNamespace_NotificationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationCountArgs<ExtArgs>;
type prismaNamespace_NotificationCountOrderByAggregateInput = NotificationCountOrderByAggregateInput;
type prismaNamespace_NotificationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationCreateArgs<ExtArgs>;
type prismaNamespace_NotificationCreateInput = NotificationCreateInput;
type prismaNamespace_NotificationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_NotificationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationCreateManyArgs<ExtArgs>;
type prismaNamespace_NotificationCreateManyInput = NotificationCreateManyInput;
type prismaNamespace_NotificationCreateManyUserInput = NotificationCreateManyUserInput;
type prismaNamespace_NotificationCreateManyUserInputEnvelope = NotificationCreateManyUserInputEnvelope;
type prismaNamespace_NotificationCreateNestedManyWithoutUserInput = NotificationCreateNestedManyWithoutUserInput;
type prismaNamespace_NotificationCreateOrConnectWithoutUserInput = NotificationCreateOrConnectWithoutUserInput;
type prismaNamespace_NotificationCreateWithoutUserInput = NotificationCreateWithoutUserInput;
type prismaNamespace_NotificationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>;
type prismaNamespace_NotificationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = NotificationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_NotificationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationDeleteArgs<ExtArgs>;
type prismaNamespace_NotificationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationDeleteManyArgs<ExtArgs>;
type prismaNamespace_NotificationFieldRefs = NotificationFieldRefs;
type prismaNamespace_NotificationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationFindFirstArgs<ExtArgs>;
type prismaNamespace_NotificationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_NotificationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationFindManyArgs<ExtArgs>;
type prismaNamespace_NotificationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationFindUniqueArgs<ExtArgs>;
type prismaNamespace_NotificationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = NotificationGetPayload<S>;
type prismaNamespace_NotificationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationGroupByArgs<ExtArgs>;
type prismaNamespace_NotificationGroupByOutputType = NotificationGroupByOutputType;
type prismaNamespace_NotificationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationInclude<ExtArgs>;
type prismaNamespace_NotificationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_NotificationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_NotificationListRelationFilter = NotificationListRelationFilter;
type prismaNamespace_NotificationMaxAggregateInputType = NotificationMaxAggregateInputType;
type prismaNamespace_NotificationMaxAggregateOutputType = NotificationMaxAggregateOutputType;
type prismaNamespace_NotificationMaxOrderByAggregateInput = NotificationMaxOrderByAggregateInput;
type prismaNamespace_NotificationMinAggregateInputType = NotificationMinAggregateInputType;
type prismaNamespace_NotificationMinAggregateOutputType = NotificationMinAggregateOutputType;
type prismaNamespace_NotificationMinOrderByAggregateInput = NotificationMinOrderByAggregateInput;
type prismaNamespace_NotificationModel = NotificationModel;
type prismaNamespace_NotificationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationOmit<ExtArgs>;
type prismaNamespace_NotificationOrderByRelationAggregateInput = NotificationOrderByRelationAggregateInput;
type prismaNamespace_NotificationOrderByWithAggregationInput = NotificationOrderByWithAggregationInput;
type prismaNamespace_NotificationOrderByWithRelationInput = NotificationOrderByWithRelationInput;
type prismaNamespace_NotificationScalarFieldEnum = NotificationScalarFieldEnum;
type prismaNamespace_NotificationScalarWhereInput = NotificationScalarWhereInput;
type prismaNamespace_NotificationScalarWhereWithAggregatesInput = NotificationScalarWhereWithAggregatesInput;
type prismaNamespace_NotificationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationSelect<ExtArgs>;
type prismaNamespace_NotificationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_NotificationSelectScalar = NotificationSelectScalar;
type prismaNamespace_NotificationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_NotificationUncheckedCreateInput = NotificationUncheckedCreateInput;
type prismaNamespace_NotificationUncheckedCreateNestedManyWithoutUserInput = NotificationUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_NotificationUncheckedCreateWithoutUserInput = NotificationUncheckedCreateWithoutUserInput;
type prismaNamespace_NotificationUncheckedUpdateInput = NotificationUncheckedUpdateInput;
type prismaNamespace_NotificationUncheckedUpdateManyInput = NotificationUncheckedUpdateManyInput;
type prismaNamespace_NotificationUncheckedUpdateManyWithoutUserInput = NotificationUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_NotificationUncheckedUpdateManyWithoutUserNestedInput = NotificationUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_NotificationUncheckedUpdateWithoutUserInput = NotificationUncheckedUpdateWithoutUserInput;
type prismaNamespace_NotificationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationUpdateArgs<ExtArgs>;
type prismaNamespace_NotificationUpdateInput = NotificationUpdateInput;
type prismaNamespace_NotificationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_NotificationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationUpdateManyArgs<ExtArgs>;
type prismaNamespace_NotificationUpdateManyMutationInput = NotificationUpdateManyMutationInput;
type prismaNamespace_NotificationUpdateManyWithWhereWithoutUserInput = NotificationUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_NotificationUpdateManyWithoutUserNestedInput = NotificationUpdateManyWithoutUserNestedInput;
type prismaNamespace_NotificationUpdateWithWhereUniqueWithoutUserInput = NotificationUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_NotificationUpdateWithoutUserInput = NotificationUpdateWithoutUserInput;
type prismaNamespace_NotificationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = NotificationUpsertArgs<ExtArgs>;
type prismaNamespace_NotificationUpsertWithWhereUniqueWithoutUserInput = NotificationUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_NotificationWhereInput = NotificationWhereInput;
type prismaNamespace_NotificationWhereUniqueInput = NotificationWhereUniqueInput;
declare const prismaNamespace_NullTypes: typeof NullTypes;
type prismaNamespace_NullableBoolFieldUpdateOperationsInput = NullableBoolFieldUpdateOperationsInput;
type prismaNamespace_NullableDateTimeFieldUpdateOperationsInput = NullableDateTimeFieldUpdateOperationsInput;
type prismaNamespace_NullableDecimalFieldUpdateOperationsInput = NullableDecimalFieldUpdateOperationsInput;
type prismaNamespace_NullableEnumRoleFieldUpdateOperationsInput = NullableEnumRoleFieldUpdateOperationsInput;
type prismaNamespace_NullableIntFieldUpdateOperationsInput = NullableIntFieldUpdateOperationsInput;
type prismaNamespace_NullableJsonNullValueInput = NullableJsonNullValueInput;
type prismaNamespace_NullableStringFieldUpdateOperationsInput = NullableStringFieldUpdateOperationsInput;
type prismaNamespace_NullsOrder = NullsOrder;
type prismaNamespace_OptionalFlat<O> = OptionalFlat<O>;
type prismaNamespace_Or<B1 extends Boolean, B2 extends Boolean> = Or<B1, B2>;
type prismaNamespace_Overwrite<O extends object, O1 extends object> = Overwrite<O, O1>;
type prismaNamespace_PatchUndefined<O extends object, O1 extends object> = PatchUndefined<O, O1>;
type prismaNamespace_Payload<T, F extends runtime.Operation = never> = Payload<T, F>;
type prismaNamespace_PaymentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentAggregateArgs<ExtArgs>;
type prismaNamespace_PaymentAvgAggregateInputType = PaymentAvgAggregateInputType;
type prismaNamespace_PaymentAvgAggregateOutputType = PaymentAvgAggregateOutputType;
type prismaNamespace_PaymentAvgOrderByAggregateInput = PaymentAvgOrderByAggregateInput;
type prismaNamespace_PaymentCountAggregateInputType = PaymentCountAggregateInputType;
type prismaNamespace_PaymentCountAggregateOutputType = PaymentCountAggregateOutputType;
type prismaNamespace_PaymentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentCountArgs<ExtArgs>;
type prismaNamespace_PaymentCountOrderByAggregateInput = PaymentCountOrderByAggregateInput;
type prismaNamespace_PaymentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentCreateArgs<ExtArgs>;
type prismaNamespace_PaymentCreateInput = PaymentCreateInput;
type prismaNamespace_PaymentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_PaymentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentCreateManyArgs<ExtArgs>;
type prismaNamespace_PaymentCreateManyInput = PaymentCreateManyInput;
type prismaNamespace_PaymentCreateManyUserInput = PaymentCreateManyUserInput;
type prismaNamespace_PaymentCreateManyUserInputEnvelope = PaymentCreateManyUserInputEnvelope;
type prismaNamespace_PaymentCreateNestedManyWithoutUserInput = PaymentCreateNestedManyWithoutUserInput;
type prismaNamespace_PaymentCreateNestedOneWithoutAppointmentInput = PaymentCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_PaymentCreateOrConnectWithoutAppointmentInput = PaymentCreateOrConnectWithoutAppointmentInput;
type prismaNamespace_PaymentCreateOrConnectWithoutUserInput = PaymentCreateOrConnectWithoutUserInput;
type prismaNamespace_PaymentCreateWithoutAppointmentInput = PaymentCreateWithoutAppointmentInput;
type prismaNamespace_PaymentCreateWithoutUserInput = PaymentCreateWithoutUserInput;
type prismaNamespace_PaymentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>;
type prismaNamespace_PaymentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = PaymentDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_PaymentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentDeleteArgs<ExtArgs>;
type prismaNamespace_PaymentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentDeleteManyArgs<ExtArgs>;
type prismaNamespace_PaymentFieldRefs = PaymentFieldRefs;
type prismaNamespace_PaymentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentFindFirstArgs<ExtArgs>;
type prismaNamespace_PaymentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_PaymentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentFindManyArgs<ExtArgs>;
type prismaNamespace_PaymentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentFindUniqueArgs<ExtArgs>;
type prismaNamespace_PaymentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = PaymentGetPayload<S>;
type prismaNamespace_PaymentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentGroupByArgs<ExtArgs>;
type prismaNamespace_PaymentGroupByOutputType = PaymentGroupByOutputType;
type prismaNamespace_PaymentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentInclude<ExtArgs>;
type prismaNamespace_PaymentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_PaymentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_PaymentListRelationFilter = PaymentListRelationFilter;
type prismaNamespace_PaymentMaxAggregateInputType = PaymentMaxAggregateInputType;
type prismaNamespace_PaymentMaxAggregateOutputType = PaymentMaxAggregateOutputType;
type prismaNamespace_PaymentMaxOrderByAggregateInput = PaymentMaxOrderByAggregateInput;
type prismaNamespace_PaymentMinAggregateInputType = PaymentMinAggregateInputType;
type prismaNamespace_PaymentMinAggregateOutputType = PaymentMinAggregateOutputType;
type prismaNamespace_PaymentMinOrderByAggregateInput = PaymentMinOrderByAggregateInput;
type prismaNamespace_PaymentModel = PaymentModel;
type prismaNamespace_PaymentNullableScalarRelationFilter = PaymentNullableScalarRelationFilter;
type prismaNamespace_PaymentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentOmit<ExtArgs>;
type prismaNamespace_PaymentOrderByRelationAggregateInput = PaymentOrderByRelationAggregateInput;
type prismaNamespace_PaymentOrderByWithAggregationInput = PaymentOrderByWithAggregationInput;
type prismaNamespace_PaymentOrderByWithRelationInput = PaymentOrderByWithRelationInput;
type prismaNamespace_PaymentScalarFieldEnum = PaymentScalarFieldEnum;
type prismaNamespace_PaymentScalarWhereInput = PaymentScalarWhereInput;
type prismaNamespace_PaymentScalarWhereWithAggregatesInput = PaymentScalarWhereWithAggregatesInput;
type prismaNamespace_PaymentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentSelect<ExtArgs>;
type prismaNamespace_PaymentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_PaymentSelectScalar = PaymentSelectScalar;
type prismaNamespace_PaymentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_PaymentSumAggregateInputType = PaymentSumAggregateInputType;
type prismaNamespace_PaymentSumAggregateOutputType = PaymentSumAggregateOutputType;
type prismaNamespace_PaymentSumOrderByAggregateInput = PaymentSumOrderByAggregateInput;
type prismaNamespace_PaymentUncheckedCreateInput = PaymentUncheckedCreateInput;
type prismaNamespace_PaymentUncheckedCreateNestedManyWithoutUserInput = PaymentUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_PaymentUncheckedCreateNestedOneWithoutAppointmentInput = PaymentUncheckedCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_PaymentUncheckedCreateWithoutAppointmentInput = PaymentUncheckedCreateWithoutAppointmentInput;
type prismaNamespace_PaymentUncheckedCreateWithoutUserInput = PaymentUncheckedCreateWithoutUserInput;
type prismaNamespace_PaymentUncheckedUpdateInput = PaymentUncheckedUpdateInput;
type prismaNamespace_PaymentUncheckedUpdateManyInput = PaymentUncheckedUpdateManyInput;
type prismaNamespace_PaymentUncheckedUpdateManyWithoutUserInput = PaymentUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_PaymentUncheckedUpdateManyWithoutUserNestedInput = PaymentUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_PaymentUncheckedUpdateOneWithoutAppointmentNestedInput = PaymentUncheckedUpdateOneWithoutAppointmentNestedInput;
type prismaNamespace_PaymentUncheckedUpdateWithoutAppointmentInput = PaymentUncheckedUpdateWithoutAppointmentInput;
type prismaNamespace_PaymentUncheckedUpdateWithoutUserInput = PaymentUncheckedUpdateWithoutUserInput;
type prismaNamespace_PaymentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentUpdateArgs<ExtArgs>;
type prismaNamespace_PaymentUpdateInput = PaymentUpdateInput;
type prismaNamespace_PaymentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_PaymentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentUpdateManyArgs<ExtArgs>;
type prismaNamespace_PaymentUpdateManyMutationInput = PaymentUpdateManyMutationInput;
type prismaNamespace_PaymentUpdateManyWithWhereWithoutUserInput = PaymentUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_PaymentUpdateManyWithoutUserNestedInput = PaymentUpdateManyWithoutUserNestedInput;
type prismaNamespace_PaymentUpdateOneWithoutAppointmentNestedInput = PaymentUpdateOneWithoutAppointmentNestedInput;
type prismaNamespace_PaymentUpdateToOneWithWhereWithoutAppointmentInput = PaymentUpdateToOneWithWhereWithoutAppointmentInput;
type prismaNamespace_PaymentUpdateWithWhereUniqueWithoutUserInput = PaymentUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_PaymentUpdateWithoutAppointmentInput = PaymentUpdateWithoutAppointmentInput;
type prismaNamespace_PaymentUpdateWithoutUserInput = PaymentUpdateWithoutUserInput;
type prismaNamespace_PaymentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = PaymentUpsertArgs<ExtArgs>;
type prismaNamespace_PaymentUpsertWithWhereUniqueWithoutUserInput = PaymentUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_PaymentUpsertWithoutAppointmentInput = PaymentUpsertWithoutAppointmentInput;
type prismaNamespace_PaymentWhereInput = PaymentWhereInput;
type prismaNamespace_PaymentWhereUniqueInput = PaymentWhereUniqueInput;
type prismaNamespace_PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = PickEnumerable<T, K>;
type prismaNamespace_PrismaAction = PrismaAction;
type prismaNamespace_PrismaClientInitializationError = PrismaClientInitializationError;
type prismaNamespace_PrismaClientKnownRequestError = PrismaClientKnownRequestError;
type prismaNamespace_PrismaClientOptions = PrismaClientOptions;
type prismaNamespace_PrismaClientRustPanicError = PrismaClientRustPanicError;
type prismaNamespace_PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
type prismaNamespace_PrismaClientValidationError = PrismaClientValidationError;
type prismaNamespace_PrismaPromise<T> = PrismaPromise<T>;
type prismaNamespace_PrismaVersion = PrismaVersion;
type prismaNamespace_Prisma__AppointmentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__AppointmentClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__AuditLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__AuditLogClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__DoctorApplicationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__DoctorApplicationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__DoctorClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__DoctorClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__DoctorHospitalProfileClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__DoctorHospitalProfileClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__DoctorSpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__DoctorSpecializationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__HospitalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__HospitalClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__HospitalSpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__HospitalSpecializationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__NotificationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__NotificationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__PaymentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__PaymentClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__ReviewClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__ReviewClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__SavedDoctorHospitalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__SavedDoctorHospitalClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__ScheduleClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__ScheduleClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__SearchLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__SearchLogClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__SlotClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__SlotClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__SpecializationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__SpecializationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__UserClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__UserClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__accountClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__accountClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__sessionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__sessionClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_Prisma__verificationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = Prisma__verificationClient<T, Null, ExtArgs, GlobalOmitOptions>;
type prismaNamespace_QueryEvent = QueryEvent;
type prismaNamespace_QueryMode = QueryMode;
type prismaNamespace_Result<T, A, F extends runtime.Operation> = Result<T, A, F>;
type prismaNamespace_Review$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Review$DoctorArgs<ExtArgs>;
type prismaNamespace_Review$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Review$HospitalArgs<ExtArgs>;
type prismaNamespace_ReviewAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewAggregateArgs<ExtArgs>;
type prismaNamespace_ReviewAvgAggregateInputType = ReviewAvgAggregateInputType;
type prismaNamespace_ReviewAvgAggregateOutputType = ReviewAvgAggregateOutputType;
type prismaNamespace_ReviewAvgOrderByAggregateInput = ReviewAvgOrderByAggregateInput;
type prismaNamespace_ReviewCountAggregateInputType = ReviewCountAggregateInputType;
type prismaNamespace_ReviewCountAggregateOutputType = ReviewCountAggregateOutputType;
type prismaNamespace_ReviewCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewCountArgs<ExtArgs>;
type prismaNamespace_ReviewCountOrderByAggregateInput = ReviewCountOrderByAggregateInput;
type prismaNamespace_ReviewCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewCreateArgs<ExtArgs>;
type prismaNamespace_ReviewCreateInput = ReviewCreateInput;
type prismaNamespace_ReviewCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_ReviewCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewCreateManyArgs<ExtArgs>;
type prismaNamespace_ReviewCreateManyDoctorInput = ReviewCreateManyDoctorInput;
type prismaNamespace_ReviewCreateManyDoctorInputEnvelope = ReviewCreateManyDoctorInputEnvelope;
type prismaNamespace_ReviewCreateManyHospitalInput = ReviewCreateManyHospitalInput;
type prismaNamespace_ReviewCreateManyHospitalInputEnvelope = ReviewCreateManyHospitalInputEnvelope;
type prismaNamespace_ReviewCreateManyInput = ReviewCreateManyInput;
type prismaNamespace_ReviewCreateManyUserInput = ReviewCreateManyUserInput;
type prismaNamespace_ReviewCreateManyUserInputEnvelope = ReviewCreateManyUserInputEnvelope;
type prismaNamespace_ReviewCreateNestedManyWithoutDoctorInput = ReviewCreateNestedManyWithoutDoctorInput;
type prismaNamespace_ReviewCreateNestedManyWithoutHospitalInput = ReviewCreateNestedManyWithoutHospitalInput;
type prismaNamespace_ReviewCreateNestedManyWithoutUserInput = ReviewCreateNestedManyWithoutUserInput;
type prismaNamespace_ReviewCreateOrConnectWithoutDoctorInput = ReviewCreateOrConnectWithoutDoctorInput;
type prismaNamespace_ReviewCreateOrConnectWithoutHospitalInput = ReviewCreateOrConnectWithoutHospitalInput;
type prismaNamespace_ReviewCreateOrConnectWithoutUserInput = ReviewCreateOrConnectWithoutUserInput;
type prismaNamespace_ReviewCreateWithoutDoctorInput = ReviewCreateWithoutDoctorInput;
type prismaNamespace_ReviewCreateWithoutHospitalInput = ReviewCreateWithoutHospitalInput;
type prismaNamespace_ReviewCreateWithoutUserInput = ReviewCreateWithoutUserInput;
type prismaNamespace_ReviewDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>;
type prismaNamespace_ReviewDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = ReviewDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_ReviewDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewDeleteArgs<ExtArgs>;
type prismaNamespace_ReviewDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewDeleteManyArgs<ExtArgs>;
type prismaNamespace_ReviewFieldRefs = ReviewFieldRefs;
type prismaNamespace_ReviewFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewFindFirstArgs<ExtArgs>;
type prismaNamespace_ReviewFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_ReviewFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewFindManyArgs<ExtArgs>;
type prismaNamespace_ReviewFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewFindUniqueArgs<ExtArgs>;
type prismaNamespace_ReviewFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = ReviewGetPayload<S>;
type prismaNamespace_ReviewGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewGroupByArgs<ExtArgs>;
type prismaNamespace_ReviewGroupByOutputType = ReviewGroupByOutputType;
type prismaNamespace_ReviewInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewInclude<ExtArgs>;
type prismaNamespace_ReviewIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_ReviewIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_ReviewListRelationFilter = ReviewListRelationFilter;
type prismaNamespace_ReviewMaxAggregateInputType = ReviewMaxAggregateInputType;
type prismaNamespace_ReviewMaxAggregateOutputType = ReviewMaxAggregateOutputType;
type prismaNamespace_ReviewMaxOrderByAggregateInput = ReviewMaxOrderByAggregateInput;
type prismaNamespace_ReviewMinAggregateInputType = ReviewMinAggregateInputType;
type prismaNamespace_ReviewMinAggregateOutputType = ReviewMinAggregateOutputType;
type prismaNamespace_ReviewMinOrderByAggregateInput = ReviewMinOrderByAggregateInput;
type prismaNamespace_ReviewModel = ReviewModel;
type prismaNamespace_ReviewOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewOmit<ExtArgs>;
type prismaNamespace_ReviewOrderByRelationAggregateInput = ReviewOrderByRelationAggregateInput;
type prismaNamespace_ReviewOrderByWithAggregationInput = ReviewOrderByWithAggregationInput;
type prismaNamespace_ReviewOrderByWithRelationInput = ReviewOrderByWithRelationInput;
type prismaNamespace_ReviewScalarFieldEnum = ReviewScalarFieldEnum;
type prismaNamespace_ReviewScalarWhereInput = ReviewScalarWhereInput;
type prismaNamespace_ReviewScalarWhereWithAggregatesInput = ReviewScalarWhereWithAggregatesInput;
type prismaNamespace_ReviewSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewSelect<ExtArgs>;
type prismaNamespace_ReviewSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_ReviewSelectScalar = ReviewSelectScalar;
type prismaNamespace_ReviewSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_ReviewSumAggregateInputType = ReviewSumAggregateInputType;
type prismaNamespace_ReviewSumAggregateOutputType = ReviewSumAggregateOutputType;
type prismaNamespace_ReviewSumOrderByAggregateInput = ReviewSumOrderByAggregateInput;
type prismaNamespace_ReviewUncheckedCreateInput = ReviewUncheckedCreateInput;
type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutDoctorInput = ReviewUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutHospitalInput = ReviewUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutUserInput = ReviewUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_ReviewUncheckedCreateWithoutDoctorInput = ReviewUncheckedCreateWithoutDoctorInput;
type prismaNamespace_ReviewUncheckedCreateWithoutHospitalInput = ReviewUncheckedCreateWithoutHospitalInput;
type prismaNamespace_ReviewUncheckedCreateWithoutUserInput = ReviewUncheckedCreateWithoutUserInput;
type prismaNamespace_ReviewUncheckedUpdateInput = ReviewUncheckedUpdateInput;
type prismaNamespace_ReviewUncheckedUpdateManyInput = ReviewUncheckedUpdateManyInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutDoctorInput = ReviewUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutDoctorNestedInput = ReviewUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutHospitalInput = ReviewUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutHospitalNestedInput = ReviewUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutUserInput = ReviewUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_ReviewUncheckedUpdateManyWithoutUserNestedInput = ReviewUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_ReviewUncheckedUpdateWithoutDoctorInput = ReviewUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_ReviewUncheckedUpdateWithoutHospitalInput = ReviewUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_ReviewUncheckedUpdateWithoutUserInput = ReviewUncheckedUpdateWithoutUserInput;
type prismaNamespace_ReviewUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewUpdateArgs<ExtArgs>;
type prismaNamespace_ReviewUpdateInput = ReviewUpdateInput;
type prismaNamespace_ReviewUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_ReviewUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewUpdateManyArgs<ExtArgs>;
type prismaNamespace_ReviewUpdateManyMutationInput = ReviewUpdateManyMutationInput;
type prismaNamespace_ReviewUpdateManyWithWhereWithoutDoctorInput = ReviewUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_ReviewUpdateManyWithWhereWithoutHospitalInput = ReviewUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_ReviewUpdateManyWithWhereWithoutUserInput = ReviewUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_ReviewUpdateManyWithoutDoctorNestedInput = ReviewUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_ReviewUpdateManyWithoutHospitalNestedInput = ReviewUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_ReviewUpdateManyWithoutUserNestedInput = ReviewUpdateManyWithoutUserNestedInput;
type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutDoctorInput = ReviewUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutHospitalInput = ReviewUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutUserInput = ReviewUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_ReviewUpdateWithoutDoctorInput = ReviewUpdateWithoutDoctorInput;
type prismaNamespace_ReviewUpdateWithoutHospitalInput = ReviewUpdateWithoutHospitalInput;
type prismaNamespace_ReviewUpdateWithoutUserInput = ReviewUpdateWithoutUserInput;
type prismaNamespace_ReviewUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ReviewUpsertArgs<ExtArgs>;
type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutDoctorInput = ReviewUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutHospitalInput = ReviewUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutUserInput = ReviewUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_ReviewWhereInput = ReviewWhereInput;
type prismaNamespace_ReviewWhereUniqueInput = ReviewWhereUniqueInput;
type prismaNamespace_SavedDoctorHospital$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospital$DoctorArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospital$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospital$HospitalArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalAggregateArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalCountAggregateInputType = SavedDoctorHospitalCountAggregateInputType;
type prismaNamespace_SavedDoctorHospitalCountAggregateOutputType = SavedDoctorHospitalCountAggregateOutputType;
type prismaNamespace_SavedDoctorHospitalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalCountArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalCountOrderByAggregateInput = SavedDoctorHospitalCountOrderByAggregateInput;
type prismaNamespace_SavedDoctorHospitalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalCreateArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalCreateInput = SavedDoctorHospitalCreateInput;
type prismaNamespace_SavedDoctorHospitalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalCreateManyArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalCreateManyDoctorInput = SavedDoctorHospitalCreateManyDoctorInput;
type prismaNamespace_SavedDoctorHospitalCreateManyDoctorInputEnvelope = SavedDoctorHospitalCreateManyDoctorInputEnvelope;
type prismaNamespace_SavedDoctorHospitalCreateManyHospitalInput = SavedDoctorHospitalCreateManyHospitalInput;
type prismaNamespace_SavedDoctorHospitalCreateManyHospitalInputEnvelope = SavedDoctorHospitalCreateManyHospitalInputEnvelope;
type prismaNamespace_SavedDoctorHospitalCreateManyInput = SavedDoctorHospitalCreateManyInput;
type prismaNamespace_SavedDoctorHospitalCreateManyUserInput = SavedDoctorHospitalCreateManyUserInput;
type prismaNamespace_SavedDoctorHospitalCreateManyUserInputEnvelope = SavedDoctorHospitalCreateManyUserInputEnvelope;
type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutDoctorInput = SavedDoctorHospitalCreateNestedManyWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutHospitalInput = SavedDoctorHospitalCreateNestedManyWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutUserInput = SavedDoctorHospitalCreateNestedManyWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutDoctorInput = SavedDoctorHospitalCreateOrConnectWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutHospitalInput = SavedDoctorHospitalCreateOrConnectWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutUserInput = SavedDoctorHospitalCreateOrConnectWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalCreateWithoutDoctorInput = SavedDoctorHospitalCreateWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalCreateWithoutHospitalInput = SavedDoctorHospitalCreateWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalCreateWithoutUserInput = SavedDoctorHospitalCreateWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalDefaultArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = SavedDoctorHospitalDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_SavedDoctorHospitalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalDeleteArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalDeleteManyArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalFieldRefs = SavedDoctorHospitalFieldRefs;
type prismaNamespace_SavedDoctorHospitalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalFindFirstArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalFindManyArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalFindUniqueArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalGetPayload<S extends boolean | null | undefined | SavedDoctorHospitalDefaultArgs> = SavedDoctorHospitalGetPayload<S>;
type prismaNamespace_SavedDoctorHospitalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalGroupByArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalGroupByOutputType = SavedDoctorHospitalGroupByOutputType;
type prismaNamespace_SavedDoctorHospitalInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalInclude<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalListRelationFilter = SavedDoctorHospitalListRelationFilter;
type prismaNamespace_SavedDoctorHospitalMaxAggregateInputType = SavedDoctorHospitalMaxAggregateInputType;
type prismaNamespace_SavedDoctorHospitalMaxAggregateOutputType = SavedDoctorHospitalMaxAggregateOutputType;
type prismaNamespace_SavedDoctorHospitalMaxOrderByAggregateInput = SavedDoctorHospitalMaxOrderByAggregateInput;
type prismaNamespace_SavedDoctorHospitalMinAggregateInputType = SavedDoctorHospitalMinAggregateInputType;
type prismaNamespace_SavedDoctorHospitalMinAggregateOutputType = SavedDoctorHospitalMinAggregateOutputType;
type prismaNamespace_SavedDoctorHospitalMinOrderByAggregateInput = SavedDoctorHospitalMinOrderByAggregateInput;
type prismaNamespace_SavedDoctorHospitalModel = SavedDoctorHospitalModel;
type prismaNamespace_SavedDoctorHospitalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalOmit<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalOrderByRelationAggregateInput = SavedDoctorHospitalOrderByRelationAggregateInput;
type prismaNamespace_SavedDoctorHospitalOrderByWithAggregationInput = SavedDoctorHospitalOrderByWithAggregationInput;
type prismaNamespace_SavedDoctorHospitalOrderByWithRelationInput = SavedDoctorHospitalOrderByWithRelationInput;
type prismaNamespace_SavedDoctorHospitalScalarFieldEnum = SavedDoctorHospitalScalarFieldEnum;
type prismaNamespace_SavedDoctorHospitalScalarWhereInput = SavedDoctorHospitalScalarWhereInput;
type prismaNamespace_SavedDoctorHospitalScalarWhereWithAggregatesInput = SavedDoctorHospitalScalarWhereWithAggregatesInput;
type prismaNamespace_SavedDoctorHospitalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalSelect<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalSelectScalar = SavedDoctorHospitalSelectScalar;
type prismaNamespace_SavedDoctorHospitalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateInput = SavedDoctorHospitalUncheckedCreateInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput = SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput = SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput = SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutDoctorInput = SavedDoctorHospitalUncheckedCreateWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutHospitalInput = SavedDoctorHospitalUncheckedCreateWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutUserInput = SavedDoctorHospitalUncheckedCreateWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateInput = SavedDoctorHospitalUncheckedUpdateInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyInput = SavedDoctorHospitalUncheckedUpdateManyInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput = SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput = SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput = SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput = SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput = SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput = SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput = SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput = SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutUserInput = SavedDoctorHospitalUncheckedUpdateWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalUpdateArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalUpdateInput = SavedDoctorHospitalUpdateInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalUpdateManyArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalUpdateManyMutationInput = SavedDoctorHospitalUpdateManyMutationInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput = SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput = SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput = SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput = SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput = SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutUserNestedInput = SavedDoctorHospitalUpdateManyWithoutUserNestedInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput = SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput = SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput = SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithoutDoctorInput = SavedDoctorHospitalUpdateWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithoutHospitalInput = SavedDoctorHospitalUpdateWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUpdateWithoutUserInput = SavedDoctorHospitalUpdateWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SavedDoctorHospitalUpsertArgs<ExtArgs>;
type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput = SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput = SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput = SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_SavedDoctorHospitalWhereInput = SavedDoctorHospitalWhereInput;
type prismaNamespace_SavedDoctorHospitalWhereUniqueInput = SavedDoctorHospitalWhereUniqueInput;
type prismaNamespace_Schedule$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Schedule$AppointmentArgs<ExtArgs>;
type prismaNamespace_Schedule$SlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Schedule$SlotArgs<ExtArgs>;
type prismaNamespace_ScheduleAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleAggregateArgs<ExtArgs>;
type prismaNamespace_ScheduleAvgAggregateInputType = ScheduleAvgAggregateInputType;
type prismaNamespace_ScheduleAvgAggregateOutputType = ScheduleAvgAggregateOutputType;
type prismaNamespace_ScheduleAvgOrderByAggregateInput = ScheduleAvgOrderByAggregateInput;
type prismaNamespace_ScheduleCountAggregateInputType = ScheduleCountAggregateInputType;
type prismaNamespace_ScheduleCountAggregateOutputType = ScheduleCountAggregateOutputType;
type prismaNamespace_ScheduleCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCountArgs<ExtArgs>;
type prismaNamespace_ScheduleCountOrderByAggregateInput = ScheduleCountOrderByAggregateInput;
type prismaNamespace_ScheduleCountOutputType = ScheduleCountOutputType;
type prismaNamespace_ScheduleCountOutputTypeCountAppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCountOutputTypeCountAppointmentArgs<ExtArgs>;
type prismaNamespace_ScheduleCountOutputTypeCountSlotArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCountOutputTypeCountSlotArgs<ExtArgs>;
type prismaNamespace_ScheduleCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCountOutputTypeDefaultArgs<ExtArgs>;
type prismaNamespace_ScheduleCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCountOutputTypeSelect<ExtArgs>;
type prismaNamespace_ScheduleCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCreateArgs<ExtArgs>;
type prismaNamespace_ScheduleCreateInput = ScheduleCreateInput;
type prismaNamespace_ScheduleCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_ScheduleCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleCreateManyArgs<ExtArgs>;
type prismaNamespace_ScheduleCreateManyDoctorInput = ScheduleCreateManyDoctorInput;
type prismaNamespace_ScheduleCreateManyDoctorInputEnvelope = ScheduleCreateManyDoctorInputEnvelope;
type prismaNamespace_ScheduleCreateManyHospitalInput = ScheduleCreateManyHospitalInput;
type prismaNamespace_ScheduleCreateManyHospitalInputEnvelope = ScheduleCreateManyHospitalInputEnvelope;
type prismaNamespace_ScheduleCreateManyInput = ScheduleCreateManyInput;
type prismaNamespace_ScheduleCreateManyUserInput = ScheduleCreateManyUserInput;
type prismaNamespace_ScheduleCreateManyUserInputEnvelope = ScheduleCreateManyUserInputEnvelope;
type prismaNamespace_ScheduleCreateNestedManyWithoutDoctorInput = ScheduleCreateNestedManyWithoutDoctorInput;
type prismaNamespace_ScheduleCreateNestedManyWithoutHospitalInput = ScheduleCreateNestedManyWithoutHospitalInput;
type prismaNamespace_ScheduleCreateNestedManyWithoutUserInput = ScheduleCreateNestedManyWithoutUserInput;
type prismaNamespace_ScheduleCreateNestedOneWithoutAppointmentInput = ScheduleCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_ScheduleCreateNestedOneWithoutSlotInput = ScheduleCreateNestedOneWithoutSlotInput;
type prismaNamespace_ScheduleCreateOrConnectWithoutAppointmentInput = ScheduleCreateOrConnectWithoutAppointmentInput;
type prismaNamespace_ScheduleCreateOrConnectWithoutDoctorInput = ScheduleCreateOrConnectWithoutDoctorInput;
type prismaNamespace_ScheduleCreateOrConnectWithoutHospitalInput = ScheduleCreateOrConnectWithoutHospitalInput;
type prismaNamespace_ScheduleCreateOrConnectWithoutSlotInput = ScheduleCreateOrConnectWithoutSlotInput;
type prismaNamespace_ScheduleCreateOrConnectWithoutUserInput = ScheduleCreateOrConnectWithoutUserInput;
type prismaNamespace_ScheduleCreateWithoutAppointmentInput = ScheduleCreateWithoutAppointmentInput;
type prismaNamespace_ScheduleCreateWithoutDoctorInput = ScheduleCreateWithoutDoctorInput;
type prismaNamespace_ScheduleCreateWithoutHospitalInput = ScheduleCreateWithoutHospitalInput;
type prismaNamespace_ScheduleCreateWithoutSlotInput = ScheduleCreateWithoutSlotInput;
type prismaNamespace_ScheduleCreateWithoutUserInput = ScheduleCreateWithoutUserInput;
type prismaNamespace_ScheduleCreatedayOfWeekInput = ScheduleCreatedayOfWeekInput;
type prismaNamespace_ScheduleDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>;
type prismaNamespace_ScheduleDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = ScheduleDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_ScheduleDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleDeleteArgs<ExtArgs>;
type prismaNamespace_ScheduleDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleDeleteManyArgs<ExtArgs>;
type prismaNamespace_ScheduleFieldRefs = ScheduleFieldRefs;
type prismaNamespace_ScheduleFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleFindFirstArgs<ExtArgs>;
type prismaNamespace_ScheduleFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_ScheduleFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleFindManyArgs<ExtArgs>;
type prismaNamespace_ScheduleFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleFindUniqueArgs<ExtArgs>;
type prismaNamespace_ScheduleFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = ScheduleGetPayload<S>;
type prismaNamespace_ScheduleGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleGroupByArgs<ExtArgs>;
type prismaNamespace_ScheduleGroupByOutputType = ScheduleGroupByOutputType;
type prismaNamespace_ScheduleInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleInclude<ExtArgs>;
type prismaNamespace_ScheduleIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_ScheduleIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_ScheduleListRelationFilter = ScheduleListRelationFilter;
type prismaNamespace_ScheduleMaxAggregateInputType = ScheduleMaxAggregateInputType;
type prismaNamespace_ScheduleMaxAggregateOutputType = ScheduleMaxAggregateOutputType;
type prismaNamespace_ScheduleMaxOrderByAggregateInput = ScheduleMaxOrderByAggregateInput;
type prismaNamespace_ScheduleMinAggregateInputType = ScheduleMinAggregateInputType;
type prismaNamespace_ScheduleMinAggregateOutputType = ScheduleMinAggregateOutputType;
type prismaNamespace_ScheduleMinOrderByAggregateInput = ScheduleMinOrderByAggregateInput;
type prismaNamespace_ScheduleModel = ScheduleModel;
type prismaNamespace_ScheduleOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleOmit<ExtArgs>;
type prismaNamespace_ScheduleOrderByRelationAggregateInput = ScheduleOrderByRelationAggregateInput;
type prismaNamespace_ScheduleOrderByWithAggregationInput = ScheduleOrderByWithAggregationInput;
type prismaNamespace_ScheduleOrderByWithRelationInput = ScheduleOrderByWithRelationInput;
type prismaNamespace_ScheduleScalarFieldEnum = ScheduleScalarFieldEnum;
type prismaNamespace_ScheduleScalarRelationFilter = ScheduleScalarRelationFilter;
type prismaNamespace_ScheduleScalarWhereInput = ScheduleScalarWhereInput;
type prismaNamespace_ScheduleScalarWhereWithAggregatesInput = ScheduleScalarWhereWithAggregatesInput;
type prismaNamespace_ScheduleSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleSelect<ExtArgs>;
type prismaNamespace_ScheduleSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_ScheduleSelectScalar = ScheduleSelectScalar;
type prismaNamespace_ScheduleSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_ScheduleSumAggregateInputType = ScheduleSumAggregateInputType;
type prismaNamespace_ScheduleSumAggregateOutputType = ScheduleSumAggregateOutputType;
type prismaNamespace_ScheduleSumOrderByAggregateInput = ScheduleSumOrderByAggregateInput;
type prismaNamespace_ScheduleUncheckedCreateInput = ScheduleUncheckedCreateInput;
type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutDoctorInput = ScheduleUncheckedCreateNestedManyWithoutDoctorInput;
type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutHospitalInput = ScheduleUncheckedCreateNestedManyWithoutHospitalInput;
type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutUserInput = ScheduleUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_ScheduleUncheckedCreateWithoutAppointmentInput = ScheduleUncheckedCreateWithoutAppointmentInput;
type prismaNamespace_ScheduleUncheckedCreateWithoutDoctorInput = ScheduleUncheckedCreateWithoutDoctorInput;
type prismaNamespace_ScheduleUncheckedCreateWithoutHospitalInput = ScheduleUncheckedCreateWithoutHospitalInput;
type prismaNamespace_ScheduleUncheckedCreateWithoutSlotInput = ScheduleUncheckedCreateWithoutSlotInput;
type prismaNamespace_ScheduleUncheckedCreateWithoutUserInput = ScheduleUncheckedCreateWithoutUserInput;
type prismaNamespace_ScheduleUncheckedUpdateInput = ScheduleUncheckedUpdateInput;
type prismaNamespace_ScheduleUncheckedUpdateManyInput = ScheduleUncheckedUpdateManyInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutDoctorInput = ScheduleUncheckedUpdateManyWithoutDoctorInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutDoctorNestedInput = ScheduleUncheckedUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutHospitalInput = ScheduleUncheckedUpdateManyWithoutHospitalInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutHospitalNestedInput = ScheduleUncheckedUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutUserInput = ScheduleUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_ScheduleUncheckedUpdateManyWithoutUserNestedInput = ScheduleUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_ScheduleUncheckedUpdateWithoutAppointmentInput = ScheduleUncheckedUpdateWithoutAppointmentInput;
type prismaNamespace_ScheduleUncheckedUpdateWithoutDoctorInput = ScheduleUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_ScheduleUncheckedUpdateWithoutHospitalInput = ScheduleUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_ScheduleUncheckedUpdateWithoutSlotInput = ScheduleUncheckedUpdateWithoutSlotInput;
type prismaNamespace_ScheduleUncheckedUpdateWithoutUserInput = ScheduleUncheckedUpdateWithoutUserInput;
type prismaNamespace_ScheduleUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleUpdateArgs<ExtArgs>;
type prismaNamespace_ScheduleUpdateInput = ScheduleUpdateInput;
type prismaNamespace_ScheduleUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_ScheduleUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleUpdateManyArgs<ExtArgs>;
type prismaNamespace_ScheduleUpdateManyMutationInput = ScheduleUpdateManyMutationInput;
type prismaNamespace_ScheduleUpdateManyWithWhereWithoutDoctorInput = ScheduleUpdateManyWithWhereWithoutDoctorInput;
type prismaNamespace_ScheduleUpdateManyWithWhereWithoutHospitalInput = ScheduleUpdateManyWithWhereWithoutHospitalInput;
type prismaNamespace_ScheduleUpdateManyWithWhereWithoutUserInput = ScheduleUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_ScheduleUpdateManyWithoutDoctorNestedInput = ScheduleUpdateManyWithoutDoctorNestedInput;
type prismaNamespace_ScheduleUpdateManyWithoutHospitalNestedInput = ScheduleUpdateManyWithoutHospitalNestedInput;
type prismaNamespace_ScheduleUpdateManyWithoutUserNestedInput = ScheduleUpdateManyWithoutUserNestedInput;
type prismaNamespace_ScheduleUpdateOneRequiredWithoutAppointmentNestedInput = ScheduleUpdateOneRequiredWithoutAppointmentNestedInput;
type prismaNamespace_ScheduleUpdateOneRequiredWithoutSlotNestedInput = ScheduleUpdateOneRequiredWithoutSlotNestedInput;
type prismaNamespace_ScheduleUpdateToOneWithWhereWithoutAppointmentInput = ScheduleUpdateToOneWithWhereWithoutAppointmentInput;
type prismaNamespace_ScheduleUpdateToOneWithWhereWithoutSlotInput = ScheduleUpdateToOneWithWhereWithoutSlotInput;
type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutDoctorInput = ScheduleUpdateWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutHospitalInput = ScheduleUpdateWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutUserInput = ScheduleUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_ScheduleUpdateWithoutAppointmentInput = ScheduleUpdateWithoutAppointmentInput;
type prismaNamespace_ScheduleUpdateWithoutDoctorInput = ScheduleUpdateWithoutDoctorInput;
type prismaNamespace_ScheduleUpdateWithoutHospitalInput = ScheduleUpdateWithoutHospitalInput;
type prismaNamespace_ScheduleUpdateWithoutSlotInput = ScheduleUpdateWithoutSlotInput;
type prismaNamespace_ScheduleUpdateWithoutUserInput = ScheduleUpdateWithoutUserInput;
type prismaNamespace_ScheduleUpdatedayOfWeekInput = ScheduleUpdatedayOfWeekInput;
type prismaNamespace_ScheduleUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = ScheduleUpsertArgs<ExtArgs>;
type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutDoctorInput = ScheduleUpsertWithWhereUniqueWithoutDoctorInput;
type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutHospitalInput = ScheduleUpsertWithWhereUniqueWithoutHospitalInput;
type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutUserInput = ScheduleUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_ScheduleUpsertWithoutAppointmentInput = ScheduleUpsertWithoutAppointmentInput;
type prismaNamespace_ScheduleUpsertWithoutSlotInput = ScheduleUpsertWithoutSlotInput;
type prismaNamespace_ScheduleWhereInput = ScheduleWhereInput;
type prismaNamespace_ScheduleWhereUniqueInput = ScheduleWhereUniqueInput;
type prismaNamespace_SearchLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogAggregateArgs<ExtArgs>;
type prismaNamespace_SearchLogCountAggregateInputType = SearchLogCountAggregateInputType;
type prismaNamespace_SearchLogCountAggregateOutputType = SearchLogCountAggregateOutputType;
type prismaNamespace_SearchLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogCountArgs<ExtArgs>;
type prismaNamespace_SearchLogCountOrderByAggregateInput = SearchLogCountOrderByAggregateInput;
type prismaNamespace_SearchLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogCreateArgs<ExtArgs>;
type prismaNamespace_SearchLogCreateInput = SearchLogCreateInput;
type prismaNamespace_SearchLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SearchLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogCreateManyArgs<ExtArgs>;
type prismaNamespace_SearchLogCreateManyInput = SearchLogCreateManyInput;
type prismaNamespace_SearchLogCreateManyUserInput = SearchLogCreateManyUserInput;
type prismaNamespace_SearchLogCreateManyUserInputEnvelope = SearchLogCreateManyUserInputEnvelope;
type prismaNamespace_SearchLogCreateNestedManyWithoutUserInput = SearchLogCreateNestedManyWithoutUserInput;
type prismaNamespace_SearchLogCreateOrConnectWithoutUserInput = SearchLogCreateOrConnectWithoutUserInput;
type prismaNamespace_SearchLogCreateWithoutUserInput = SearchLogCreateWithoutUserInput;
type prismaNamespace_SearchLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogDefaultArgs<ExtArgs>;
type prismaNamespace_SearchLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = SearchLogDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_SearchLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogDeleteArgs<ExtArgs>;
type prismaNamespace_SearchLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogDeleteManyArgs<ExtArgs>;
type prismaNamespace_SearchLogFieldRefs = SearchLogFieldRefs;
type prismaNamespace_SearchLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogFindFirstArgs<ExtArgs>;
type prismaNamespace_SearchLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_SearchLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogFindManyArgs<ExtArgs>;
type prismaNamespace_SearchLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogFindUniqueArgs<ExtArgs>;
type prismaNamespace_SearchLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_SearchLogGetPayload<S extends boolean | null | undefined | SearchLogDefaultArgs> = SearchLogGetPayload<S>;
type prismaNamespace_SearchLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogGroupByArgs<ExtArgs>;
type prismaNamespace_SearchLogGroupByOutputType = SearchLogGroupByOutputType;
type prismaNamespace_SearchLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogInclude<ExtArgs>;
type prismaNamespace_SearchLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SearchLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SearchLogListRelationFilter = SearchLogListRelationFilter;
type prismaNamespace_SearchLogMaxAggregateInputType = SearchLogMaxAggregateInputType;
type prismaNamespace_SearchLogMaxAggregateOutputType = SearchLogMaxAggregateOutputType;
type prismaNamespace_SearchLogMaxOrderByAggregateInput = SearchLogMaxOrderByAggregateInput;
type prismaNamespace_SearchLogMinAggregateInputType = SearchLogMinAggregateInputType;
type prismaNamespace_SearchLogMinAggregateOutputType = SearchLogMinAggregateOutputType;
type prismaNamespace_SearchLogMinOrderByAggregateInput = SearchLogMinOrderByAggregateInput;
type prismaNamespace_SearchLogModel = SearchLogModel;
type prismaNamespace_SearchLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogOmit<ExtArgs>;
type prismaNamespace_SearchLogOrderByRelationAggregateInput = SearchLogOrderByRelationAggregateInput;
type prismaNamespace_SearchLogOrderByWithAggregationInput = SearchLogOrderByWithAggregationInput;
type prismaNamespace_SearchLogOrderByWithRelationInput = SearchLogOrderByWithRelationInput;
type prismaNamespace_SearchLogScalarFieldEnum = SearchLogScalarFieldEnum;
type prismaNamespace_SearchLogScalarWhereInput = SearchLogScalarWhereInput;
type prismaNamespace_SearchLogScalarWhereWithAggregatesInput = SearchLogScalarWhereWithAggregatesInput;
type prismaNamespace_SearchLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogSelect<ExtArgs>;
type prismaNamespace_SearchLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SearchLogSelectScalar = SearchLogSelectScalar;
type prismaNamespace_SearchLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SearchLogUncheckedCreateInput = SearchLogUncheckedCreateInput;
type prismaNamespace_SearchLogUncheckedCreateNestedManyWithoutUserInput = SearchLogUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_SearchLogUncheckedCreateWithoutUserInput = SearchLogUncheckedCreateWithoutUserInput;
type prismaNamespace_SearchLogUncheckedUpdateInput = SearchLogUncheckedUpdateInput;
type prismaNamespace_SearchLogUncheckedUpdateManyInput = SearchLogUncheckedUpdateManyInput;
type prismaNamespace_SearchLogUncheckedUpdateManyWithoutUserInput = SearchLogUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_SearchLogUncheckedUpdateManyWithoutUserNestedInput = SearchLogUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_SearchLogUncheckedUpdateWithoutUserInput = SearchLogUncheckedUpdateWithoutUserInput;
type prismaNamespace_SearchLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogUpdateArgs<ExtArgs>;
type prismaNamespace_SearchLogUpdateInput = SearchLogUpdateInput;
type prismaNamespace_SearchLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SearchLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogUpdateManyArgs<ExtArgs>;
type prismaNamespace_SearchLogUpdateManyMutationInput = SearchLogUpdateManyMutationInput;
type prismaNamespace_SearchLogUpdateManyWithWhereWithoutUserInput = SearchLogUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_SearchLogUpdateManyWithoutUserNestedInput = SearchLogUpdateManyWithoutUserNestedInput;
type prismaNamespace_SearchLogUpdateWithWhereUniqueWithoutUserInput = SearchLogUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_SearchLogUpdateWithoutUserInput = SearchLogUpdateWithoutUserInput;
type prismaNamespace_SearchLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SearchLogUpsertArgs<ExtArgs>;
type prismaNamespace_SearchLogUpsertWithWhereUniqueWithoutUserInput = SearchLogUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_SearchLogWhereInput = SearchLogWhereInput;
type prismaNamespace_SearchLogWhereUniqueInput = SearchLogWhereUniqueInput;
type prismaNamespace_SelectSubset<T, U> = SelectSubset<T, U>;
type prismaNamespace_SessionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SessionAggregateArgs<ExtArgs>;
type prismaNamespace_SessionCountAggregateInputType = SessionCountAggregateInputType;
type prismaNamespace_SessionCountAggregateOutputType = SessionCountAggregateOutputType;
type prismaNamespace_SessionGroupByOutputType = SessionGroupByOutputType;
type prismaNamespace_SessionListRelationFilter = SessionListRelationFilter;
type prismaNamespace_SessionMaxAggregateInputType = SessionMaxAggregateInputType;
type prismaNamespace_SessionMaxAggregateOutputType = SessionMaxAggregateOutputType;
type prismaNamespace_SessionMinAggregateInputType = SessionMinAggregateInputType;
type prismaNamespace_SessionMinAggregateOutputType = SessionMinAggregateOutputType;
type prismaNamespace_SessionScalarFieldEnum = SessionScalarFieldEnum;
type prismaNamespace_Slot$AppointmentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Slot$AppointmentArgs<ExtArgs>;
type prismaNamespace_SlotAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotAggregateArgs<ExtArgs>;
type prismaNamespace_SlotCountAggregateInputType = SlotCountAggregateInputType;
type prismaNamespace_SlotCountAggregateOutputType = SlotCountAggregateOutputType;
type prismaNamespace_SlotCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotCountArgs<ExtArgs>;
type prismaNamespace_SlotCountOrderByAggregateInput = SlotCountOrderByAggregateInput;
type prismaNamespace_SlotCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotCreateArgs<ExtArgs>;
type prismaNamespace_SlotCreateInput = SlotCreateInput;
type prismaNamespace_SlotCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SlotCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotCreateManyArgs<ExtArgs>;
type prismaNamespace_SlotCreateManyInput = SlotCreateManyInput;
type prismaNamespace_SlotCreateManyScheduleInput = SlotCreateManyScheduleInput;
type prismaNamespace_SlotCreateManyScheduleInputEnvelope = SlotCreateManyScheduleInputEnvelope;
type prismaNamespace_SlotCreateNestedManyWithoutScheduleInput = SlotCreateNestedManyWithoutScheduleInput;
type prismaNamespace_SlotCreateNestedOneWithoutAppointmentInput = SlotCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_SlotCreateOrConnectWithoutAppointmentInput = SlotCreateOrConnectWithoutAppointmentInput;
type prismaNamespace_SlotCreateOrConnectWithoutScheduleInput = SlotCreateOrConnectWithoutScheduleInput;
type prismaNamespace_SlotCreateWithoutAppointmentInput = SlotCreateWithoutAppointmentInput;
type prismaNamespace_SlotCreateWithoutScheduleInput = SlotCreateWithoutScheduleInput;
type prismaNamespace_SlotDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotDefaultArgs<ExtArgs>;
type prismaNamespace_SlotDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = SlotDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_SlotDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotDeleteArgs<ExtArgs>;
type prismaNamespace_SlotDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotDeleteManyArgs<ExtArgs>;
type prismaNamespace_SlotFieldRefs = SlotFieldRefs;
type prismaNamespace_SlotFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotFindFirstArgs<ExtArgs>;
type prismaNamespace_SlotFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_SlotFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotFindManyArgs<ExtArgs>;
type prismaNamespace_SlotFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotFindUniqueArgs<ExtArgs>;
type prismaNamespace_SlotFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_SlotGetPayload<S extends boolean | null | undefined | SlotDefaultArgs> = SlotGetPayload<S>;
type prismaNamespace_SlotGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotGroupByArgs<ExtArgs>;
type prismaNamespace_SlotGroupByOutputType = SlotGroupByOutputType;
type prismaNamespace_SlotInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotInclude<ExtArgs>;
type prismaNamespace_SlotIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SlotIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SlotListRelationFilter = SlotListRelationFilter;
type prismaNamespace_SlotMaxAggregateInputType = SlotMaxAggregateInputType;
type prismaNamespace_SlotMaxAggregateOutputType = SlotMaxAggregateOutputType;
type prismaNamespace_SlotMaxOrderByAggregateInput = SlotMaxOrderByAggregateInput;
type prismaNamespace_SlotMinAggregateInputType = SlotMinAggregateInputType;
type prismaNamespace_SlotMinAggregateOutputType = SlotMinAggregateOutputType;
type prismaNamespace_SlotMinOrderByAggregateInput = SlotMinOrderByAggregateInput;
type prismaNamespace_SlotModel = SlotModel;
type prismaNamespace_SlotNullableScalarRelationFilter = SlotNullableScalarRelationFilter;
type prismaNamespace_SlotOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotOmit<ExtArgs>;
type prismaNamespace_SlotOrderByRelationAggregateInput = SlotOrderByRelationAggregateInput;
type prismaNamespace_SlotOrderByWithAggregationInput = SlotOrderByWithAggregationInput;
type prismaNamespace_SlotOrderByWithRelationInput = SlotOrderByWithRelationInput;
type prismaNamespace_SlotScalarFieldEnum = SlotScalarFieldEnum;
type prismaNamespace_SlotScalarWhereInput = SlotScalarWhereInput;
type prismaNamespace_SlotScalarWhereWithAggregatesInput = SlotScalarWhereWithAggregatesInput;
type prismaNamespace_SlotSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotSelect<ExtArgs>;
type prismaNamespace_SlotSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SlotSelectScalar = SlotSelectScalar;
type prismaNamespace_SlotSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SlotSlotStartScheduleIdDateCompoundUniqueInput = SlotSlotStartScheduleIdDateCompoundUniqueInput;
type prismaNamespace_SlotUncheckedCreateInput = SlotUncheckedCreateInput;
type prismaNamespace_SlotUncheckedCreateNestedManyWithoutScheduleInput = SlotUncheckedCreateNestedManyWithoutScheduleInput;
type prismaNamespace_SlotUncheckedCreateNestedOneWithoutAppointmentInput = SlotUncheckedCreateNestedOneWithoutAppointmentInput;
type prismaNamespace_SlotUncheckedCreateWithoutAppointmentInput = SlotUncheckedCreateWithoutAppointmentInput;
type prismaNamespace_SlotUncheckedCreateWithoutScheduleInput = SlotUncheckedCreateWithoutScheduleInput;
type prismaNamespace_SlotUncheckedUpdateInput = SlotUncheckedUpdateInput;
type prismaNamespace_SlotUncheckedUpdateManyInput = SlotUncheckedUpdateManyInput;
type prismaNamespace_SlotUncheckedUpdateManyWithoutScheduleInput = SlotUncheckedUpdateManyWithoutScheduleInput;
type prismaNamespace_SlotUncheckedUpdateManyWithoutScheduleNestedInput = SlotUncheckedUpdateManyWithoutScheduleNestedInput;
type prismaNamespace_SlotUncheckedUpdateOneWithoutAppointmentNestedInput = SlotUncheckedUpdateOneWithoutAppointmentNestedInput;
type prismaNamespace_SlotUncheckedUpdateWithoutAppointmentInput = SlotUncheckedUpdateWithoutAppointmentInput;
type prismaNamespace_SlotUncheckedUpdateWithoutScheduleInput = SlotUncheckedUpdateWithoutScheduleInput;
type prismaNamespace_SlotUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotUpdateArgs<ExtArgs>;
type prismaNamespace_SlotUpdateInput = SlotUpdateInput;
type prismaNamespace_SlotUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SlotUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotUpdateManyArgs<ExtArgs>;
type prismaNamespace_SlotUpdateManyMutationInput = SlotUpdateManyMutationInput;
type prismaNamespace_SlotUpdateManyWithWhereWithoutScheduleInput = SlotUpdateManyWithWhereWithoutScheduleInput;
type prismaNamespace_SlotUpdateManyWithoutScheduleNestedInput = SlotUpdateManyWithoutScheduleNestedInput;
type prismaNamespace_SlotUpdateOneWithoutAppointmentNestedInput = SlotUpdateOneWithoutAppointmentNestedInput;
type prismaNamespace_SlotUpdateToOneWithWhereWithoutAppointmentInput = SlotUpdateToOneWithWhereWithoutAppointmentInput;
type prismaNamespace_SlotUpdateWithWhereUniqueWithoutScheduleInput = SlotUpdateWithWhereUniqueWithoutScheduleInput;
type prismaNamespace_SlotUpdateWithoutAppointmentInput = SlotUpdateWithoutAppointmentInput;
type prismaNamespace_SlotUpdateWithoutScheduleInput = SlotUpdateWithoutScheduleInput;
type prismaNamespace_SlotUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SlotUpsertArgs<ExtArgs>;
type prismaNamespace_SlotUpsertWithWhereUniqueWithoutScheduleInput = SlotUpsertWithWhereUniqueWithoutScheduleInput;
type prismaNamespace_SlotUpsertWithoutAppointmentInput = SlotUpsertWithoutAppointmentInput;
type prismaNamespace_SlotWhereInput = SlotWhereInput;
type prismaNamespace_SlotWhereUniqueInput = SlotWhereUniqueInput;
type prismaNamespace_SortOrder = SortOrder;
type prismaNamespace_SortOrderInput = SortOrderInput;
type prismaNamespace_Specialization$DoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Specialization$DoctorSpecializationArgs<ExtArgs>;
type prismaNamespace_Specialization$HospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Specialization$HospitalSpecializationArgs<ExtArgs>;
type prismaNamespace_SpecializationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationAggregateArgs<ExtArgs>;
type prismaNamespace_SpecializationCountAggregateInputType = SpecializationCountAggregateInputType;
type prismaNamespace_SpecializationCountAggregateOutputType = SpecializationCountAggregateOutputType;
type prismaNamespace_SpecializationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCountArgs<ExtArgs>;
type prismaNamespace_SpecializationCountOrderByAggregateInput = SpecializationCountOrderByAggregateInput;
type prismaNamespace_SpecializationCountOutputType = SpecializationCountOutputType;
type prismaNamespace_SpecializationCountOutputTypeCountDoctorSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCountOutputTypeCountDoctorSpecializationArgs<ExtArgs>;
type prismaNamespace_SpecializationCountOutputTypeCountHospitalSpecializationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCountOutputTypeCountHospitalSpecializationArgs<ExtArgs>;
type prismaNamespace_SpecializationCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCountOutputTypeDefaultArgs<ExtArgs>;
type prismaNamespace_SpecializationCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCountOutputTypeSelect<ExtArgs>;
type prismaNamespace_SpecializationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCreateArgs<ExtArgs>;
type prismaNamespace_SpecializationCreateInput = SpecializationCreateInput;
type prismaNamespace_SpecializationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SpecializationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationCreateManyArgs<ExtArgs>;
type prismaNamespace_SpecializationCreateManyInput = SpecializationCreateManyInput;
type prismaNamespace_SpecializationCreateNestedOneWithoutDoctorSpecializationInput = SpecializationCreateNestedOneWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationCreateNestedOneWithoutHospitalSpecializationInput = SpecializationCreateNestedOneWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationCreateOrConnectWithoutDoctorSpecializationInput = SpecializationCreateOrConnectWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationCreateOrConnectWithoutHospitalSpecializationInput = SpecializationCreateOrConnectWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationCreateWithoutDoctorSpecializationInput = SpecializationCreateWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationCreateWithoutHospitalSpecializationInput = SpecializationCreateWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationDefaultArgs<ExtArgs>;
type prismaNamespace_SpecializationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = SpecializationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_SpecializationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationDeleteArgs<ExtArgs>;
type prismaNamespace_SpecializationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationDeleteManyArgs<ExtArgs>;
type prismaNamespace_SpecializationFieldRefs = SpecializationFieldRefs;
type prismaNamespace_SpecializationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationFindFirstArgs<ExtArgs>;
type prismaNamespace_SpecializationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_SpecializationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationFindManyArgs<ExtArgs>;
type prismaNamespace_SpecializationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationFindUniqueArgs<ExtArgs>;
type prismaNamespace_SpecializationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_SpecializationGetPayload<S extends boolean | null | undefined | SpecializationDefaultArgs> = SpecializationGetPayload<S>;
type prismaNamespace_SpecializationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationGroupByArgs<ExtArgs>;
type prismaNamespace_SpecializationGroupByOutputType = SpecializationGroupByOutputType;
type prismaNamespace_SpecializationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationInclude<ExtArgs>;
type prismaNamespace_SpecializationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SpecializationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SpecializationMaxAggregateInputType = SpecializationMaxAggregateInputType;
type prismaNamespace_SpecializationMaxAggregateOutputType = SpecializationMaxAggregateOutputType;
type prismaNamespace_SpecializationMaxOrderByAggregateInput = SpecializationMaxOrderByAggregateInput;
type prismaNamespace_SpecializationMinAggregateInputType = SpecializationMinAggregateInputType;
type prismaNamespace_SpecializationMinAggregateOutputType = SpecializationMinAggregateOutputType;
type prismaNamespace_SpecializationMinOrderByAggregateInput = SpecializationMinOrderByAggregateInput;
type prismaNamespace_SpecializationModel = SpecializationModel;
type prismaNamespace_SpecializationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationOmit<ExtArgs>;
type prismaNamespace_SpecializationOrderByWithAggregationInput = SpecializationOrderByWithAggregationInput;
type prismaNamespace_SpecializationOrderByWithRelationInput = SpecializationOrderByWithRelationInput;
type prismaNamespace_SpecializationScalarFieldEnum = SpecializationScalarFieldEnum;
type prismaNamespace_SpecializationScalarRelationFilter = SpecializationScalarRelationFilter;
type prismaNamespace_SpecializationScalarWhereWithAggregatesInput = SpecializationScalarWhereWithAggregatesInput;
type prismaNamespace_SpecializationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationSelect<ExtArgs>;
type prismaNamespace_SpecializationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_SpecializationSelectScalar = SpecializationSelectScalar;
type prismaNamespace_SpecializationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_SpecializationUncheckedCreateInput = SpecializationUncheckedCreateInput;
type prismaNamespace_SpecializationUncheckedCreateWithoutDoctorSpecializationInput = SpecializationUncheckedCreateWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationUncheckedCreateWithoutHospitalSpecializationInput = SpecializationUncheckedCreateWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationUncheckedUpdateInput = SpecializationUncheckedUpdateInput;
type prismaNamespace_SpecializationUncheckedUpdateManyInput = SpecializationUncheckedUpdateManyInput;
type prismaNamespace_SpecializationUncheckedUpdateWithoutDoctorSpecializationInput = SpecializationUncheckedUpdateWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationUncheckedUpdateWithoutHospitalSpecializationInput = SpecializationUncheckedUpdateWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationUpdateArgs<ExtArgs>;
type prismaNamespace_SpecializationUpdateInput = SpecializationUpdateInput;
type prismaNamespace_SpecializationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_SpecializationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationUpdateManyArgs<ExtArgs>;
type prismaNamespace_SpecializationUpdateManyMutationInput = SpecializationUpdateManyMutationInput;
type prismaNamespace_SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput = SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput;
type prismaNamespace_SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput = SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput;
type prismaNamespace_SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput = SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput = SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationUpdateWithoutDoctorSpecializationInput = SpecializationUpdateWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationUpdateWithoutHospitalSpecializationInput = SpecializationUpdateWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = SpecializationUpsertArgs<ExtArgs>;
type prismaNamespace_SpecializationUpsertWithoutDoctorSpecializationInput = SpecializationUpsertWithoutDoctorSpecializationInput;
type prismaNamespace_SpecializationUpsertWithoutHospitalSpecializationInput = SpecializationUpsertWithoutHospitalSpecializationInput;
type prismaNamespace_SpecializationWhereInput = SpecializationWhereInput;
type prismaNamespace_SpecializationWhereUniqueInput = SpecializationWhereUniqueInput;
type prismaNamespace_Sql = Sql;
type prismaNamespace_Strict<U extends object> = Strict<U>;
type prismaNamespace_StringFieldRefInput<$PrismaModel> = StringFieldRefInput<$PrismaModel>;
type prismaNamespace_StringFieldUpdateOperationsInput = StringFieldUpdateOperationsInput;
type prismaNamespace_StringFilter<$PrismaModel = never> = StringFilter<$PrismaModel>;
type prismaNamespace_StringNullableFilter<$PrismaModel = never> = StringNullableFilter<$PrismaModel>;
type prismaNamespace_StringNullableListFilter<$PrismaModel = never> = StringNullableListFilter<$PrismaModel>;
type prismaNamespace_StringNullableWithAggregatesFilter<$PrismaModel = never> = StringNullableWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_StringWithAggregatesFilter<$PrismaModel = never> = StringWithAggregatesFilter<$PrismaModel>;
type prismaNamespace_Subset<T, U> = Subset<T, U>;
type prismaNamespace_SubsetIntersection<T, U, K> = SubsetIntersection<T, U, K>;
type prismaNamespace_TransactionClient = TransactionClient;
type prismaNamespace_TransactionIsolationLevel = TransactionIsolationLevel;
type prismaNamespace_True = True;
type prismaNamespace_TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = TypeMap<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_TypeMapCb<GlobalOmitOptions = {}> = TypeMapCb<GlobalOmitOptions>;
type prismaNamespace_UnEnumerate<T extends unknown> = UnEnumerate<T>;
type prismaNamespace_Union = Union;
type prismaNamespace_User$Appointment_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$Appointment_Appointment_approvedByToUserArgs<ExtArgs>;
type prismaNamespace_User$Appointment_Appointment_customerIdToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$Appointment_Appointment_customerIdToUserArgs<ExtArgs>;
type prismaNamespace_User$AuditLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$AuditLogArgs<ExtArgs>;
type prismaNamespace_User$DoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$DoctorApplicationArgs<ExtArgs>;
type prismaNamespace_User$DoctorArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$DoctorArgs<ExtArgs>;
type prismaNamespace_User$HospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$HospitalArgs<ExtArgs>;
type prismaNamespace_User$NotificationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$NotificationArgs<ExtArgs>;
type prismaNamespace_User$PaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$PaymentArgs<ExtArgs>;
type prismaNamespace_User$ReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$ReviewArgs<ExtArgs>;
type prismaNamespace_User$SavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$SavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_User$ScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$ScheduleArgs<ExtArgs>;
type prismaNamespace_User$SearchLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$SearchLogArgs<ExtArgs>;
type prismaNamespace_User$accountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$accountArgs<ExtArgs>;
type prismaNamespace_User$sessionArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = User$sessionArgs<ExtArgs>;
type prismaNamespace_UserAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserAggregateArgs<ExtArgs>;
type prismaNamespace_UserCountAggregateInputType = UserCountAggregateInputType;
type prismaNamespace_UserCountAggregateOutputType = UserCountAggregateOutputType;
type prismaNamespace_UserCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountArgs<ExtArgs>;
type prismaNamespace_UserCountOrderByAggregateInput = UserCountOrderByAggregateInput;
type prismaNamespace_UserCountOutputType = UserCountOutputType;
type prismaNamespace_UserCountOutputTypeCountAccountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountAccountArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountAuditLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountAuditLogArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountDoctorApplicationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountDoctorApplicationArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountNotificationArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountNotificationArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountPaymentArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountPaymentArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountReviewArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountReviewArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountSavedDoctorHospitalArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountScheduleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountScheduleArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountSearchLogArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountSearchLogArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeCountSessionArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeCountSessionArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>;
type prismaNamespace_UserCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCountOutputTypeSelect<ExtArgs>;
type prismaNamespace_UserCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCreateArgs<ExtArgs>;
type prismaNamespace_UserCreateInput = UserCreateInput;
type prismaNamespace_UserCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_UserCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserCreateManyArgs<ExtArgs>;
type prismaNamespace_UserCreateManyInput = UserCreateManyInput;
type prismaNamespace_UserCreateNestedOneWithoutAccountInput = UserCreateNestedOneWithoutAccountInput;
type prismaNamespace_UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput = UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput = UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserCreateNestedOneWithoutAuditLogInput = UserCreateNestedOneWithoutAuditLogInput;
type prismaNamespace_UserCreateNestedOneWithoutDoctorApplicationInput = UserCreateNestedOneWithoutDoctorApplicationInput;
type prismaNamespace_UserCreateNestedOneWithoutDoctorInput = UserCreateNestedOneWithoutDoctorInput;
type prismaNamespace_UserCreateNestedOneWithoutHospitalInput = UserCreateNestedOneWithoutHospitalInput;
type prismaNamespace_UserCreateNestedOneWithoutNotificationInput = UserCreateNestedOneWithoutNotificationInput;
type prismaNamespace_UserCreateNestedOneWithoutPaymentInput = UserCreateNestedOneWithoutPaymentInput;
type prismaNamespace_UserCreateNestedOneWithoutReviewInput = UserCreateNestedOneWithoutReviewInput;
type prismaNamespace_UserCreateNestedOneWithoutSavedDoctorHospitalInput = UserCreateNestedOneWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserCreateNestedOneWithoutScheduleInput = UserCreateNestedOneWithoutScheduleInput;
type prismaNamespace_UserCreateNestedOneWithoutSearchLogInput = UserCreateNestedOneWithoutSearchLogInput;
type prismaNamespace_UserCreateNestedOneWithoutSessionInput = UserCreateNestedOneWithoutSessionInput;
type prismaNamespace_UserCreateOrConnectWithoutAccountInput = UserCreateOrConnectWithoutAccountInput;
type prismaNamespace_UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput = UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput = UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserCreateOrConnectWithoutAuditLogInput = UserCreateOrConnectWithoutAuditLogInput;
type prismaNamespace_UserCreateOrConnectWithoutDoctorApplicationInput = UserCreateOrConnectWithoutDoctorApplicationInput;
type prismaNamespace_UserCreateOrConnectWithoutDoctorInput = UserCreateOrConnectWithoutDoctorInput;
type prismaNamespace_UserCreateOrConnectWithoutHospitalInput = UserCreateOrConnectWithoutHospitalInput;
type prismaNamespace_UserCreateOrConnectWithoutNotificationInput = UserCreateOrConnectWithoutNotificationInput;
type prismaNamespace_UserCreateOrConnectWithoutPaymentInput = UserCreateOrConnectWithoutPaymentInput;
type prismaNamespace_UserCreateOrConnectWithoutReviewInput = UserCreateOrConnectWithoutReviewInput;
type prismaNamespace_UserCreateOrConnectWithoutSavedDoctorHospitalInput = UserCreateOrConnectWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserCreateOrConnectWithoutScheduleInput = UserCreateOrConnectWithoutScheduleInput;
type prismaNamespace_UserCreateOrConnectWithoutSearchLogInput = UserCreateOrConnectWithoutSearchLogInput;
type prismaNamespace_UserCreateOrConnectWithoutSessionInput = UserCreateOrConnectWithoutSessionInput;
type prismaNamespace_UserCreateWithoutAccountInput = UserCreateWithoutAccountInput;
type prismaNamespace_UserCreateWithoutAppointment_Appointment_approvedByToUserInput = UserCreateWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserCreateWithoutAppointment_Appointment_customerIdToUserInput = UserCreateWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserCreateWithoutAuditLogInput = UserCreateWithoutAuditLogInput;
type prismaNamespace_UserCreateWithoutDoctorApplicationInput = UserCreateWithoutDoctorApplicationInput;
type prismaNamespace_UserCreateWithoutDoctorInput = UserCreateWithoutDoctorInput;
type prismaNamespace_UserCreateWithoutHospitalInput = UserCreateWithoutHospitalInput;
type prismaNamespace_UserCreateWithoutNotificationInput = UserCreateWithoutNotificationInput;
type prismaNamespace_UserCreateWithoutPaymentInput = UserCreateWithoutPaymentInput;
type prismaNamespace_UserCreateWithoutReviewInput = UserCreateWithoutReviewInput;
type prismaNamespace_UserCreateWithoutSavedDoctorHospitalInput = UserCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserCreateWithoutScheduleInput = UserCreateWithoutScheduleInput;
type prismaNamespace_UserCreateWithoutSearchLogInput = UserCreateWithoutSearchLogInput;
type prismaNamespace_UserCreateWithoutSessionInput = UserCreateWithoutSessionInput;
type prismaNamespace_UserDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>;
type prismaNamespace_UserDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = UserDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_UserDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserDeleteArgs<ExtArgs>;
type prismaNamespace_UserDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserDeleteManyArgs<ExtArgs>;
type prismaNamespace_UserFieldRefs = UserFieldRefs;
type prismaNamespace_UserFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserFindFirstArgs<ExtArgs>;
type prismaNamespace_UserFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_UserFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserFindManyArgs<ExtArgs>;
type prismaNamespace_UserFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserFindUniqueArgs<ExtArgs>;
type prismaNamespace_UserFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = UserGetPayload<S>;
type prismaNamespace_UserGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserGroupByArgs<ExtArgs>;
type prismaNamespace_UserGroupByOutputType = UserGroupByOutputType;
type prismaNamespace_UserInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserInclude<ExtArgs>;
type prismaNamespace_UserIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_UserIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_UserMaxAggregateInputType = UserMaxAggregateInputType;
type prismaNamespace_UserMaxAggregateOutputType = UserMaxAggregateOutputType;
type prismaNamespace_UserMaxOrderByAggregateInput = UserMaxOrderByAggregateInput;
type prismaNamespace_UserMinAggregateInputType = UserMinAggregateInputType;
type prismaNamespace_UserMinAggregateOutputType = UserMinAggregateOutputType;
type prismaNamespace_UserMinOrderByAggregateInput = UserMinOrderByAggregateInput;
type prismaNamespace_UserModel = UserModel;
type prismaNamespace_UserNullableScalarRelationFilter = UserNullableScalarRelationFilter;
type prismaNamespace_UserOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserOmit<ExtArgs>;
type prismaNamespace_UserOrderByWithAggregationInput = UserOrderByWithAggregationInput;
type prismaNamespace_UserOrderByWithRelationInput = UserOrderByWithRelationInput;
type prismaNamespace_UserScalarFieldEnum = UserScalarFieldEnum;
type prismaNamespace_UserScalarRelationFilter = UserScalarRelationFilter;
type prismaNamespace_UserScalarWhereWithAggregatesInput = UserScalarWhereWithAggregatesInput;
type prismaNamespace_UserSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserSelect<ExtArgs>;
type prismaNamespace_UserSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_UserSelectScalar = UserSelectScalar;
type prismaNamespace_UserSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_UserUncheckedCreateInput = UserUncheckedCreateInput;
type prismaNamespace_UserUncheckedCreateWithoutAccountInput = UserUncheckedCreateWithoutAccountInput;
type prismaNamespace_UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput = UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput = UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserUncheckedCreateWithoutAuditLogInput = UserUncheckedCreateWithoutAuditLogInput;
type prismaNamespace_UserUncheckedCreateWithoutDoctorApplicationInput = UserUncheckedCreateWithoutDoctorApplicationInput;
type prismaNamespace_UserUncheckedCreateWithoutDoctorInput = UserUncheckedCreateWithoutDoctorInput;
type prismaNamespace_UserUncheckedCreateWithoutHospitalInput = UserUncheckedCreateWithoutHospitalInput;
type prismaNamespace_UserUncheckedCreateWithoutNotificationInput = UserUncheckedCreateWithoutNotificationInput;
type prismaNamespace_UserUncheckedCreateWithoutPaymentInput = UserUncheckedCreateWithoutPaymentInput;
type prismaNamespace_UserUncheckedCreateWithoutReviewInput = UserUncheckedCreateWithoutReviewInput;
type prismaNamespace_UserUncheckedCreateWithoutSavedDoctorHospitalInput = UserUncheckedCreateWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserUncheckedCreateWithoutScheduleInput = UserUncheckedCreateWithoutScheduleInput;
type prismaNamespace_UserUncheckedCreateWithoutSearchLogInput = UserUncheckedCreateWithoutSearchLogInput;
type prismaNamespace_UserUncheckedCreateWithoutSessionInput = UserUncheckedCreateWithoutSessionInput;
type prismaNamespace_UserUncheckedUpdateInput = UserUncheckedUpdateInput;
type prismaNamespace_UserUncheckedUpdateManyInput = UserUncheckedUpdateManyInput;
type prismaNamespace_UserUncheckedUpdateWithoutAccountInput = UserUncheckedUpdateWithoutAccountInput;
type prismaNamespace_UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput = UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput = UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserUncheckedUpdateWithoutAuditLogInput = UserUncheckedUpdateWithoutAuditLogInput;
type prismaNamespace_UserUncheckedUpdateWithoutDoctorApplicationInput = UserUncheckedUpdateWithoutDoctorApplicationInput;
type prismaNamespace_UserUncheckedUpdateWithoutDoctorInput = UserUncheckedUpdateWithoutDoctorInput;
type prismaNamespace_UserUncheckedUpdateWithoutHospitalInput = UserUncheckedUpdateWithoutHospitalInput;
type prismaNamespace_UserUncheckedUpdateWithoutNotificationInput = UserUncheckedUpdateWithoutNotificationInput;
type prismaNamespace_UserUncheckedUpdateWithoutPaymentInput = UserUncheckedUpdateWithoutPaymentInput;
type prismaNamespace_UserUncheckedUpdateWithoutReviewInput = UserUncheckedUpdateWithoutReviewInput;
type prismaNamespace_UserUncheckedUpdateWithoutSavedDoctorHospitalInput = UserUncheckedUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserUncheckedUpdateWithoutScheduleInput = UserUncheckedUpdateWithoutScheduleInput;
type prismaNamespace_UserUncheckedUpdateWithoutSearchLogInput = UserUncheckedUpdateWithoutSearchLogInput;
type prismaNamespace_UserUncheckedUpdateWithoutSessionInput = UserUncheckedUpdateWithoutSessionInput;
type prismaNamespace_UserUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserUpdateArgs<ExtArgs>;
type prismaNamespace_UserUpdateInput = UserUpdateInput;
type prismaNamespace_UserUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_UserUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserUpdateManyArgs<ExtArgs>;
type prismaNamespace_UserUpdateManyMutationInput = UserUpdateManyMutationInput;
type prismaNamespace_UserUpdateOneRequiredWithoutAccountNestedInput = UserUpdateOneRequiredWithoutAccountNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput = UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutAuditLogNestedInput = UserUpdateOneRequiredWithoutAuditLogNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutDoctorApplicationNestedInput = UserUpdateOneRequiredWithoutDoctorApplicationNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutDoctorNestedInput = UserUpdateOneRequiredWithoutDoctorNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutHospitalNestedInput = UserUpdateOneRequiredWithoutHospitalNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutNotificationNestedInput = UserUpdateOneRequiredWithoutNotificationNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutPaymentNestedInput = UserUpdateOneRequiredWithoutPaymentNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutReviewNestedInput = UserUpdateOneRequiredWithoutReviewNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput = UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutScheduleNestedInput = UserUpdateOneRequiredWithoutScheduleNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutSearchLogNestedInput = UserUpdateOneRequiredWithoutSearchLogNestedInput;
type prismaNamespace_UserUpdateOneRequiredWithoutSessionNestedInput = UserUpdateOneRequiredWithoutSessionNestedInput;
type prismaNamespace_UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput = UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutAccountInput = UserUpdateToOneWithWhereWithoutAccountInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput = UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput = UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutAuditLogInput = UserUpdateToOneWithWhereWithoutAuditLogInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutDoctorApplicationInput = UserUpdateToOneWithWhereWithoutDoctorApplicationInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutDoctorInput = UserUpdateToOneWithWhereWithoutDoctorInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutHospitalInput = UserUpdateToOneWithWhereWithoutHospitalInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutNotificationInput = UserUpdateToOneWithWhereWithoutNotificationInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutPaymentInput = UserUpdateToOneWithWhereWithoutPaymentInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutReviewInput = UserUpdateToOneWithWhereWithoutReviewInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput = UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutScheduleInput = UserUpdateToOneWithWhereWithoutScheduleInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutSearchLogInput = UserUpdateToOneWithWhereWithoutSearchLogInput;
type prismaNamespace_UserUpdateToOneWithWhereWithoutSessionInput = UserUpdateToOneWithWhereWithoutSessionInput;
type prismaNamespace_UserUpdateWithoutAccountInput = UserUpdateWithoutAccountInput;
type prismaNamespace_UserUpdateWithoutAppointment_Appointment_approvedByToUserInput = UserUpdateWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserUpdateWithoutAppointment_Appointment_customerIdToUserInput = UserUpdateWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserUpdateWithoutAuditLogInput = UserUpdateWithoutAuditLogInput;
type prismaNamespace_UserUpdateWithoutDoctorApplicationInput = UserUpdateWithoutDoctorApplicationInput;
type prismaNamespace_UserUpdateWithoutDoctorInput = UserUpdateWithoutDoctorInput;
type prismaNamespace_UserUpdateWithoutHospitalInput = UserUpdateWithoutHospitalInput;
type prismaNamespace_UserUpdateWithoutNotificationInput = UserUpdateWithoutNotificationInput;
type prismaNamespace_UserUpdateWithoutPaymentInput = UserUpdateWithoutPaymentInput;
type prismaNamespace_UserUpdateWithoutReviewInput = UserUpdateWithoutReviewInput;
type prismaNamespace_UserUpdateWithoutSavedDoctorHospitalInput = UserUpdateWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserUpdateWithoutScheduleInput = UserUpdateWithoutScheduleInput;
type prismaNamespace_UserUpdateWithoutSearchLogInput = UserUpdateWithoutSearchLogInput;
type prismaNamespace_UserUpdateWithoutSessionInput = UserUpdateWithoutSessionInput;
type prismaNamespace_UserUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = UserUpsertArgs<ExtArgs>;
type prismaNamespace_UserUpsertWithoutAccountInput = UserUpsertWithoutAccountInput;
type prismaNamespace_UserUpsertWithoutAppointment_Appointment_approvedByToUserInput = UserUpsertWithoutAppointment_Appointment_approvedByToUserInput;
type prismaNamespace_UserUpsertWithoutAppointment_Appointment_customerIdToUserInput = UserUpsertWithoutAppointment_Appointment_customerIdToUserInput;
type prismaNamespace_UserUpsertWithoutAuditLogInput = UserUpsertWithoutAuditLogInput;
type prismaNamespace_UserUpsertWithoutDoctorApplicationInput = UserUpsertWithoutDoctorApplicationInput;
type prismaNamespace_UserUpsertWithoutDoctorInput = UserUpsertWithoutDoctorInput;
type prismaNamespace_UserUpsertWithoutHospitalInput = UserUpsertWithoutHospitalInput;
type prismaNamespace_UserUpsertWithoutNotificationInput = UserUpsertWithoutNotificationInput;
type prismaNamespace_UserUpsertWithoutPaymentInput = UserUpsertWithoutPaymentInput;
type prismaNamespace_UserUpsertWithoutReviewInput = UserUpsertWithoutReviewInput;
type prismaNamespace_UserUpsertWithoutSavedDoctorHospitalInput = UserUpsertWithoutSavedDoctorHospitalInput;
type prismaNamespace_UserUpsertWithoutScheduleInput = UserUpsertWithoutScheduleInput;
type prismaNamespace_UserUpsertWithoutSearchLogInput = UserUpsertWithoutSearchLogInput;
type prismaNamespace_UserUpsertWithoutSessionInput = UserUpsertWithoutSessionInput;
type prismaNamespace_UserWhereInput = UserWhereInput;
type prismaNamespace_UserWhereUniqueInput = UserWhereUniqueInput;
type prismaNamespace_VerificationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = VerificationAggregateArgs<ExtArgs>;
type prismaNamespace_VerificationCountAggregateInputType = VerificationCountAggregateInputType;
type prismaNamespace_VerificationCountAggregateOutputType = VerificationCountAggregateOutputType;
type prismaNamespace_VerificationGroupByOutputType = VerificationGroupByOutputType;
type prismaNamespace_VerificationMaxAggregateInputType = VerificationMaxAggregateInputType;
type prismaNamespace_VerificationMaxAggregateOutputType = VerificationMaxAggregateOutputType;
type prismaNamespace_VerificationMinAggregateInputType = VerificationMinAggregateInputType;
type prismaNamespace_VerificationMinAggregateOutputType = VerificationMinAggregateOutputType;
type prismaNamespace_VerificationScalarFieldEnum = VerificationScalarFieldEnum;
type prismaNamespace_XOR<T, U> = XOR<T, U>;
type prismaNamespace_accountCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountCountArgs<ExtArgs>;
type prismaNamespace_accountCountOrderByAggregateInput = accountCountOrderByAggregateInput;
type prismaNamespace_accountCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountCreateArgs<ExtArgs>;
type prismaNamespace_accountCreateInput = accountCreateInput;
type prismaNamespace_accountCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_accountCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountCreateManyArgs<ExtArgs>;
type prismaNamespace_accountCreateManyInput = accountCreateManyInput;
type prismaNamespace_accountCreateManyUserInput = accountCreateManyUserInput;
type prismaNamespace_accountCreateManyUserInputEnvelope = accountCreateManyUserInputEnvelope;
type prismaNamespace_accountCreateNestedManyWithoutUserInput = accountCreateNestedManyWithoutUserInput;
type prismaNamespace_accountCreateOrConnectWithoutUserInput = accountCreateOrConnectWithoutUserInput;
type prismaNamespace_accountCreateWithoutUserInput = accountCreateWithoutUserInput;
type prismaNamespace_accountDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountDefaultArgs<ExtArgs>;
type prismaNamespace_accountDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = accountDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_accountDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountDeleteArgs<ExtArgs>;
type prismaNamespace_accountDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountDeleteManyArgs<ExtArgs>;
type prismaNamespace_accountFieldRefs = accountFieldRefs;
type prismaNamespace_accountFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountFindFirstArgs<ExtArgs>;
type prismaNamespace_accountFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_accountFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountFindManyArgs<ExtArgs>;
type prismaNamespace_accountFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountFindUniqueArgs<ExtArgs>;
type prismaNamespace_accountFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_accountGetPayload<S extends boolean | null | undefined | accountDefaultArgs> = accountGetPayload<S>;
type prismaNamespace_accountGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountGroupByArgs<ExtArgs>;
type prismaNamespace_accountInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountInclude<ExtArgs>;
type prismaNamespace_accountIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_accountIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_accountMaxOrderByAggregateInput = accountMaxOrderByAggregateInput;
type prismaNamespace_accountMinOrderByAggregateInput = accountMinOrderByAggregateInput;
type prismaNamespace_accountModel = accountModel;
type prismaNamespace_accountOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountOmit<ExtArgs>;
type prismaNamespace_accountOrderByRelationAggregateInput = accountOrderByRelationAggregateInput;
type prismaNamespace_accountOrderByWithAggregationInput = accountOrderByWithAggregationInput;
type prismaNamespace_accountOrderByWithRelationInput = accountOrderByWithRelationInput;
type prismaNamespace_accountScalarWhereInput = accountScalarWhereInput;
type prismaNamespace_accountScalarWhereWithAggregatesInput = accountScalarWhereWithAggregatesInput;
type prismaNamespace_accountSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountSelect<ExtArgs>;
type prismaNamespace_accountSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_accountSelectScalar = accountSelectScalar;
type prismaNamespace_accountSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_accountUncheckedCreateInput = accountUncheckedCreateInput;
type prismaNamespace_accountUncheckedCreateNestedManyWithoutUserInput = accountUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_accountUncheckedCreateWithoutUserInput = accountUncheckedCreateWithoutUserInput;
type prismaNamespace_accountUncheckedUpdateInput = accountUncheckedUpdateInput;
type prismaNamespace_accountUncheckedUpdateManyInput = accountUncheckedUpdateManyInput;
type prismaNamespace_accountUncheckedUpdateManyWithoutUserInput = accountUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_accountUncheckedUpdateManyWithoutUserNestedInput = accountUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_accountUncheckedUpdateWithoutUserInput = accountUncheckedUpdateWithoutUserInput;
type prismaNamespace_accountUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountUpdateArgs<ExtArgs>;
type prismaNamespace_accountUpdateInput = accountUpdateInput;
type prismaNamespace_accountUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_accountUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountUpdateManyArgs<ExtArgs>;
type prismaNamespace_accountUpdateManyMutationInput = accountUpdateManyMutationInput;
type prismaNamespace_accountUpdateManyWithWhereWithoutUserInput = accountUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_accountUpdateManyWithoutUserNestedInput = accountUpdateManyWithoutUserNestedInput;
type prismaNamespace_accountUpdateWithWhereUniqueWithoutUserInput = accountUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_accountUpdateWithoutUserInput = accountUpdateWithoutUserInput;
type prismaNamespace_accountUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = accountUpsertArgs<ExtArgs>;
type prismaNamespace_accountUpsertWithWhereUniqueWithoutUserInput = accountUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_accountWhereInput = accountWhereInput;
type prismaNamespace_accountWhereUniqueInput = accountWhereUniqueInput;
declare const prismaNamespace_defineExtension: typeof defineExtension;
declare const prismaNamespace_empty: typeof empty;
declare const prismaNamespace_getExtensionContext: typeof getExtensionContext;
declare const prismaNamespace_join: typeof join;
declare const prismaNamespace_prismaVersion: typeof prismaVersion;
declare const prismaNamespace_raw: typeof raw;
type prismaNamespace_sessionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionCountArgs<ExtArgs>;
type prismaNamespace_sessionCountOrderByAggregateInput = sessionCountOrderByAggregateInput;
type prismaNamespace_sessionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionCreateArgs<ExtArgs>;
type prismaNamespace_sessionCreateInput = sessionCreateInput;
type prismaNamespace_sessionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_sessionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionCreateManyArgs<ExtArgs>;
type prismaNamespace_sessionCreateManyInput = sessionCreateManyInput;
type prismaNamespace_sessionCreateManyUserInput = sessionCreateManyUserInput;
type prismaNamespace_sessionCreateManyUserInputEnvelope = sessionCreateManyUserInputEnvelope;
type prismaNamespace_sessionCreateNestedManyWithoutUserInput = sessionCreateNestedManyWithoutUserInput;
type prismaNamespace_sessionCreateOrConnectWithoutUserInput = sessionCreateOrConnectWithoutUserInput;
type prismaNamespace_sessionCreateWithoutUserInput = sessionCreateWithoutUserInput;
type prismaNamespace_sessionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionDefaultArgs<ExtArgs>;
type prismaNamespace_sessionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = sessionDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_sessionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionDeleteArgs<ExtArgs>;
type prismaNamespace_sessionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionDeleteManyArgs<ExtArgs>;
type prismaNamespace_sessionFieldRefs = sessionFieldRefs;
type prismaNamespace_sessionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionFindFirstArgs<ExtArgs>;
type prismaNamespace_sessionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_sessionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionFindManyArgs<ExtArgs>;
type prismaNamespace_sessionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionFindUniqueArgs<ExtArgs>;
type prismaNamespace_sessionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = sessionGetPayload<S>;
type prismaNamespace_sessionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionGroupByArgs<ExtArgs>;
type prismaNamespace_sessionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionInclude<ExtArgs>;
type prismaNamespace_sessionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionIncludeCreateManyAndReturn<ExtArgs>;
type prismaNamespace_sessionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionIncludeUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_sessionMaxOrderByAggregateInput = sessionMaxOrderByAggregateInput;
type prismaNamespace_sessionMinOrderByAggregateInput = sessionMinOrderByAggregateInput;
type prismaNamespace_sessionModel = sessionModel;
type prismaNamespace_sessionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionOmit<ExtArgs>;
type prismaNamespace_sessionOrderByRelationAggregateInput = sessionOrderByRelationAggregateInput;
type prismaNamespace_sessionOrderByWithAggregationInput = sessionOrderByWithAggregationInput;
type prismaNamespace_sessionOrderByWithRelationInput = sessionOrderByWithRelationInput;
type prismaNamespace_sessionScalarWhereInput = sessionScalarWhereInput;
type prismaNamespace_sessionScalarWhereWithAggregatesInput = sessionScalarWhereWithAggregatesInput;
type prismaNamespace_sessionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionSelect<ExtArgs>;
type prismaNamespace_sessionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_sessionSelectScalar = sessionSelectScalar;
type prismaNamespace_sessionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_sessionUncheckedCreateInput = sessionUncheckedCreateInput;
type prismaNamespace_sessionUncheckedCreateNestedManyWithoutUserInput = sessionUncheckedCreateNestedManyWithoutUserInput;
type prismaNamespace_sessionUncheckedCreateWithoutUserInput = sessionUncheckedCreateWithoutUserInput;
type prismaNamespace_sessionUncheckedUpdateInput = sessionUncheckedUpdateInput;
type prismaNamespace_sessionUncheckedUpdateManyInput = sessionUncheckedUpdateManyInput;
type prismaNamespace_sessionUncheckedUpdateManyWithoutUserInput = sessionUncheckedUpdateManyWithoutUserInput;
type prismaNamespace_sessionUncheckedUpdateManyWithoutUserNestedInput = sessionUncheckedUpdateManyWithoutUserNestedInput;
type prismaNamespace_sessionUncheckedUpdateWithoutUserInput = sessionUncheckedUpdateWithoutUserInput;
type prismaNamespace_sessionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionUpdateArgs<ExtArgs>;
type prismaNamespace_sessionUpdateInput = sessionUpdateInput;
type prismaNamespace_sessionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_sessionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionUpdateManyArgs<ExtArgs>;
type prismaNamespace_sessionUpdateManyMutationInput = sessionUpdateManyMutationInput;
type prismaNamespace_sessionUpdateManyWithWhereWithoutUserInput = sessionUpdateManyWithWhereWithoutUserInput;
type prismaNamespace_sessionUpdateManyWithoutUserNestedInput = sessionUpdateManyWithoutUserNestedInput;
type prismaNamespace_sessionUpdateWithWhereUniqueWithoutUserInput = sessionUpdateWithWhereUniqueWithoutUserInput;
type prismaNamespace_sessionUpdateWithoutUserInput = sessionUpdateWithoutUserInput;
type prismaNamespace_sessionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = sessionUpsertArgs<ExtArgs>;
type prismaNamespace_sessionUpsertWithWhereUniqueWithoutUserInput = sessionUpsertWithWhereUniqueWithoutUserInput;
type prismaNamespace_sessionWhereInput = sessionWhereInput;
type prismaNamespace_sessionWhereUniqueInput = sessionWhereUniqueInput;
declare const prismaNamespace_sql: typeof sql;
type prismaNamespace_verificationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationCountArgs<ExtArgs>;
type prismaNamespace_verificationCountOrderByAggregateInput = verificationCountOrderByAggregateInput;
type prismaNamespace_verificationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationCreateArgs<ExtArgs>;
type prismaNamespace_verificationCreateInput = verificationCreateInput;
type prismaNamespace_verificationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationCreateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_verificationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationCreateManyArgs<ExtArgs>;
type prismaNamespace_verificationCreateManyInput = verificationCreateManyInput;
type prismaNamespace_verificationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationDefaultArgs<ExtArgs>;
type prismaNamespace_verificationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = verificationDelegate<ExtArgs, GlobalOmitOptions>;
type prismaNamespace_verificationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationDeleteArgs<ExtArgs>;
type prismaNamespace_verificationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationDeleteManyArgs<ExtArgs>;
type prismaNamespace_verificationFieldRefs = verificationFieldRefs;
type prismaNamespace_verificationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationFindFirstArgs<ExtArgs>;
type prismaNamespace_verificationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationFindFirstOrThrowArgs<ExtArgs>;
type prismaNamespace_verificationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationFindManyArgs<ExtArgs>;
type prismaNamespace_verificationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationFindUniqueArgs<ExtArgs>;
type prismaNamespace_verificationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationFindUniqueOrThrowArgs<ExtArgs>;
type prismaNamespace_verificationGetPayload<S extends boolean | null | undefined | verificationDefaultArgs> = verificationGetPayload<S>;
type prismaNamespace_verificationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationGroupByArgs<ExtArgs>;
type prismaNamespace_verificationMaxOrderByAggregateInput = verificationMaxOrderByAggregateInput;
type prismaNamespace_verificationMinOrderByAggregateInput = verificationMinOrderByAggregateInput;
type prismaNamespace_verificationModel = verificationModel;
type prismaNamespace_verificationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationOmit<ExtArgs>;
type prismaNamespace_verificationOrderByWithAggregationInput = verificationOrderByWithAggregationInput;
type prismaNamespace_verificationOrderByWithRelationInput = verificationOrderByWithRelationInput;
type prismaNamespace_verificationScalarWhereWithAggregatesInput = verificationScalarWhereWithAggregatesInput;
type prismaNamespace_verificationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationSelect<ExtArgs>;
type prismaNamespace_verificationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationSelectCreateManyAndReturn<ExtArgs>;
type prismaNamespace_verificationSelectScalar = verificationSelectScalar;
type prismaNamespace_verificationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationSelectUpdateManyAndReturn<ExtArgs>;
type prismaNamespace_verificationUncheckedCreateInput = verificationUncheckedCreateInput;
type prismaNamespace_verificationUncheckedUpdateInput = verificationUncheckedUpdateInput;
type prismaNamespace_verificationUncheckedUpdateManyInput = verificationUncheckedUpdateManyInput;
type prismaNamespace_verificationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationUpdateArgs<ExtArgs>;
type prismaNamespace_verificationUpdateInput = verificationUpdateInput;
type prismaNamespace_verificationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationUpdateManyAndReturnArgs<ExtArgs>;
type prismaNamespace_verificationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationUpdateManyArgs<ExtArgs>;
type prismaNamespace_verificationUpdateManyMutationInput = verificationUpdateManyMutationInput;
type prismaNamespace_verificationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = verificationUpsertArgs<ExtArgs>;
type prismaNamespace_verificationWhereInput = verificationWhereInput;
type prismaNamespace_verificationWhereUniqueInput = verificationWhereUniqueInput;
declare namespace prismaNamespace {
  export { type prismaNamespace_$AppointmentPayload as $AppointmentPayload, type prismaNamespace_$AuditLogPayload as $AuditLogPayload, type prismaNamespace_$DoctorApplicationPayload as $DoctorApplicationPayload, type prismaNamespace_$DoctorHospitalProfilePayload as $DoctorHospitalProfilePayload, type prismaNamespace_$DoctorPayload as $DoctorPayload, type prismaNamespace_$DoctorSpecializationPayload as $DoctorSpecializationPayload, type prismaNamespace_$HospitalPayload as $HospitalPayload, type prismaNamespace_$HospitalSpecializationPayload as $HospitalSpecializationPayload, type prismaNamespace_$NotificationPayload as $NotificationPayload, type prismaNamespace_$PaymentPayload as $PaymentPayload, type prismaNamespace_$ReviewPayload as $ReviewPayload, type prismaNamespace_$SavedDoctorHospitalPayload as $SavedDoctorHospitalPayload, type prismaNamespace_$SchedulePayload as $SchedulePayload, type prismaNamespace_$SearchLogPayload as $SearchLogPayload, type prismaNamespace_$SlotPayload as $SlotPayload, type prismaNamespace_$SpecializationPayload as $SpecializationPayload, type prismaNamespace_$UserPayload as $UserPayload, type prismaNamespace_$accountPayload as $accountPayload, type prismaNamespace_$sessionPayload as $sessionPayload, type prismaNamespace_$verificationPayload as $verificationPayload, type prismaNamespace_AccountAggregateArgs as AccountAggregateArgs, type prismaNamespace_AccountCountAggregateInputType as AccountCountAggregateInputType, type prismaNamespace_AccountCountAggregateOutputType as AccountCountAggregateOutputType, type prismaNamespace_AccountGroupByOutputType as AccountGroupByOutputType, type prismaNamespace_AccountListRelationFilter as AccountListRelationFilter, type prismaNamespace_AccountMaxAggregateInputType as AccountMaxAggregateInputType, type prismaNamespace_AccountMaxAggregateOutputType as AccountMaxAggregateOutputType, type prismaNamespace_AccountMinAggregateInputType as AccountMinAggregateInputType, type prismaNamespace_AccountMinAggregateOutputType as AccountMinAggregateOutputType, type prismaNamespace_AccountScalarFieldEnum as AccountScalarFieldEnum, type prismaNamespace_AggregateAccount as AggregateAccount, type prismaNamespace_AggregateAppointment as AggregateAppointment, type prismaNamespace_AggregateAuditLog as AggregateAuditLog, type prismaNamespace_AggregateDoctor as AggregateDoctor, type prismaNamespace_AggregateDoctorApplication as AggregateDoctorApplication, type prismaNamespace_AggregateDoctorHospitalProfile as AggregateDoctorHospitalProfile, type prismaNamespace_AggregateDoctorSpecialization as AggregateDoctorSpecialization, type prismaNamespace_AggregateHospital as AggregateHospital, type prismaNamespace_AggregateHospitalSpecialization as AggregateHospitalSpecialization, type prismaNamespace_AggregateNotification as AggregateNotification, type prismaNamespace_AggregatePayment as AggregatePayment, type prismaNamespace_AggregateReview as AggregateReview, type prismaNamespace_AggregateSavedDoctorHospital as AggregateSavedDoctorHospital, type prismaNamespace_AggregateSchedule as AggregateSchedule, type prismaNamespace_AggregateSearchLog as AggregateSearchLog, type prismaNamespace_AggregateSession as AggregateSession, type prismaNamespace_AggregateSlot as AggregateSlot, type prismaNamespace_AggregateSpecialization as AggregateSpecialization, type prismaNamespace_AggregateUser as AggregateUser, type prismaNamespace_AggregateVerification as AggregateVerification, prismaNamespace_AnyNull as AnyNull, type prismaNamespace_Appointment$PaymentArgs as Appointment$PaymentArgs, type prismaNamespace_Appointment$SlotArgs as Appointment$SlotArgs, type prismaNamespace_Appointment$User_Appointment_approvedByToUserArgs as Appointment$User_Appointment_approvedByToUserArgs, type prismaNamespace_AppointmentAggregateArgs as AppointmentAggregateArgs, type prismaNamespace_AppointmentCountAggregateInputType as AppointmentCountAggregateInputType, type prismaNamespace_AppointmentCountAggregateOutputType as AppointmentCountAggregateOutputType, type prismaNamespace_AppointmentCountArgs as AppointmentCountArgs, type prismaNamespace_AppointmentCountOrderByAggregateInput as AppointmentCountOrderByAggregateInput, type prismaNamespace_AppointmentCreateArgs as AppointmentCreateArgs, type prismaNamespace_AppointmentCreateInput as AppointmentCreateInput, type prismaNamespace_AppointmentCreateManyAndReturnArgs as AppointmentCreateManyAndReturnArgs, type prismaNamespace_AppointmentCreateManyArgs as AppointmentCreateManyArgs, type prismaNamespace_AppointmentCreateManyDoctorInput as AppointmentCreateManyDoctorInput, type prismaNamespace_AppointmentCreateManyDoctorInputEnvelope as AppointmentCreateManyDoctorInputEnvelope, type prismaNamespace_AppointmentCreateManyHospitalInput as AppointmentCreateManyHospitalInput, type prismaNamespace_AppointmentCreateManyHospitalInputEnvelope as AppointmentCreateManyHospitalInputEnvelope, type prismaNamespace_AppointmentCreateManyInput as AppointmentCreateManyInput, type prismaNamespace_AppointmentCreateManyScheduleInput as AppointmentCreateManyScheduleInput, type prismaNamespace_AppointmentCreateManyScheduleInputEnvelope as AppointmentCreateManyScheduleInputEnvelope, type prismaNamespace_AppointmentCreateManyUser_Appointment_approvedByToUserInput as AppointmentCreateManyUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope as AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope, type prismaNamespace_AppointmentCreateManyUser_Appointment_customerIdToUserInput as AppointmentCreateManyUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope as AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope, type prismaNamespace_AppointmentCreateNestedManyWithoutDoctorInput as AppointmentCreateNestedManyWithoutDoctorInput, type prismaNamespace_AppointmentCreateNestedManyWithoutHospitalInput as AppointmentCreateNestedManyWithoutHospitalInput, type prismaNamespace_AppointmentCreateNestedManyWithoutScheduleInput as AppointmentCreateNestedManyWithoutScheduleInput, type prismaNamespace_AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput as AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput as AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentCreateNestedOneWithoutPaymentInput as AppointmentCreateNestedOneWithoutPaymentInput, type prismaNamespace_AppointmentCreateNestedOneWithoutSlotInput as AppointmentCreateNestedOneWithoutSlotInput, type prismaNamespace_AppointmentCreateOrConnectWithoutDoctorInput as AppointmentCreateOrConnectWithoutDoctorInput, type prismaNamespace_AppointmentCreateOrConnectWithoutHospitalInput as AppointmentCreateOrConnectWithoutHospitalInput, type prismaNamespace_AppointmentCreateOrConnectWithoutPaymentInput as AppointmentCreateOrConnectWithoutPaymentInput, type prismaNamespace_AppointmentCreateOrConnectWithoutScheduleInput as AppointmentCreateOrConnectWithoutScheduleInput, type prismaNamespace_AppointmentCreateOrConnectWithoutSlotInput as AppointmentCreateOrConnectWithoutSlotInput, type prismaNamespace_AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput as AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput as AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentCreateWithoutDoctorInput as AppointmentCreateWithoutDoctorInput, type prismaNamespace_AppointmentCreateWithoutHospitalInput as AppointmentCreateWithoutHospitalInput, type prismaNamespace_AppointmentCreateWithoutPaymentInput as AppointmentCreateWithoutPaymentInput, type prismaNamespace_AppointmentCreateWithoutScheduleInput as AppointmentCreateWithoutScheduleInput, type prismaNamespace_AppointmentCreateWithoutSlotInput as AppointmentCreateWithoutSlotInput, type prismaNamespace_AppointmentCreateWithoutUser_Appointment_approvedByToUserInput as AppointmentCreateWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentCreateWithoutUser_Appointment_customerIdToUserInput as AppointmentCreateWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentDefaultArgs as AppointmentDefaultArgs, type prismaNamespace_AppointmentDelegate as AppointmentDelegate, type prismaNamespace_AppointmentDeleteArgs as AppointmentDeleteArgs, type prismaNamespace_AppointmentDeleteManyArgs as AppointmentDeleteManyArgs, type prismaNamespace_AppointmentFieldRefs as AppointmentFieldRefs, type prismaNamespace_AppointmentFindFirstArgs as AppointmentFindFirstArgs, type prismaNamespace_AppointmentFindFirstOrThrowArgs as AppointmentFindFirstOrThrowArgs, type prismaNamespace_AppointmentFindManyArgs as AppointmentFindManyArgs, type prismaNamespace_AppointmentFindUniqueArgs as AppointmentFindUniqueArgs, type prismaNamespace_AppointmentFindUniqueOrThrowArgs as AppointmentFindUniqueOrThrowArgs, type prismaNamespace_AppointmentGetPayload as AppointmentGetPayload, type prismaNamespace_AppointmentGroupByArgs as AppointmentGroupByArgs, type prismaNamespace_AppointmentGroupByOutputType as AppointmentGroupByOutputType, type prismaNamespace_AppointmentInclude as AppointmentInclude, type prismaNamespace_AppointmentIncludeCreateManyAndReturn as AppointmentIncludeCreateManyAndReturn, type prismaNamespace_AppointmentIncludeUpdateManyAndReturn as AppointmentIncludeUpdateManyAndReturn, type prismaNamespace_AppointmentListRelationFilter as AppointmentListRelationFilter, type prismaNamespace_AppointmentMaxAggregateInputType as AppointmentMaxAggregateInputType, type prismaNamespace_AppointmentMaxAggregateOutputType as AppointmentMaxAggregateOutputType, type prismaNamespace_AppointmentMaxOrderByAggregateInput as AppointmentMaxOrderByAggregateInput, type prismaNamespace_AppointmentMinAggregateInputType as AppointmentMinAggregateInputType, type prismaNamespace_AppointmentMinAggregateOutputType as AppointmentMinAggregateOutputType, type prismaNamespace_AppointmentMinOrderByAggregateInput as AppointmentMinOrderByAggregateInput, type prismaNamespace_AppointmentModel as AppointmentModel, type prismaNamespace_AppointmentNullableScalarRelationFilter as AppointmentNullableScalarRelationFilter, type prismaNamespace_AppointmentOmit as AppointmentOmit, type prismaNamespace_AppointmentOrderByRelationAggregateInput as AppointmentOrderByRelationAggregateInput, type prismaNamespace_AppointmentOrderByWithAggregationInput as AppointmentOrderByWithAggregationInput, type prismaNamespace_AppointmentOrderByWithRelationInput as AppointmentOrderByWithRelationInput, type prismaNamespace_AppointmentScalarFieldEnum as AppointmentScalarFieldEnum, type prismaNamespace_AppointmentScalarRelationFilter as AppointmentScalarRelationFilter, type prismaNamespace_AppointmentScalarWhereInput as AppointmentScalarWhereInput, type prismaNamespace_AppointmentScalarWhereWithAggregatesInput as AppointmentScalarWhereWithAggregatesInput, type prismaNamespace_AppointmentSelect as AppointmentSelect, type prismaNamespace_AppointmentSelectCreateManyAndReturn as AppointmentSelectCreateManyAndReturn, type prismaNamespace_AppointmentSelectScalar as AppointmentSelectScalar, type prismaNamespace_AppointmentSelectUpdateManyAndReturn as AppointmentSelectUpdateManyAndReturn, type prismaNamespace_AppointmentUncheckedCreateInput as AppointmentUncheckedCreateInput, type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutDoctorInput as AppointmentUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutHospitalInput as AppointmentUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutScheduleInput as AppointmentUncheckedCreateNestedManyWithoutScheduleInput, type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput as AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput as AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUncheckedCreateWithoutDoctorInput as AppointmentUncheckedCreateWithoutDoctorInput, type prismaNamespace_AppointmentUncheckedCreateWithoutHospitalInput as AppointmentUncheckedCreateWithoutHospitalInput, type prismaNamespace_AppointmentUncheckedCreateWithoutPaymentInput as AppointmentUncheckedCreateWithoutPaymentInput, type prismaNamespace_AppointmentUncheckedCreateWithoutScheduleInput as AppointmentUncheckedCreateWithoutScheduleInput, type prismaNamespace_AppointmentUncheckedCreateWithoutSlotInput as AppointmentUncheckedCreateWithoutSlotInput, type prismaNamespace_AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput as AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput as AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUncheckedUpdateInput as AppointmentUncheckedUpdateInput, type prismaNamespace_AppointmentUncheckedUpdateManyInput as AppointmentUncheckedUpdateManyInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutDoctorInput as AppointmentUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutDoctorNestedInput as AppointmentUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutHospitalInput as AppointmentUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutHospitalNestedInput as AppointmentUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutScheduleInput as AppointmentUncheckedUpdateManyWithoutScheduleInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutScheduleNestedInput as AppointmentUncheckedUpdateManyWithoutScheduleNestedInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput as AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput as AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput as AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput as AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutDoctorInput as AppointmentUncheckedUpdateWithoutDoctorInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutHospitalInput as AppointmentUncheckedUpdateWithoutHospitalInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutPaymentInput as AppointmentUncheckedUpdateWithoutPaymentInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutScheduleInput as AppointmentUncheckedUpdateWithoutScheduleInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutSlotInput as AppointmentUncheckedUpdateWithoutSlotInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput as AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput as AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUpdateArgs as AppointmentUpdateArgs, type prismaNamespace_AppointmentUpdateInput as AppointmentUpdateInput, type prismaNamespace_AppointmentUpdateManyAndReturnArgs as AppointmentUpdateManyAndReturnArgs, type prismaNamespace_AppointmentUpdateManyArgs as AppointmentUpdateManyArgs, type prismaNamespace_AppointmentUpdateManyMutationInput as AppointmentUpdateManyMutationInput, type prismaNamespace_AppointmentUpdateManyWithWhereWithoutDoctorInput as AppointmentUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_AppointmentUpdateManyWithWhereWithoutHospitalInput as AppointmentUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_AppointmentUpdateManyWithWhereWithoutScheduleInput as AppointmentUpdateManyWithWhereWithoutScheduleInput, type prismaNamespace_AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput as AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput as AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUpdateManyWithoutDoctorNestedInput as AppointmentUpdateManyWithoutDoctorNestedInput, type prismaNamespace_AppointmentUpdateManyWithoutHospitalNestedInput as AppointmentUpdateManyWithoutHospitalNestedInput, type prismaNamespace_AppointmentUpdateManyWithoutScheduleNestedInput as AppointmentUpdateManyWithoutScheduleNestedInput, type prismaNamespace_AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput as AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput, type prismaNamespace_AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput as AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput, type prismaNamespace_AppointmentUpdateOneRequiredWithoutPaymentNestedInput as AppointmentUpdateOneRequiredWithoutPaymentNestedInput, type prismaNamespace_AppointmentUpdateOneWithoutSlotNestedInput as AppointmentUpdateOneWithoutSlotNestedInput, type prismaNamespace_AppointmentUpdateToOneWithWhereWithoutPaymentInput as AppointmentUpdateToOneWithWhereWithoutPaymentInput, type prismaNamespace_AppointmentUpdateToOneWithWhereWithoutSlotInput as AppointmentUpdateToOneWithWhereWithoutSlotInput, type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutDoctorInput as AppointmentUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutHospitalInput as AppointmentUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutScheduleInput as AppointmentUpdateWithWhereUniqueWithoutScheduleInput, type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput as AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput as AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUpdateWithoutDoctorInput as AppointmentUpdateWithoutDoctorInput, type prismaNamespace_AppointmentUpdateWithoutHospitalInput as AppointmentUpdateWithoutHospitalInput, type prismaNamespace_AppointmentUpdateWithoutPaymentInput as AppointmentUpdateWithoutPaymentInput, type prismaNamespace_AppointmentUpdateWithoutScheduleInput as AppointmentUpdateWithoutScheduleInput, type prismaNamespace_AppointmentUpdateWithoutSlotInput as AppointmentUpdateWithoutSlotInput, type prismaNamespace_AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput as AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput as AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUpsertArgs as AppointmentUpsertArgs, type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutDoctorInput as AppointmentUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutHospitalInput as AppointmentUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutScheduleInput as AppointmentUpsertWithWhereUniqueWithoutScheduleInput, type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput as AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput, type prismaNamespace_AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput as AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput, type prismaNamespace_AppointmentUpsertWithoutPaymentInput as AppointmentUpsertWithoutPaymentInput, type prismaNamespace_AppointmentUpsertWithoutSlotInput as AppointmentUpsertWithoutSlotInput, type prismaNamespace_AppointmentWhereInput as AppointmentWhereInput, type prismaNamespace_AppointmentWhereUniqueInput as AppointmentWhereUniqueInput, type prismaNamespace_Args as Args, type prismaNamespace_At as At, type prismaNamespace_AtLeast as AtLeast, type prismaNamespace_AuditLogAggregateArgs as AuditLogAggregateArgs, type prismaNamespace_AuditLogCountAggregateInputType as AuditLogCountAggregateInputType, type prismaNamespace_AuditLogCountAggregateOutputType as AuditLogCountAggregateOutputType, type prismaNamespace_AuditLogCountArgs as AuditLogCountArgs, type prismaNamespace_AuditLogCountOrderByAggregateInput as AuditLogCountOrderByAggregateInput, type prismaNamespace_AuditLogCreateArgs as AuditLogCreateArgs, type prismaNamespace_AuditLogCreateInput as AuditLogCreateInput, type prismaNamespace_AuditLogCreateManyAndReturnArgs as AuditLogCreateManyAndReturnArgs, type prismaNamespace_AuditLogCreateManyArgs as AuditLogCreateManyArgs, type prismaNamespace_AuditLogCreateManyInput as AuditLogCreateManyInput, type prismaNamespace_AuditLogCreateManyUserInput as AuditLogCreateManyUserInput, type prismaNamespace_AuditLogCreateManyUserInputEnvelope as AuditLogCreateManyUserInputEnvelope, type prismaNamespace_AuditLogCreateNestedManyWithoutUserInput as AuditLogCreateNestedManyWithoutUserInput, type prismaNamespace_AuditLogCreateOrConnectWithoutUserInput as AuditLogCreateOrConnectWithoutUserInput, type prismaNamespace_AuditLogCreateWithoutUserInput as AuditLogCreateWithoutUserInput, type prismaNamespace_AuditLogDefaultArgs as AuditLogDefaultArgs, type prismaNamespace_AuditLogDelegate as AuditLogDelegate, type prismaNamespace_AuditLogDeleteArgs as AuditLogDeleteArgs, type prismaNamespace_AuditLogDeleteManyArgs as AuditLogDeleteManyArgs, type prismaNamespace_AuditLogFieldRefs as AuditLogFieldRefs, type prismaNamespace_AuditLogFindFirstArgs as AuditLogFindFirstArgs, type prismaNamespace_AuditLogFindFirstOrThrowArgs as AuditLogFindFirstOrThrowArgs, type prismaNamespace_AuditLogFindManyArgs as AuditLogFindManyArgs, type prismaNamespace_AuditLogFindUniqueArgs as AuditLogFindUniqueArgs, type prismaNamespace_AuditLogFindUniqueOrThrowArgs as AuditLogFindUniqueOrThrowArgs, type prismaNamespace_AuditLogGetPayload as AuditLogGetPayload, type prismaNamespace_AuditLogGroupByArgs as AuditLogGroupByArgs, type prismaNamespace_AuditLogGroupByOutputType as AuditLogGroupByOutputType, type prismaNamespace_AuditLogInclude as AuditLogInclude, type prismaNamespace_AuditLogIncludeCreateManyAndReturn as AuditLogIncludeCreateManyAndReturn, type prismaNamespace_AuditLogIncludeUpdateManyAndReturn as AuditLogIncludeUpdateManyAndReturn, type prismaNamespace_AuditLogListRelationFilter as AuditLogListRelationFilter, type prismaNamespace_AuditLogMaxAggregateInputType as AuditLogMaxAggregateInputType, type prismaNamespace_AuditLogMaxAggregateOutputType as AuditLogMaxAggregateOutputType, type prismaNamespace_AuditLogMaxOrderByAggregateInput as AuditLogMaxOrderByAggregateInput, type prismaNamespace_AuditLogMinAggregateInputType as AuditLogMinAggregateInputType, type prismaNamespace_AuditLogMinAggregateOutputType as AuditLogMinAggregateOutputType, type prismaNamespace_AuditLogMinOrderByAggregateInput as AuditLogMinOrderByAggregateInput, type prismaNamespace_AuditLogModel as AuditLogModel, type prismaNamespace_AuditLogOmit as AuditLogOmit, type prismaNamespace_AuditLogOrderByRelationAggregateInput as AuditLogOrderByRelationAggregateInput, type prismaNamespace_AuditLogOrderByWithAggregationInput as AuditLogOrderByWithAggregationInput, type prismaNamespace_AuditLogOrderByWithRelationInput as AuditLogOrderByWithRelationInput, type prismaNamespace_AuditLogScalarFieldEnum as AuditLogScalarFieldEnum, type prismaNamespace_AuditLogScalarWhereInput as AuditLogScalarWhereInput, type prismaNamespace_AuditLogScalarWhereWithAggregatesInput as AuditLogScalarWhereWithAggregatesInput, type prismaNamespace_AuditLogSelect as AuditLogSelect, type prismaNamespace_AuditLogSelectCreateManyAndReturn as AuditLogSelectCreateManyAndReturn, type prismaNamespace_AuditLogSelectScalar as AuditLogSelectScalar, type prismaNamespace_AuditLogSelectUpdateManyAndReturn as AuditLogSelectUpdateManyAndReturn, type prismaNamespace_AuditLogUncheckedCreateInput as AuditLogUncheckedCreateInput, type prismaNamespace_AuditLogUncheckedCreateNestedManyWithoutUserInput as AuditLogUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_AuditLogUncheckedCreateWithoutUserInput as AuditLogUncheckedCreateWithoutUserInput, type prismaNamespace_AuditLogUncheckedUpdateInput as AuditLogUncheckedUpdateInput, type prismaNamespace_AuditLogUncheckedUpdateManyInput as AuditLogUncheckedUpdateManyInput, type prismaNamespace_AuditLogUncheckedUpdateManyWithoutUserInput as AuditLogUncheckedUpdateManyWithoutUserInput, type prismaNamespace_AuditLogUncheckedUpdateManyWithoutUserNestedInput as AuditLogUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_AuditLogUncheckedUpdateWithoutUserInput as AuditLogUncheckedUpdateWithoutUserInput, type prismaNamespace_AuditLogUpdateArgs as AuditLogUpdateArgs, type prismaNamespace_AuditLogUpdateInput as AuditLogUpdateInput, type prismaNamespace_AuditLogUpdateManyAndReturnArgs as AuditLogUpdateManyAndReturnArgs, type prismaNamespace_AuditLogUpdateManyArgs as AuditLogUpdateManyArgs, type prismaNamespace_AuditLogUpdateManyMutationInput as AuditLogUpdateManyMutationInput, type prismaNamespace_AuditLogUpdateManyWithWhereWithoutUserInput as AuditLogUpdateManyWithWhereWithoutUserInput, type prismaNamespace_AuditLogUpdateManyWithoutUserNestedInput as AuditLogUpdateManyWithoutUserNestedInput, type prismaNamespace_AuditLogUpdateWithWhereUniqueWithoutUserInput as AuditLogUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_AuditLogUpdateWithoutUserInput as AuditLogUpdateWithoutUserInput, type prismaNamespace_AuditLogUpsertArgs as AuditLogUpsertArgs, type prismaNamespace_AuditLogUpsertWithWhereUniqueWithoutUserInput as AuditLogUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_AuditLogWhereInput as AuditLogWhereInput, type prismaNamespace_AuditLogWhereUniqueInput as AuditLogWhereUniqueInput, type prismaNamespace_BatchPayload as BatchPayload, type prismaNamespace_BoolFieldUpdateOperationsInput as BoolFieldUpdateOperationsInput, type prismaNamespace_BoolFilter as BoolFilter, type prismaNamespace_BoolNullableFilter as BoolNullableFilter, type prismaNamespace_BoolNullableWithAggregatesFilter as BoolNullableWithAggregatesFilter, type prismaNamespace_BoolWithAggregatesFilter as BoolWithAggregatesFilter, type prismaNamespace_Boolean as Boolean, type prismaNamespace_BooleanFieldRefInput as BooleanFieldRefInput, type prismaNamespace_Bytes as Bytes, type prismaNamespace_CheckIsLogLevel as CheckIsLogLevel, type prismaNamespace_ComputeRaw as ComputeRaw, type prismaNamespace_DMMF as DMMF, type prismaNamespace_DateTimeFieldRefInput as DateTimeFieldRefInput, type prismaNamespace_DateTimeFieldUpdateOperationsInput as DateTimeFieldUpdateOperationsInput, type prismaNamespace_DateTimeFilter as DateTimeFilter, type prismaNamespace_DateTimeNullableFilter as DateTimeNullableFilter, type prismaNamespace_DateTimeNullableWithAggregatesFilter as DateTimeNullableWithAggregatesFilter, type prismaNamespace_DateTimeWithAggregatesFilter as DateTimeWithAggregatesFilter, prismaNamespace_DbNull as DbNull, type prismaNamespace_Decimal as Decimal, type prismaNamespace_DecimalFieldRefInput as DecimalFieldRefInput, type prismaNamespace_DecimalFieldUpdateOperationsInput as DecimalFieldUpdateOperationsInput, type prismaNamespace_DecimalFilter as DecimalFilter, type prismaNamespace_DecimalJsLike as DecimalJsLike, type prismaNamespace_DecimalNullableFilter as DecimalNullableFilter, type prismaNamespace_DecimalNullableWithAggregatesFilter as DecimalNullableWithAggregatesFilter, type prismaNamespace_DecimalWithAggregatesFilter as DecimalWithAggregatesFilter, type prismaNamespace_DefaultPrismaClient as DefaultPrismaClient, type prismaNamespace_Doctor$AppointmentArgs as Doctor$AppointmentArgs, type prismaNamespace_Doctor$DoctorHospitalProfileArgs as Doctor$DoctorHospitalProfileArgs, type prismaNamespace_Doctor$DoctorSpecializationArgs as Doctor$DoctorSpecializationArgs, type prismaNamespace_Doctor$ReviewArgs as Doctor$ReviewArgs, type prismaNamespace_Doctor$SavedDoctorHospitalArgs as Doctor$SavedDoctorHospitalArgs, type prismaNamespace_Doctor$ScheduleArgs as Doctor$ScheduleArgs, type prismaNamespace_DoctorAggregateArgs as DoctorAggregateArgs, type prismaNamespace_DoctorApplicationAggregateArgs as DoctorApplicationAggregateArgs, type prismaNamespace_DoctorApplicationAvgAggregateInputType as DoctorApplicationAvgAggregateInputType, type prismaNamespace_DoctorApplicationAvgAggregateOutputType as DoctorApplicationAvgAggregateOutputType, type prismaNamespace_DoctorApplicationAvgOrderByAggregateInput as DoctorApplicationAvgOrderByAggregateInput, type prismaNamespace_DoctorApplicationCountAggregateInputType as DoctorApplicationCountAggregateInputType, type prismaNamespace_DoctorApplicationCountAggregateOutputType as DoctorApplicationCountAggregateOutputType, type prismaNamespace_DoctorApplicationCountArgs as DoctorApplicationCountArgs, type prismaNamespace_DoctorApplicationCountOrderByAggregateInput as DoctorApplicationCountOrderByAggregateInput, type prismaNamespace_DoctorApplicationCreateArgs as DoctorApplicationCreateArgs, type prismaNamespace_DoctorApplicationCreateInput as DoctorApplicationCreateInput, type prismaNamespace_DoctorApplicationCreateManyAndReturnArgs as DoctorApplicationCreateManyAndReturnArgs, type prismaNamespace_DoctorApplicationCreateManyArgs as DoctorApplicationCreateManyArgs, type prismaNamespace_DoctorApplicationCreateManyHospitalInput as DoctorApplicationCreateManyHospitalInput, type prismaNamespace_DoctorApplicationCreateManyHospitalInputEnvelope as DoctorApplicationCreateManyHospitalInputEnvelope, type prismaNamespace_DoctorApplicationCreateManyInput as DoctorApplicationCreateManyInput, type prismaNamespace_DoctorApplicationCreateManyUserInput as DoctorApplicationCreateManyUserInput, type prismaNamespace_DoctorApplicationCreateManyUserInputEnvelope as DoctorApplicationCreateManyUserInputEnvelope, type prismaNamespace_DoctorApplicationCreateNestedManyWithoutHospitalInput as DoctorApplicationCreateNestedManyWithoutHospitalInput, type prismaNamespace_DoctorApplicationCreateNestedManyWithoutUserInput as DoctorApplicationCreateNestedManyWithoutUserInput, type prismaNamespace_DoctorApplicationCreateOrConnectWithoutHospitalInput as DoctorApplicationCreateOrConnectWithoutHospitalInput, type prismaNamespace_DoctorApplicationCreateOrConnectWithoutUserInput as DoctorApplicationCreateOrConnectWithoutUserInput, type prismaNamespace_DoctorApplicationCreateWithoutHospitalInput as DoctorApplicationCreateWithoutHospitalInput, type prismaNamespace_DoctorApplicationCreateWithoutUserInput as DoctorApplicationCreateWithoutUserInput, type prismaNamespace_DoctorApplicationCreatespecializationIdsInput as DoctorApplicationCreatespecializationIdsInput, type prismaNamespace_DoctorApplicationDefaultArgs as DoctorApplicationDefaultArgs, type prismaNamespace_DoctorApplicationDelegate as DoctorApplicationDelegate, type prismaNamespace_DoctorApplicationDeleteArgs as DoctorApplicationDeleteArgs, type prismaNamespace_DoctorApplicationDeleteManyArgs as DoctorApplicationDeleteManyArgs, type prismaNamespace_DoctorApplicationFieldRefs as DoctorApplicationFieldRefs, type prismaNamespace_DoctorApplicationFindFirstArgs as DoctorApplicationFindFirstArgs, type prismaNamespace_DoctorApplicationFindFirstOrThrowArgs as DoctorApplicationFindFirstOrThrowArgs, type prismaNamespace_DoctorApplicationFindManyArgs as DoctorApplicationFindManyArgs, type prismaNamespace_DoctorApplicationFindUniqueArgs as DoctorApplicationFindUniqueArgs, type prismaNamespace_DoctorApplicationFindUniqueOrThrowArgs as DoctorApplicationFindUniqueOrThrowArgs, type prismaNamespace_DoctorApplicationGetPayload as DoctorApplicationGetPayload, type prismaNamespace_DoctorApplicationGroupByArgs as DoctorApplicationGroupByArgs, type prismaNamespace_DoctorApplicationGroupByOutputType as DoctorApplicationGroupByOutputType, type prismaNamespace_DoctorApplicationInclude as DoctorApplicationInclude, type prismaNamespace_DoctorApplicationIncludeCreateManyAndReturn as DoctorApplicationIncludeCreateManyAndReturn, type prismaNamespace_DoctorApplicationIncludeUpdateManyAndReturn as DoctorApplicationIncludeUpdateManyAndReturn, type prismaNamespace_DoctorApplicationListRelationFilter as DoctorApplicationListRelationFilter, type prismaNamespace_DoctorApplicationMaxAggregateInputType as DoctorApplicationMaxAggregateInputType, type prismaNamespace_DoctorApplicationMaxAggregateOutputType as DoctorApplicationMaxAggregateOutputType, type prismaNamespace_DoctorApplicationMaxOrderByAggregateInput as DoctorApplicationMaxOrderByAggregateInput, type prismaNamespace_DoctorApplicationMinAggregateInputType as DoctorApplicationMinAggregateInputType, type prismaNamespace_DoctorApplicationMinAggregateOutputType as DoctorApplicationMinAggregateOutputType, type prismaNamespace_DoctorApplicationMinOrderByAggregateInput as DoctorApplicationMinOrderByAggregateInput, type prismaNamespace_DoctorApplicationModel as DoctorApplicationModel, type prismaNamespace_DoctorApplicationOmit as DoctorApplicationOmit, type prismaNamespace_DoctorApplicationOrderByRelationAggregateInput as DoctorApplicationOrderByRelationAggregateInput, type prismaNamespace_DoctorApplicationOrderByWithAggregationInput as DoctorApplicationOrderByWithAggregationInput, type prismaNamespace_DoctorApplicationOrderByWithRelationInput as DoctorApplicationOrderByWithRelationInput, type prismaNamespace_DoctorApplicationScalarFieldEnum as DoctorApplicationScalarFieldEnum, type prismaNamespace_DoctorApplicationScalarWhereInput as DoctorApplicationScalarWhereInput, type prismaNamespace_DoctorApplicationScalarWhereWithAggregatesInput as DoctorApplicationScalarWhereWithAggregatesInput, type prismaNamespace_DoctorApplicationSelect as DoctorApplicationSelect, type prismaNamespace_DoctorApplicationSelectCreateManyAndReturn as DoctorApplicationSelectCreateManyAndReturn, type prismaNamespace_DoctorApplicationSelectScalar as DoctorApplicationSelectScalar, type prismaNamespace_DoctorApplicationSelectUpdateManyAndReturn as DoctorApplicationSelectUpdateManyAndReturn, type prismaNamespace_DoctorApplicationSumAggregateInputType as DoctorApplicationSumAggregateInputType, type prismaNamespace_DoctorApplicationSumAggregateOutputType as DoctorApplicationSumAggregateOutputType, type prismaNamespace_DoctorApplicationSumOrderByAggregateInput as DoctorApplicationSumOrderByAggregateInput, type prismaNamespace_DoctorApplicationUncheckedCreateInput as DoctorApplicationUncheckedCreateInput, type prismaNamespace_DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput as DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_DoctorApplicationUncheckedCreateNestedManyWithoutUserInput as DoctorApplicationUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_DoctorApplicationUncheckedCreateWithoutHospitalInput as DoctorApplicationUncheckedCreateWithoutHospitalInput, type prismaNamespace_DoctorApplicationUncheckedCreateWithoutUserInput as DoctorApplicationUncheckedCreateWithoutUserInput, type prismaNamespace_DoctorApplicationUncheckedUpdateInput as DoctorApplicationUncheckedUpdateInput, type prismaNamespace_DoctorApplicationUncheckedUpdateManyInput as DoctorApplicationUncheckedUpdateManyInput, type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutHospitalInput as DoctorApplicationUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput as DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutUserInput as DoctorApplicationUncheckedUpdateManyWithoutUserInput, type prismaNamespace_DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput as DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_DoctorApplicationUncheckedUpdateWithoutHospitalInput as DoctorApplicationUncheckedUpdateWithoutHospitalInput, type prismaNamespace_DoctorApplicationUncheckedUpdateWithoutUserInput as DoctorApplicationUncheckedUpdateWithoutUserInput, type prismaNamespace_DoctorApplicationUpdateArgs as DoctorApplicationUpdateArgs, type prismaNamespace_DoctorApplicationUpdateInput as DoctorApplicationUpdateInput, type prismaNamespace_DoctorApplicationUpdateManyAndReturnArgs as DoctorApplicationUpdateManyAndReturnArgs, type prismaNamespace_DoctorApplicationUpdateManyArgs as DoctorApplicationUpdateManyArgs, type prismaNamespace_DoctorApplicationUpdateManyMutationInput as DoctorApplicationUpdateManyMutationInput, type prismaNamespace_DoctorApplicationUpdateManyWithWhereWithoutHospitalInput as DoctorApplicationUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_DoctorApplicationUpdateManyWithWhereWithoutUserInput as DoctorApplicationUpdateManyWithWhereWithoutUserInput, type prismaNamespace_DoctorApplicationUpdateManyWithoutHospitalNestedInput as DoctorApplicationUpdateManyWithoutHospitalNestedInput, type prismaNamespace_DoctorApplicationUpdateManyWithoutUserNestedInput as DoctorApplicationUpdateManyWithoutUserNestedInput, type prismaNamespace_DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput as DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_DoctorApplicationUpdateWithWhereUniqueWithoutUserInput as DoctorApplicationUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_DoctorApplicationUpdateWithoutHospitalInput as DoctorApplicationUpdateWithoutHospitalInput, type prismaNamespace_DoctorApplicationUpdateWithoutUserInput as DoctorApplicationUpdateWithoutUserInput, type prismaNamespace_DoctorApplicationUpdatespecializationIdsInput as DoctorApplicationUpdatespecializationIdsInput, type prismaNamespace_DoctorApplicationUpsertArgs as DoctorApplicationUpsertArgs, type prismaNamespace_DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput as DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_DoctorApplicationUpsertWithWhereUniqueWithoutUserInput as DoctorApplicationUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_DoctorApplicationUserIdHospitalIdCompoundUniqueInput as DoctorApplicationUserIdHospitalIdCompoundUniqueInput, type prismaNamespace_DoctorApplicationWhereInput as DoctorApplicationWhereInput, type prismaNamespace_DoctorApplicationWhereUniqueInput as DoctorApplicationWhereUniqueInput, type prismaNamespace_DoctorAvgAggregateInputType as DoctorAvgAggregateInputType, type prismaNamespace_DoctorAvgAggregateOutputType as DoctorAvgAggregateOutputType, type prismaNamespace_DoctorAvgOrderByAggregateInput as DoctorAvgOrderByAggregateInput, type prismaNamespace_DoctorCountAggregateInputType as DoctorCountAggregateInputType, type prismaNamespace_DoctorCountAggregateOutputType as DoctorCountAggregateOutputType, type prismaNamespace_DoctorCountArgs as DoctorCountArgs, type prismaNamespace_DoctorCountOrderByAggregateInput as DoctorCountOrderByAggregateInput, type prismaNamespace_DoctorCountOutputType as DoctorCountOutputType, type prismaNamespace_DoctorCountOutputTypeCountAppointmentArgs as DoctorCountOutputTypeCountAppointmentArgs, type prismaNamespace_DoctorCountOutputTypeCountDoctorHospitalProfileArgs as DoctorCountOutputTypeCountDoctorHospitalProfileArgs, type prismaNamespace_DoctorCountOutputTypeCountDoctorSpecializationArgs as DoctorCountOutputTypeCountDoctorSpecializationArgs, type prismaNamespace_DoctorCountOutputTypeCountReviewArgs as DoctorCountOutputTypeCountReviewArgs, type prismaNamespace_DoctorCountOutputTypeCountSavedDoctorHospitalArgs as DoctorCountOutputTypeCountSavedDoctorHospitalArgs, type prismaNamespace_DoctorCountOutputTypeCountScheduleArgs as DoctorCountOutputTypeCountScheduleArgs, type prismaNamespace_DoctorCountOutputTypeDefaultArgs as DoctorCountOutputTypeDefaultArgs, type prismaNamespace_DoctorCountOutputTypeSelect as DoctorCountOutputTypeSelect, type prismaNamespace_DoctorCreateArgs as DoctorCreateArgs, type prismaNamespace_DoctorCreateInput as DoctorCreateInput, type prismaNamespace_DoctorCreateManyAndReturnArgs as DoctorCreateManyAndReturnArgs, type prismaNamespace_DoctorCreateManyArgs as DoctorCreateManyArgs, type prismaNamespace_DoctorCreateManyInput as DoctorCreateManyInput, type prismaNamespace_DoctorCreateNestedOneWithoutAppointmentInput as DoctorCreateNestedOneWithoutAppointmentInput, type prismaNamespace_DoctorCreateNestedOneWithoutDoctorHospitalProfileInput as DoctorCreateNestedOneWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorCreateNestedOneWithoutDoctorSpecializationInput as DoctorCreateNestedOneWithoutDoctorSpecializationInput, type prismaNamespace_DoctorCreateNestedOneWithoutReviewInput as DoctorCreateNestedOneWithoutReviewInput, type prismaNamespace_DoctorCreateNestedOneWithoutSavedDoctorHospitalInput as DoctorCreateNestedOneWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorCreateNestedOneWithoutScheduleInput as DoctorCreateNestedOneWithoutScheduleInput, type prismaNamespace_DoctorCreateNestedOneWithoutUserInput as DoctorCreateNestedOneWithoutUserInput, type prismaNamespace_DoctorCreateOrConnectWithoutAppointmentInput as DoctorCreateOrConnectWithoutAppointmentInput, type prismaNamespace_DoctorCreateOrConnectWithoutDoctorHospitalProfileInput as DoctorCreateOrConnectWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorCreateOrConnectWithoutDoctorSpecializationInput as DoctorCreateOrConnectWithoutDoctorSpecializationInput, type prismaNamespace_DoctorCreateOrConnectWithoutReviewInput as DoctorCreateOrConnectWithoutReviewInput, type prismaNamespace_DoctorCreateOrConnectWithoutSavedDoctorHospitalInput as DoctorCreateOrConnectWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorCreateOrConnectWithoutScheduleInput as DoctorCreateOrConnectWithoutScheduleInput, type prismaNamespace_DoctorCreateOrConnectWithoutUserInput as DoctorCreateOrConnectWithoutUserInput, type prismaNamespace_DoctorCreateWithoutAppointmentInput as DoctorCreateWithoutAppointmentInput, type prismaNamespace_DoctorCreateWithoutDoctorHospitalProfileInput as DoctorCreateWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorCreateWithoutDoctorSpecializationInput as DoctorCreateWithoutDoctorSpecializationInput, type prismaNamespace_DoctorCreateWithoutReviewInput as DoctorCreateWithoutReviewInput, type prismaNamespace_DoctorCreateWithoutSavedDoctorHospitalInput as DoctorCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorCreateWithoutScheduleInput as DoctorCreateWithoutScheduleInput, type prismaNamespace_DoctorCreateWithoutUserInput as DoctorCreateWithoutUserInput, type prismaNamespace_DoctorDefaultArgs as DoctorDefaultArgs, type prismaNamespace_DoctorDelegate as DoctorDelegate, type prismaNamespace_DoctorDeleteArgs as DoctorDeleteArgs, type prismaNamespace_DoctorDeleteManyArgs as DoctorDeleteManyArgs, type prismaNamespace_DoctorFieldRefs as DoctorFieldRefs, type prismaNamespace_DoctorFindFirstArgs as DoctorFindFirstArgs, type prismaNamespace_DoctorFindFirstOrThrowArgs as DoctorFindFirstOrThrowArgs, type prismaNamespace_DoctorFindManyArgs as DoctorFindManyArgs, type prismaNamespace_DoctorFindUniqueArgs as DoctorFindUniqueArgs, type prismaNamespace_DoctorFindUniqueOrThrowArgs as DoctorFindUniqueOrThrowArgs, type prismaNamespace_DoctorGetPayload as DoctorGetPayload, type prismaNamespace_DoctorGroupByArgs as DoctorGroupByArgs, type prismaNamespace_DoctorGroupByOutputType as DoctorGroupByOutputType, type prismaNamespace_DoctorHospitalProfileAggregateArgs as DoctorHospitalProfileAggregateArgs, type prismaNamespace_DoctorHospitalProfileAvgAggregateInputType as DoctorHospitalProfileAvgAggregateInputType, type prismaNamespace_DoctorHospitalProfileAvgAggregateOutputType as DoctorHospitalProfileAvgAggregateOutputType, type prismaNamespace_DoctorHospitalProfileAvgOrderByAggregateInput as DoctorHospitalProfileAvgOrderByAggregateInput, type prismaNamespace_DoctorHospitalProfileCountAggregateInputType as DoctorHospitalProfileCountAggregateInputType, type prismaNamespace_DoctorHospitalProfileCountAggregateOutputType as DoctorHospitalProfileCountAggregateOutputType, type prismaNamespace_DoctorHospitalProfileCountArgs as DoctorHospitalProfileCountArgs, type prismaNamespace_DoctorHospitalProfileCountOrderByAggregateInput as DoctorHospitalProfileCountOrderByAggregateInput, type prismaNamespace_DoctorHospitalProfileCreateArgs as DoctorHospitalProfileCreateArgs, type prismaNamespace_DoctorHospitalProfileCreateInput as DoctorHospitalProfileCreateInput, type prismaNamespace_DoctorHospitalProfileCreateManyAndReturnArgs as DoctorHospitalProfileCreateManyAndReturnArgs, type prismaNamespace_DoctorHospitalProfileCreateManyArgs as DoctorHospitalProfileCreateManyArgs, type prismaNamespace_DoctorHospitalProfileCreateManyDoctorInput as DoctorHospitalProfileCreateManyDoctorInput, type prismaNamespace_DoctorHospitalProfileCreateManyDoctorInputEnvelope as DoctorHospitalProfileCreateManyDoctorInputEnvelope, type prismaNamespace_DoctorHospitalProfileCreateManyHospitalInput as DoctorHospitalProfileCreateManyHospitalInput, type prismaNamespace_DoctorHospitalProfileCreateManyHospitalInputEnvelope as DoctorHospitalProfileCreateManyHospitalInputEnvelope, type prismaNamespace_DoctorHospitalProfileCreateManyInput as DoctorHospitalProfileCreateManyInput, type prismaNamespace_DoctorHospitalProfileCreateNestedManyWithoutDoctorInput as DoctorHospitalProfileCreateNestedManyWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileCreateNestedManyWithoutHospitalInput as DoctorHospitalProfileCreateNestedManyWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileCreateOrConnectWithoutDoctorInput as DoctorHospitalProfileCreateOrConnectWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileCreateOrConnectWithoutHospitalInput as DoctorHospitalProfileCreateOrConnectWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileCreateWithoutDoctorInput as DoctorHospitalProfileCreateWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileCreateWithoutHospitalInput as DoctorHospitalProfileCreateWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileDefaultArgs as DoctorHospitalProfileDefaultArgs, type prismaNamespace_DoctorHospitalProfileDelegate as DoctorHospitalProfileDelegate, type prismaNamespace_DoctorHospitalProfileDeleteArgs as DoctorHospitalProfileDeleteArgs, type prismaNamespace_DoctorHospitalProfileDeleteManyArgs as DoctorHospitalProfileDeleteManyArgs, type prismaNamespace_DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput as DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput, type prismaNamespace_DoctorHospitalProfileFieldRefs as DoctorHospitalProfileFieldRefs, type prismaNamespace_DoctorHospitalProfileFindFirstArgs as DoctorHospitalProfileFindFirstArgs, type prismaNamespace_DoctorHospitalProfileFindFirstOrThrowArgs as DoctorHospitalProfileFindFirstOrThrowArgs, type prismaNamespace_DoctorHospitalProfileFindManyArgs as DoctorHospitalProfileFindManyArgs, type prismaNamespace_DoctorHospitalProfileFindUniqueArgs as DoctorHospitalProfileFindUniqueArgs, type prismaNamespace_DoctorHospitalProfileFindUniqueOrThrowArgs as DoctorHospitalProfileFindUniqueOrThrowArgs, type prismaNamespace_DoctorHospitalProfileGetPayload as DoctorHospitalProfileGetPayload, type prismaNamespace_DoctorHospitalProfileGroupByArgs as DoctorHospitalProfileGroupByArgs, type prismaNamespace_DoctorHospitalProfileGroupByOutputType as DoctorHospitalProfileGroupByOutputType, type prismaNamespace_DoctorHospitalProfileInclude as DoctorHospitalProfileInclude, type prismaNamespace_DoctorHospitalProfileIncludeCreateManyAndReturn as DoctorHospitalProfileIncludeCreateManyAndReturn, type prismaNamespace_DoctorHospitalProfileIncludeUpdateManyAndReturn as DoctorHospitalProfileIncludeUpdateManyAndReturn, type prismaNamespace_DoctorHospitalProfileListRelationFilter as DoctorHospitalProfileListRelationFilter, type prismaNamespace_DoctorHospitalProfileMaxAggregateInputType as DoctorHospitalProfileMaxAggregateInputType, type prismaNamespace_DoctorHospitalProfileMaxAggregateOutputType as DoctorHospitalProfileMaxAggregateOutputType, type prismaNamespace_DoctorHospitalProfileMaxOrderByAggregateInput as DoctorHospitalProfileMaxOrderByAggregateInput, type prismaNamespace_DoctorHospitalProfileMinAggregateInputType as DoctorHospitalProfileMinAggregateInputType, type prismaNamespace_DoctorHospitalProfileMinAggregateOutputType as DoctorHospitalProfileMinAggregateOutputType, type prismaNamespace_DoctorHospitalProfileMinOrderByAggregateInput as DoctorHospitalProfileMinOrderByAggregateInput, type prismaNamespace_DoctorHospitalProfileModel as DoctorHospitalProfileModel, type prismaNamespace_DoctorHospitalProfileOmit as DoctorHospitalProfileOmit, type prismaNamespace_DoctorHospitalProfileOrderByRelationAggregateInput as DoctorHospitalProfileOrderByRelationAggregateInput, type prismaNamespace_DoctorHospitalProfileOrderByWithAggregationInput as DoctorHospitalProfileOrderByWithAggregationInput, type prismaNamespace_DoctorHospitalProfileOrderByWithRelationInput as DoctorHospitalProfileOrderByWithRelationInput, type prismaNamespace_DoctorHospitalProfileScalarFieldEnum as DoctorHospitalProfileScalarFieldEnum, type prismaNamespace_DoctorHospitalProfileScalarWhereInput as DoctorHospitalProfileScalarWhereInput, type prismaNamespace_DoctorHospitalProfileScalarWhereWithAggregatesInput as DoctorHospitalProfileScalarWhereWithAggregatesInput, type prismaNamespace_DoctorHospitalProfileSelect as DoctorHospitalProfileSelect, type prismaNamespace_DoctorHospitalProfileSelectCreateManyAndReturn as DoctorHospitalProfileSelectCreateManyAndReturn, type prismaNamespace_DoctorHospitalProfileSelectScalar as DoctorHospitalProfileSelectScalar, type prismaNamespace_DoctorHospitalProfileSelectUpdateManyAndReturn as DoctorHospitalProfileSelectUpdateManyAndReturn, type prismaNamespace_DoctorHospitalProfileSumAggregateInputType as DoctorHospitalProfileSumAggregateInputType, type prismaNamespace_DoctorHospitalProfileSumAggregateOutputType as DoctorHospitalProfileSumAggregateOutputType, type prismaNamespace_DoctorHospitalProfileSumOrderByAggregateInput as DoctorHospitalProfileSumOrderByAggregateInput, type prismaNamespace_DoctorHospitalProfileUncheckedCreateInput as DoctorHospitalProfileUncheckedCreateInput, type prismaNamespace_DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput as DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput as DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUncheckedCreateWithoutDoctorInput as DoctorHospitalProfileUncheckedCreateWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUncheckedCreateWithoutHospitalInput as DoctorHospitalProfileUncheckedCreateWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateInput as DoctorHospitalProfileUncheckedUpdateInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyInput as DoctorHospitalProfileUncheckedUpdateManyInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput as DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput as DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput as DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput as DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput as DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput as DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUpdateArgs as DoctorHospitalProfileUpdateArgs, type prismaNamespace_DoctorHospitalProfileUpdateInput as DoctorHospitalProfileUpdateInput, type prismaNamespace_DoctorHospitalProfileUpdateManyAndReturnArgs as DoctorHospitalProfileUpdateManyAndReturnArgs, type prismaNamespace_DoctorHospitalProfileUpdateManyArgs as DoctorHospitalProfileUpdateManyArgs, type prismaNamespace_DoctorHospitalProfileUpdateManyMutationInput as DoctorHospitalProfileUpdateManyMutationInput, type prismaNamespace_DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput as DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput as DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput as DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput, type prismaNamespace_DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput as DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput, type prismaNamespace_DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput as DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput as DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUpdateWithoutDoctorInput as DoctorHospitalProfileUpdateWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUpdateWithoutHospitalInput as DoctorHospitalProfileUpdateWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileUpsertArgs as DoctorHospitalProfileUpsertArgs, type prismaNamespace_DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput as DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput as DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_DoctorHospitalProfileWhereInput as DoctorHospitalProfileWhereInput, type prismaNamespace_DoctorHospitalProfileWhereUniqueInput as DoctorHospitalProfileWhereUniqueInput, type prismaNamespace_DoctorInclude as DoctorInclude, type prismaNamespace_DoctorIncludeCreateManyAndReturn as DoctorIncludeCreateManyAndReturn, type prismaNamespace_DoctorIncludeUpdateManyAndReturn as DoctorIncludeUpdateManyAndReturn, type prismaNamespace_DoctorMaxAggregateInputType as DoctorMaxAggregateInputType, type prismaNamespace_DoctorMaxAggregateOutputType as DoctorMaxAggregateOutputType, type prismaNamespace_DoctorMaxOrderByAggregateInput as DoctorMaxOrderByAggregateInput, type prismaNamespace_DoctorMinAggregateInputType as DoctorMinAggregateInputType, type prismaNamespace_DoctorMinAggregateOutputType as DoctorMinAggregateOutputType, type prismaNamespace_DoctorMinOrderByAggregateInput as DoctorMinOrderByAggregateInput, type prismaNamespace_DoctorModel as DoctorModel, type prismaNamespace_DoctorNullableScalarRelationFilter as DoctorNullableScalarRelationFilter, type prismaNamespace_DoctorOmit as DoctorOmit, type prismaNamespace_DoctorOrderByWithAggregationInput as DoctorOrderByWithAggregationInput, type prismaNamespace_DoctorOrderByWithRelationInput as DoctorOrderByWithRelationInput, type prismaNamespace_DoctorScalarFieldEnum as DoctorScalarFieldEnum, type prismaNamespace_DoctorScalarRelationFilter as DoctorScalarRelationFilter, type prismaNamespace_DoctorScalarWhereWithAggregatesInput as DoctorScalarWhereWithAggregatesInput, type prismaNamespace_DoctorSelect as DoctorSelect, type prismaNamespace_DoctorSelectCreateManyAndReturn as DoctorSelectCreateManyAndReturn, type prismaNamespace_DoctorSelectScalar as DoctorSelectScalar, type prismaNamespace_DoctorSelectUpdateManyAndReturn as DoctorSelectUpdateManyAndReturn, type prismaNamespace_DoctorSpecializationAggregateArgs as DoctorSpecializationAggregateArgs, type prismaNamespace_DoctorSpecializationCountAggregateInputType as DoctorSpecializationCountAggregateInputType, type prismaNamespace_DoctorSpecializationCountAggregateOutputType as DoctorSpecializationCountAggregateOutputType, type prismaNamespace_DoctorSpecializationCountArgs as DoctorSpecializationCountArgs, type prismaNamespace_DoctorSpecializationCountOrderByAggregateInput as DoctorSpecializationCountOrderByAggregateInput, type prismaNamespace_DoctorSpecializationCreateArgs as DoctorSpecializationCreateArgs, type prismaNamespace_DoctorSpecializationCreateInput as DoctorSpecializationCreateInput, type prismaNamespace_DoctorSpecializationCreateManyAndReturnArgs as DoctorSpecializationCreateManyAndReturnArgs, type prismaNamespace_DoctorSpecializationCreateManyArgs as DoctorSpecializationCreateManyArgs, type prismaNamespace_DoctorSpecializationCreateManyDoctorInput as DoctorSpecializationCreateManyDoctorInput, type prismaNamespace_DoctorSpecializationCreateManyDoctorInputEnvelope as DoctorSpecializationCreateManyDoctorInputEnvelope, type prismaNamespace_DoctorSpecializationCreateManyInput as DoctorSpecializationCreateManyInput, type prismaNamespace_DoctorSpecializationCreateManySpecializationInput as DoctorSpecializationCreateManySpecializationInput, type prismaNamespace_DoctorSpecializationCreateManySpecializationInputEnvelope as DoctorSpecializationCreateManySpecializationInputEnvelope, type prismaNamespace_DoctorSpecializationCreateNestedManyWithoutDoctorInput as DoctorSpecializationCreateNestedManyWithoutDoctorInput, type prismaNamespace_DoctorSpecializationCreateNestedManyWithoutSpecializationInput as DoctorSpecializationCreateNestedManyWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationCreateOrConnectWithoutDoctorInput as DoctorSpecializationCreateOrConnectWithoutDoctorInput, type prismaNamespace_DoctorSpecializationCreateOrConnectWithoutSpecializationInput as DoctorSpecializationCreateOrConnectWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationCreateWithoutDoctorInput as DoctorSpecializationCreateWithoutDoctorInput, type prismaNamespace_DoctorSpecializationCreateWithoutSpecializationInput as DoctorSpecializationCreateWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationDefaultArgs as DoctorSpecializationDefaultArgs, type prismaNamespace_DoctorSpecializationDelegate as DoctorSpecializationDelegate, type prismaNamespace_DoctorSpecializationDeleteArgs as DoctorSpecializationDeleteArgs, type prismaNamespace_DoctorSpecializationDeleteManyArgs as DoctorSpecializationDeleteManyArgs, type prismaNamespace_DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput as DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput, type prismaNamespace_DoctorSpecializationFieldRefs as DoctorSpecializationFieldRefs, type prismaNamespace_DoctorSpecializationFindFirstArgs as DoctorSpecializationFindFirstArgs, type prismaNamespace_DoctorSpecializationFindFirstOrThrowArgs as DoctorSpecializationFindFirstOrThrowArgs, type prismaNamespace_DoctorSpecializationFindManyArgs as DoctorSpecializationFindManyArgs, type prismaNamespace_DoctorSpecializationFindUniqueArgs as DoctorSpecializationFindUniqueArgs, type prismaNamespace_DoctorSpecializationFindUniqueOrThrowArgs as DoctorSpecializationFindUniqueOrThrowArgs, type prismaNamespace_DoctorSpecializationGetPayload as DoctorSpecializationGetPayload, type prismaNamespace_DoctorSpecializationGroupByArgs as DoctorSpecializationGroupByArgs, type prismaNamespace_DoctorSpecializationGroupByOutputType as DoctorSpecializationGroupByOutputType, type prismaNamespace_DoctorSpecializationInclude as DoctorSpecializationInclude, type prismaNamespace_DoctorSpecializationIncludeCreateManyAndReturn as DoctorSpecializationIncludeCreateManyAndReturn, type prismaNamespace_DoctorSpecializationIncludeUpdateManyAndReturn as DoctorSpecializationIncludeUpdateManyAndReturn, type prismaNamespace_DoctorSpecializationListRelationFilter as DoctorSpecializationListRelationFilter, type prismaNamespace_DoctorSpecializationMaxAggregateInputType as DoctorSpecializationMaxAggregateInputType, type prismaNamespace_DoctorSpecializationMaxAggregateOutputType as DoctorSpecializationMaxAggregateOutputType, type prismaNamespace_DoctorSpecializationMaxOrderByAggregateInput as DoctorSpecializationMaxOrderByAggregateInput, type prismaNamespace_DoctorSpecializationMinAggregateInputType as DoctorSpecializationMinAggregateInputType, type prismaNamespace_DoctorSpecializationMinAggregateOutputType as DoctorSpecializationMinAggregateOutputType, type prismaNamespace_DoctorSpecializationMinOrderByAggregateInput as DoctorSpecializationMinOrderByAggregateInput, type prismaNamespace_DoctorSpecializationModel as DoctorSpecializationModel, type prismaNamespace_DoctorSpecializationOmit as DoctorSpecializationOmit, type prismaNamespace_DoctorSpecializationOrderByRelationAggregateInput as DoctorSpecializationOrderByRelationAggregateInput, type prismaNamespace_DoctorSpecializationOrderByWithAggregationInput as DoctorSpecializationOrderByWithAggregationInput, type prismaNamespace_DoctorSpecializationOrderByWithRelationInput as DoctorSpecializationOrderByWithRelationInput, type prismaNamespace_DoctorSpecializationScalarFieldEnum as DoctorSpecializationScalarFieldEnum, type prismaNamespace_DoctorSpecializationScalarWhereInput as DoctorSpecializationScalarWhereInput, type prismaNamespace_DoctorSpecializationScalarWhereWithAggregatesInput as DoctorSpecializationScalarWhereWithAggregatesInput, type prismaNamespace_DoctorSpecializationSelect as DoctorSpecializationSelect, type prismaNamespace_DoctorSpecializationSelectCreateManyAndReturn as DoctorSpecializationSelectCreateManyAndReturn, type prismaNamespace_DoctorSpecializationSelectScalar as DoctorSpecializationSelectScalar, type prismaNamespace_DoctorSpecializationSelectUpdateManyAndReturn as DoctorSpecializationSelectUpdateManyAndReturn, type prismaNamespace_DoctorSpecializationUncheckedCreateInput as DoctorSpecializationUncheckedCreateInput, type prismaNamespace_DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput as DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput as DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUncheckedCreateWithoutDoctorInput as DoctorSpecializationUncheckedCreateWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUncheckedCreateWithoutSpecializationInput as DoctorSpecializationUncheckedCreateWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateInput as DoctorSpecializationUncheckedUpdateInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateManyInput as DoctorSpecializationUncheckedUpdateManyInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput as DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput as DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput as DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput as DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateWithoutDoctorInput as DoctorSpecializationUncheckedUpdateWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUncheckedUpdateWithoutSpecializationInput as DoctorSpecializationUncheckedUpdateWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUpdateArgs as DoctorSpecializationUpdateArgs, type prismaNamespace_DoctorSpecializationUpdateInput as DoctorSpecializationUpdateInput, type prismaNamespace_DoctorSpecializationUpdateManyAndReturnArgs as DoctorSpecializationUpdateManyAndReturnArgs, type prismaNamespace_DoctorSpecializationUpdateManyArgs as DoctorSpecializationUpdateManyArgs, type prismaNamespace_DoctorSpecializationUpdateManyMutationInput as DoctorSpecializationUpdateManyMutationInput, type prismaNamespace_DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput as DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput as DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUpdateManyWithoutDoctorNestedInput as DoctorSpecializationUpdateManyWithoutDoctorNestedInput, type prismaNamespace_DoctorSpecializationUpdateManyWithoutSpecializationNestedInput as DoctorSpecializationUpdateManyWithoutSpecializationNestedInput, type prismaNamespace_DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput as DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput as DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUpdateWithoutDoctorInput as DoctorSpecializationUpdateWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUpdateWithoutSpecializationInput as DoctorSpecializationUpdateWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationUpsertArgs as DoctorSpecializationUpsertArgs, type prismaNamespace_DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput as DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput as DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput, type prismaNamespace_DoctorSpecializationWhereInput as DoctorSpecializationWhereInput, type prismaNamespace_DoctorSpecializationWhereUniqueInput as DoctorSpecializationWhereUniqueInput, type prismaNamespace_DoctorSumAggregateInputType as DoctorSumAggregateInputType, type prismaNamespace_DoctorSumAggregateOutputType as DoctorSumAggregateOutputType, type prismaNamespace_DoctorSumOrderByAggregateInput as DoctorSumOrderByAggregateInput, type prismaNamespace_DoctorUncheckedCreateInput as DoctorUncheckedCreateInput, type prismaNamespace_DoctorUncheckedCreateNestedOneWithoutUserInput as DoctorUncheckedCreateNestedOneWithoutUserInput, type prismaNamespace_DoctorUncheckedCreateWithoutAppointmentInput as DoctorUncheckedCreateWithoutAppointmentInput, type prismaNamespace_DoctorUncheckedCreateWithoutDoctorHospitalProfileInput as DoctorUncheckedCreateWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorUncheckedCreateWithoutDoctorSpecializationInput as DoctorUncheckedCreateWithoutDoctorSpecializationInput, type prismaNamespace_DoctorUncheckedCreateWithoutReviewInput as DoctorUncheckedCreateWithoutReviewInput, type prismaNamespace_DoctorUncheckedCreateWithoutSavedDoctorHospitalInput as DoctorUncheckedCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorUncheckedCreateWithoutScheduleInput as DoctorUncheckedCreateWithoutScheduleInput, type prismaNamespace_DoctorUncheckedCreateWithoutUserInput as DoctorUncheckedCreateWithoutUserInput, type prismaNamespace_DoctorUncheckedUpdateInput as DoctorUncheckedUpdateInput, type prismaNamespace_DoctorUncheckedUpdateManyInput as DoctorUncheckedUpdateManyInput, type prismaNamespace_DoctorUncheckedUpdateOneWithoutUserNestedInput as DoctorUncheckedUpdateOneWithoutUserNestedInput, type prismaNamespace_DoctorUncheckedUpdateWithoutAppointmentInput as DoctorUncheckedUpdateWithoutAppointmentInput, type prismaNamespace_DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput as DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorUncheckedUpdateWithoutDoctorSpecializationInput as DoctorUncheckedUpdateWithoutDoctorSpecializationInput, type prismaNamespace_DoctorUncheckedUpdateWithoutReviewInput as DoctorUncheckedUpdateWithoutReviewInput, type prismaNamespace_DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput as DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorUncheckedUpdateWithoutScheduleInput as DoctorUncheckedUpdateWithoutScheduleInput, type prismaNamespace_DoctorUncheckedUpdateWithoutUserInput as DoctorUncheckedUpdateWithoutUserInput, type prismaNamespace_DoctorUpdateArgs as DoctorUpdateArgs, type prismaNamespace_DoctorUpdateInput as DoctorUpdateInput, type prismaNamespace_DoctorUpdateManyAndReturnArgs as DoctorUpdateManyAndReturnArgs, type prismaNamespace_DoctorUpdateManyArgs as DoctorUpdateManyArgs, type prismaNamespace_DoctorUpdateManyMutationInput as DoctorUpdateManyMutationInput, type prismaNamespace_DoctorUpdateOneRequiredWithoutAppointmentNestedInput as DoctorUpdateOneRequiredWithoutAppointmentNestedInput, type prismaNamespace_DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput as DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput, type prismaNamespace_DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput as DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput, type prismaNamespace_DoctorUpdateOneRequiredWithoutScheduleNestedInput as DoctorUpdateOneRequiredWithoutScheduleNestedInput, type prismaNamespace_DoctorUpdateOneWithoutReviewNestedInput as DoctorUpdateOneWithoutReviewNestedInput, type prismaNamespace_DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput as DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput, type prismaNamespace_DoctorUpdateOneWithoutUserNestedInput as DoctorUpdateOneWithoutUserNestedInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutAppointmentInput as DoctorUpdateToOneWithWhereWithoutAppointmentInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput as DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput as DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutReviewInput as DoctorUpdateToOneWithWhereWithoutReviewInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutScheduleInput as DoctorUpdateToOneWithWhereWithoutScheduleInput, type prismaNamespace_DoctorUpdateToOneWithWhereWithoutUserInput as DoctorUpdateToOneWithWhereWithoutUserInput, type prismaNamespace_DoctorUpdateWithoutAppointmentInput as DoctorUpdateWithoutAppointmentInput, type prismaNamespace_DoctorUpdateWithoutDoctorHospitalProfileInput as DoctorUpdateWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorUpdateWithoutDoctorSpecializationInput as DoctorUpdateWithoutDoctorSpecializationInput, type prismaNamespace_DoctorUpdateWithoutReviewInput as DoctorUpdateWithoutReviewInput, type prismaNamespace_DoctorUpdateWithoutSavedDoctorHospitalInput as DoctorUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorUpdateWithoutScheduleInput as DoctorUpdateWithoutScheduleInput, type prismaNamespace_DoctorUpdateWithoutUserInput as DoctorUpdateWithoutUserInput, type prismaNamespace_DoctorUpsertArgs as DoctorUpsertArgs, type prismaNamespace_DoctorUpsertWithoutAppointmentInput as DoctorUpsertWithoutAppointmentInput, type prismaNamespace_DoctorUpsertWithoutDoctorHospitalProfileInput as DoctorUpsertWithoutDoctorHospitalProfileInput, type prismaNamespace_DoctorUpsertWithoutDoctorSpecializationInput as DoctorUpsertWithoutDoctorSpecializationInput, type prismaNamespace_DoctorUpsertWithoutReviewInput as DoctorUpsertWithoutReviewInput, type prismaNamespace_DoctorUpsertWithoutSavedDoctorHospitalInput as DoctorUpsertWithoutSavedDoctorHospitalInput, type prismaNamespace_DoctorUpsertWithoutScheduleInput as DoctorUpsertWithoutScheduleInput, type prismaNamespace_DoctorUpsertWithoutUserInput as DoctorUpsertWithoutUserInput, type prismaNamespace_DoctorWhereInput as DoctorWhereInput, type prismaNamespace_DoctorWhereUniqueInput as DoctorWhereUniqueInput, type prismaNamespace_Either as Either, type prismaNamespace_EnumAppointmentStatusFieldRefInput as EnumAppointmentStatusFieldRefInput, type prismaNamespace_EnumAppointmentStatusFieldUpdateOperationsInput as EnumAppointmentStatusFieldUpdateOperationsInput, type prismaNamespace_EnumAppointmentStatusFilter as EnumAppointmentStatusFilter, type prismaNamespace_EnumAppointmentStatusWithAggregatesFilter as EnumAppointmentStatusWithAggregatesFilter, type prismaNamespace_EnumDoctorApplicationStatusFieldRefInput as EnumDoctorApplicationStatusFieldRefInput, type prismaNamespace_EnumDoctorApplicationStatusFieldUpdateOperationsInput as EnumDoctorApplicationStatusFieldUpdateOperationsInput, type prismaNamespace_EnumDoctorApplicationStatusFilter as EnumDoctorApplicationStatusFilter, type prismaNamespace_EnumDoctorApplicationStatusWithAggregatesFilter as EnumDoctorApplicationStatusWithAggregatesFilter, type prismaNamespace_EnumDoctorTypeFieldRefInput as EnumDoctorTypeFieldRefInput, type prismaNamespace_EnumDoctorTypeFieldUpdateOperationsInput as EnumDoctorTypeFieldUpdateOperationsInput, type prismaNamespace_EnumDoctorTypeFilter as EnumDoctorTypeFilter, type prismaNamespace_EnumDoctorTypeWithAggregatesFilter as EnumDoctorTypeWithAggregatesFilter, type prismaNamespace_EnumHospitalTypeFieldRefInput as EnumHospitalTypeFieldRefInput, type prismaNamespace_EnumHospitalTypeFieldUpdateOperationsInput as EnumHospitalTypeFieldUpdateOperationsInput, type prismaNamespace_EnumHospitalTypeFilter as EnumHospitalTypeFilter, type prismaNamespace_EnumHospitalTypeWithAggregatesFilter as EnumHospitalTypeWithAggregatesFilter, type prismaNamespace_EnumQueryModeFieldRefInput as EnumQueryModeFieldRefInput, type prismaNamespace_EnumRoleFieldRefInput as EnumRoleFieldRefInput, type prismaNamespace_EnumRoleNullableFilter as EnumRoleNullableFilter, type prismaNamespace_EnumRoleNullableWithAggregatesFilter as EnumRoleNullableWithAggregatesFilter, type prismaNamespace_EnumSchedulePeriodFieldRefInput as EnumSchedulePeriodFieldRefInput, type prismaNamespace_EnumSchedulePeriodFieldUpdateOperationsInput as EnumSchedulePeriodFieldUpdateOperationsInput, type prismaNamespace_EnumSchedulePeriodFilter as EnumSchedulePeriodFilter, type prismaNamespace_EnumSchedulePeriodWithAggregatesFilter as EnumSchedulePeriodWithAggregatesFilter, type prismaNamespace_EnumScheduleStatusFieldRefInput as EnumScheduleStatusFieldRefInput, type prismaNamespace_EnumScheduleStatusFieldUpdateOperationsInput as EnumScheduleStatusFieldUpdateOperationsInput, type prismaNamespace_EnumScheduleStatusFilter as EnumScheduleStatusFilter, type prismaNamespace_EnumScheduleStatusWithAggregatesFilter as EnumScheduleStatusWithAggregatesFilter, type prismaNamespace_EnumScheduleTypeFieldRefInput as EnumScheduleTypeFieldRefInput, type prismaNamespace_EnumScheduleTypeFieldUpdateOperationsInput as EnumScheduleTypeFieldUpdateOperationsInput, type prismaNamespace_EnumScheduleTypeFilter as EnumScheduleTypeFilter, type prismaNamespace_EnumScheduleTypeWithAggregatesFilter as EnumScheduleTypeWithAggregatesFilter, type prismaNamespace_EnumSlotStatusFieldRefInput as EnumSlotStatusFieldRefInput, type prismaNamespace_EnumSlotStatusFieldUpdateOperationsInput as EnumSlotStatusFieldUpdateOperationsInput, type prismaNamespace_EnumSlotStatusFilter as EnumSlotStatusFilter, type prismaNamespace_EnumSlotStatusWithAggregatesFilter as EnumSlotStatusWithAggregatesFilter, type prismaNamespace_Enumerable as Enumerable, type prismaNamespace_ErrorFormat as ErrorFormat, type prismaNamespace_Exact as Exact, type prismaNamespace_ExcludeUnderscoreKeys as ExcludeUnderscoreKeys, type prismaNamespace_Extends as Extends, type prismaNamespace_Extension as Extension, type prismaNamespace_False as False, type prismaNamespace_FieldRef as FieldRef, type prismaNamespace_FloatFieldRefInput as FloatFieldRefInput, type prismaNamespace_GetAccountAggregateType as GetAccountAggregateType, type prismaNamespace_GetAppointmentAggregateType as GetAppointmentAggregateType, type prismaNamespace_GetAuditLogAggregateType as GetAuditLogAggregateType, type prismaNamespace_GetDoctorAggregateType as GetDoctorAggregateType, type prismaNamespace_GetDoctorApplicationAggregateType as GetDoctorApplicationAggregateType, type prismaNamespace_GetDoctorHospitalProfileAggregateType as GetDoctorHospitalProfileAggregateType, type prismaNamespace_GetDoctorSpecializationAggregateType as GetDoctorSpecializationAggregateType, type prismaNamespace_GetEvents as GetEvents, type prismaNamespace_GetHavingFields as GetHavingFields, type prismaNamespace_GetHospitalAggregateType as GetHospitalAggregateType, type prismaNamespace_GetHospitalSpecializationAggregateType as GetHospitalSpecializationAggregateType, type prismaNamespace_GetLogType as GetLogType, type prismaNamespace_GetNotificationAggregateType as GetNotificationAggregateType, type prismaNamespace_GetPaymentAggregateType as GetPaymentAggregateType, type prismaNamespace_GetReviewAggregateType as GetReviewAggregateType, type prismaNamespace_GetSavedDoctorHospitalAggregateType as GetSavedDoctorHospitalAggregateType, type prismaNamespace_GetScalarType as GetScalarType, type prismaNamespace_GetScheduleAggregateType as GetScheduleAggregateType, type prismaNamespace_GetSearchLogAggregateType as GetSearchLogAggregateType, type prismaNamespace_GetSessionAggregateType as GetSessionAggregateType, type prismaNamespace_GetSlotAggregateType as GetSlotAggregateType, type prismaNamespace_GetSpecializationAggregateType as GetSpecializationAggregateType, type prismaNamespace_GetUserAggregateType as GetUserAggregateType, type prismaNamespace_GetVerificationAggregateType as GetVerificationAggregateType, type prismaNamespace_GlobalOmitConfig as GlobalOmitConfig, type prismaNamespace_Has as Has, type prismaNamespace_Hospital$AppointmentArgs as Hospital$AppointmentArgs, type prismaNamespace_Hospital$DoctorApplicationArgs as Hospital$DoctorApplicationArgs, type prismaNamespace_Hospital$DoctorHospitalProfileArgs as Hospital$DoctorHospitalProfileArgs, type prismaNamespace_Hospital$HospitalSpecializationArgs as Hospital$HospitalSpecializationArgs, type prismaNamespace_Hospital$ReviewArgs as Hospital$ReviewArgs, type prismaNamespace_Hospital$SavedDoctorHospitalArgs as Hospital$SavedDoctorHospitalArgs, type prismaNamespace_Hospital$ScheduleArgs as Hospital$ScheduleArgs, type prismaNamespace_HospitalAggregateArgs as HospitalAggregateArgs, type prismaNamespace_HospitalAvgAggregateInputType as HospitalAvgAggregateInputType, type prismaNamespace_HospitalAvgAggregateOutputType as HospitalAvgAggregateOutputType, type prismaNamespace_HospitalAvgOrderByAggregateInput as HospitalAvgOrderByAggregateInput, type prismaNamespace_HospitalCountAggregateInputType as HospitalCountAggregateInputType, type prismaNamespace_HospitalCountAggregateOutputType as HospitalCountAggregateOutputType, type prismaNamespace_HospitalCountArgs as HospitalCountArgs, type prismaNamespace_HospitalCountOrderByAggregateInput as HospitalCountOrderByAggregateInput, type prismaNamespace_HospitalCountOutputType as HospitalCountOutputType, type prismaNamespace_HospitalCountOutputTypeCountAppointmentArgs as HospitalCountOutputTypeCountAppointmentArgs, type prismaNamespace_HospitalCountOutputTypeCountDoctorApplicationArgs as HospitalCountOutputTypeCountDoctorApplicationArgs, type prismaNamespace_HospitalCountOutputTypeCountDoctorHospitalProfileArgs as HospitalCountOutputTypeCountDoctorHospitalProfileArgs, type prismaNamespace_HospitalCountOutputTypeCountHospitalSpecializationArgs as HospitalCountOutputTypeCountHospitalSpecializationArgs, type prismaNamespace_HospitalCountOutputTypeCountReviewArgs as HospitalCountOutputTypeCountReviewArgs, type prismaNamespace_HospitalCountOutputTypeCountSavedDoctorHospitalArgs as HospitalCountOutputTypeCountSavedDoctorHospitalArgs, type prismaNamespace_HospitalCountOutputTypeCountScheduleArgs as HospitalCountOutputTypeCountScheduleArgs, type prismaNamespace_HospitalCountOutputTypeDefaultArgs as HospitalCountOutputTypeDefaultArgs, type prismaNamespace_HospitalCountOutputTypeSelect as HospitalCountOutputTypeSelect, type prismaNamespace_HospitalCreateArgs as HospitalCreateArgs, type prismaNamespace_HospitalCreateInput as HospitalCreateInput, type prismaNamespace_HospitalCreateManyAndReturnArgs as HospitalCreateManyAndReturnArgs, type prismaNamespace_HospitalCreateManyArgs as HospitalCreateManyArgs, type prismaNamespace_HospitalCreateManyInput as HospitalCreateManyInput, type prismaNamespace_HospitalCreateNestedOneWithoutAppointmentInput as HospitalCreateNestedOneWithoutAppointmentInput, type prismaNamespace_HospitalCreateNestedOneWithoutDoctorApplicationInput as HospitalCreateNestedOneWithoutDoctorApplicationInput, type prismaNamespace_HospitalCreateNestedOneWithoutDoctorHospitalProfileInput as HospitalCreateNestedOneWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalCreateNestedOneWithoutHospitalSpecializationInput as HospitalCreateNestedOneWithoutHospitalSpecializationInput, type prismaNamespace_HospitalCreateNestedOneWithoutReviewInput as HospitalCreateNestedOneWithoutReviewInput, type prismaNamespace_HospitalCreateNestedOneWithoutSavedDoctorHospitalInput as HospitalCreateNestedOneWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalCreateNestedOneWithoutScheduleInput as HospitalCreateNestedOneWithoutScheduleInput, type prismaNamespace_HospitalCreateNestedOneWithoutUserInput as HospitalCreateNestedOneWithoutUserInput, type prismaNamespace_HospitalCreateOrConnectWithoutAppointmentInput as HospitalCreateOrConnectWithoutAppointmentInput, type prismaNamespace_HospitalCreateOrConnectWithoutDoctorApplicationInput as HospitalCreateOrConnectWithoutDoctorApplicationInput, type prismaNamespace_HospitalCreateOrConnectWithoutDoctorHospitalProfileInput as HospitalCreateOrConnectWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalCreateOrConnectWithoutHospitalSpecializationInput as HospitalCreateOrConnectWithoutHospitalSpecializationInput, type prismaNamespace_HospitalCreateOrConnectWithoutReviewInput as HospitalCreateOrConnectWithoutReviewInput, type prismaNamespace_HospitalCreateOrConnectWithoutSavedDoctorHospitalInput as HospitalCreateOrConnectWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalCreateOrConnectWithoutScheduleInput as HospitalCreateOrConnectWithoutScheduleInput, type prismaNamespace_HospitalCreateOrConnectWithoutUserInput as HospitalCreateOrConnectWithoutUserInput, type prismaNamespace_HospitalCreateWithoutAppointmentInput as HospitalCreateWithoutAppointmentInput, type prismaNamespace_HospitalCreateWithoutDoctorApplicationInput as HospitalCreateWithoutDoctorApplicationInput, type prismaNamespace_HospitalCreateWithoutDoctorHospitalProfileInput as HospitalCreateWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalCreateWithoutHospitalSpecializationInput as HospitalCreateWithoutHospitalSpecializationInput, type prismaNamespace_HospitalCreateWithoutReviewInput as HospitalCreateWithoutReviewInput, type prismaNamespace_HospitalCreateWithoutSavedDoctorHospitalInput as HospitalCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalCreateWithoutScheduleInput as HospitalCreateWithoutScheduleInput, type prismaNamespace_HospitalCreateWithoutUserInput as HospitalCreateWithoutUserInput, type prismaNamespace_HospitalDefaultArgs as HospitalDefaultArgs, type prismaNamespace_HospitalDelegate as HospitalDelegate, type prismaNamespace_HospitalDeleteArgs as HospitalDeleteArgs, type prismaNamespace_HospitalDeleteManyArgs as HospitalDeleteManyArgs, type prismaNamespace_HospitalFieldRefs as HospitalFieldRefs, type prismaNamespace_HospitalFindFirstArgs as HospitalFindFirstArgs, type prismaNamespace_HospitalFindFirstOrThrowArgs as HospitalFindFirstOrThrowArgs, type prismaNamespace_HospitalFindManyArgs as HospitalFindManyArgs, type prismaNamespace_HospitalFindUniqueArgs as HospitalFindUniqueArgs, type prismaNamespace_HospitalFindUniqueOrThrowArgs as HospitalFindUniqueOrThrowArgs, type prismaNamespace_HospitalGetPayload as HospitalGetPayload, type prismaNamespace_HospitalGroupByArgs as HospitalGroupByArgs, type prismaNamespace_HospitalGroupByOutputType as HospitalGroupByOutputType, type prismaNamespace_HospitalInclude as HospitalInclude, type prismaNamespace_HospitalIncludeCreateManyAndReturn as HospitalIncludeCreateManyAndReturn, type prismaNamespace_HospitalIncludeUpdateManyAndReturn as HospitalIncludeUpdateManyAndReturn, type prismaNamespace_HospitalMaxAggregateInputType as HospitalMaxAggregateInputType, type prismaNamespace_HospitalMaxAggregateOutputType as HospitalMaxAggregateOutputType, type prismaNamespace_HospitalMaxOrderByAggregateInput as HospitalMaxOrderByAggregateInput, type prismaNamespace_HospitalMinAggregateInputType as HospitalMinAggregateInputType, type prismaNamespace_HospitalMinAggregateOutputType as HospitalMinAggregateOutputType, type prismaNamespace_HospitalMinOrderByAggregateInput as HospitalMinOrderByAggregateInput, type prismaNamespace_HospitalModel as HospitalModel, type prismaNamespace_HospitalNullableScalarRelationFilter as HospitalNullableScalarRelationFilter, type prismaNamespace_HospitalOmit as HospitalOmit, type prismaNamespace_HospitalOrderByWithAggregationInput as HospitalOrderByWithAggregationInput, type prismaNamespace_HospitalOrderByWithRelationInput as HospitalOrderByWithRelationInput, type prismaNamespace_HospitalScalarFieldEnum as HospitalScalarFieldEnum, type prismaNamespace_HospitalScalarRelationFilter as HospitalScalarRelationFilter, type prismaNamespace_HospitalScalarWhereWithAggregatesInput as HospitalScalarWhereWithAggregatesInput, type prismaNamespace_HospitalSelect as HospitalSelect, type prismaNamespace_HospitalSelectCreateManyAndReturn as HospitalSelectCreateManyAndReturn, type prismaNamespace_HospitalSelectScalar as HospitalSelectScalar, type prismaNamespace_HospitalSelectUpdateManyAndReturn as HospitalSelectUpdateManyAndReturn, type prismaNamespace_HospitalSpecializationAggregateArgs as HospitalSpecializationAggregateArgs, type prismaNamespace_HospitalSpecializationCountAggregateInputType as HospitalSpecializationCountAggregateInputType, type prismaNamespace_HospitalSpecializationCountAggregateOutputType as HospitalSpecializationCountAggregateOutputType, type prismaNamespace_HospitalSpecializationCountArgs as HospitalSpecializationCountArgs, type prismaNamespace_HospitalSpecializationCountOrderByAggregateInput as HospitalSpecializationCountOrderByAggregateInput, type prismaNamespace_HospitalSpecializationCreateArgs as HospitalSpecializationCreateArgs, type prismaNamespace_HospitalSpecializationCreateInput as HospitalSpecializationCreateInput, type prismaNamespace_HospitalSpecializationCreateManyAndReturnArgs as HospitalSpecializationCreateManyAndReturnArgs, type prismaNamespace_HospitalSpecializationCreateManyArgs as HospitalSpecializationCreateManyArgs, type prismaNamespace_HospitalSpecializationCreateManyHospitalInput as HospitalSpecializationCreateManyHospitalInput, type prismaNamespace_HospitalSpecializationCreateManyHospitalInputEnvelope as HospitalSpecializationCreateManyHospitalInputEnvelope, type prismaNamespace_HospitalSpecializationCreateManyInput as HospitalSpecializationCreateManyInput, type prismaNamespace_HospitalSpecializationCreateManySpecializationInput as HospitalSpecializationCreateManySpecializationInput, type prismaNamespace_HospitalSpecializationCreateManySpecializationInputEnvelope as HospitalSpecializationCreateManySpecializationInputEnvelope, type prismaNamespace_HospitalSpecializationCreateNestedManyWithoutHospitalInput as HospitalSpecializationCreateNestedManyWithoutHospitalInput, type prismaNamespace_HospitalSpecializationCreateNestedManyWithoutSpecializationInput as HospitalSpecializationCreateNestedManyWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationCreateOrConnectWithoutHospitalInput as HospitalSpecializationCreateOrConnectWithoutHospitalInput, type prismaNamespace_HospitalSpecializationCreateOrConnectWithoutSpecializationInput as HospitalSpecializationCreateOrConnectWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationCreateWithoutHospitalInput as HospitalSpecializationCreateWithoutHospitalInput, type prismaNamespace_HospitalSpecializationCreateWithoutSpecializationInput as HospitalSpecializationCreateWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationDefaultArgs as HospitalSpecializationDefaultArgs, type prismaNamespace_HospitalSpecializationDelegate as HospitalSpecializationDelegate, type prismaNamespace_HospitalSpecializationDeleteArgs as HospitalSpecializationDeleteArgs, type prismaNamespace_HospitalSpecializationDeleteManyArgs as HospitalSpecializationDeleteManyArgs, type prismaNamespace_HospitalSpecializationFieldRefs as HospitalSpecializationFieldRefs, type prismaNamespace_HospitalSpecializationFindFirstArgs as HospitalSpecializationFindFirstArgs, type prismaNamespace_HospitalSpecializationFindFirstOrThrowArgs as HospitalSpecializationFindFirstOrThrowArgs, type prismaNamespace_HospitalSpecializationFindManyArgs as HospitalSpecializationFindManyArgs, type prismaNamespace_HospitalSpecializationFindUniqueArgs as HospitalSpecializationFindUniqueArgs, type prismaNamespace_HospitalSpecializationFindUniqueOrThrowArgs as HospitalSpecializationFindUniqueOrThrowArgs, type prismaNamespace_HospitalSpecializationGetPayload as HospitalSpecializationGetPayload, type prismaNamespace_HospitalSpecializationGroupByArgs as HospitalSpecializationGroupByArgs, type prismaNamespace_HospitalSpecializationGroupByOutputType as HospitalSpecializationGroupByOutputType, type prismaNamespace_HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput as HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput, type prismaNamespace_HospitalSpecializationInclude as HospitalSpecializationInclude, type prismaNamespace_HospitalSpecializationIncludeCreateManyAndReturn as HospitalSpecializationIncludeCreateManyAndReturn, type prismaNamespace_HospitalSpecializationIncludeUpdateManyAndReturn as HospitalSpecializationIncludeUpdateManyAndReturn, type prismaNamespace_HospitalSpecializationListRelationFilter as HospitalSpecializationListRelationFilter, type prismaNamespace_HospitalSpecializationMaxAggregateInputType as HospitalSpecializationMaxAggregateInputType, type prismaNamespace_HospitalSpecializationMaxAggregateOutputType as HospitalSpecializationMaxAggregateOutputType, type prismaNamespace_HospitalSpecializationMaxOrderByAggregateInput as HospitalSpecializationMaxOrderByAggregateInput, type prismaNamespace_HospitalSpecializationMinAggregateInputType as HospitalSpecializationMinAggregateInputType, type prismaNamespace_HospitalSpecializationMinAggregateOutputType as HospitalSpecializationMinAggregateOutputType, type prismaNamespace_HospitalSpecializationMinOrderByAggregateInput as HospitalSpecializationMinOrderByAggregateInput, type prismaNamespace_HospitalSpecializationModel as HospitalSpecializationModel, type prismaNamespace_HospitalSpecializationOmit as HospitalSpecializationOmit, type prismaNamespace_HospitalSpecializationOrderByRelationAggregateInput as HospitalSpecializationOrderByRelationAggregateInput, type prismaNamespace_HospitalSpecializationOrderByWithAggregationInput as HospitalSpecializationOrderByWithAggregationInput, type prismaNamespace_HospitalSpecializationOrderByWithRelationInput as HospitalSpecializationOrderByWithRelationInput, type prismaNamespace_HospitalSpecializationScalarFieldEnum as HospitalSpecializationScalarFieldEnum, type prismaNamespace_HospitalSpecializationScalarWhereInput as HospitalSpecializationScalarWhereInput, type prismaNamespace_HospitalSpecializationScalarWhereWithAggregatesInput as HospitalSpecializationScalarWhereWithAggregatesInput, type prismaNamespace_HospitalSpecializationSelect as HospitalSpecializationSelect, type prismaNamespace_HospitalSpecializationSelectCreateManyAndReturn as HospitalSpecializationSelectCreateManyAndReturn, type prismaNamespace_HospitalSpecializationSelectScalar as HospitalSpecializationSelectScalar, type prismaNamespace_HospitalSpecializationSelectUpdateManyAndReturn as HospitalSpecializationSelectUpdateManyAndReturn, type prismaNamespace_HospitalSpecializationUncheckedCreateInput as HospitalSpecializationUncheckedCreateInput, type prismaNamespace_HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput as HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput as HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUncheckedCreateWithoutHospitalInput as HospitalSpecializationUncheckedCreateWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUncheckedCreateWithoutSpecializationInput as HospitalSpecializationUncheckedCreateWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateInput as HospitalSpecializationUncheckedUpdateInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateManyInput as HospitalSpecializationUncheckedUpdateManyInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput as HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput as HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput as HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput as HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateWithoutHospitalInput as HospitalSpecializationUncheckedUpdateWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUncheckedUpdateWithoutSpecializationInput as HospitalSpecializationUncheckedUpdateWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUpdateArgs as HospitalSpecializationUpdateArgs, type prismaNamespace_HospitalSpecializationUpdateInput as HospitalSpecializationUpdateInput, type prismaNamespace_HospitalSpecializationUpdateManyAndReturnArgs as HospitalSpecializationUpdateManyAndReturnArgs, type prismaNamespace_HospitalSpecializationUpdateManyArgs as HospitalSpecializationUpdateManyArgs, type prismaNamespace_HospitalSpecializationUpdateManyMutationInput as HospitalSpecializationUpdateManyMutationInput, type prismaNamespace_HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput as HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput as HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUpdateManyWithoutHospitalNestedInput as HospitalSpecializationUpdateManyWithoutHospitalNestedInput, type prismaNamespace_HospitalSpecializationUpdateManyWithoutSpecializationNestedInput as HospitalSpecializationUpdateManyWithoutSpecializationNestedInput, type prismaNamespace_HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput as HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput as HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUpdateWithoutHospitalInput as HospitalSpecializationUpdateWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUpdateWithoutSpecializationInput as HospitalSpecializationUpdateWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationUpsertArgs as HospitalSpecializationUpsertArgs, type prismaNamespace_HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput as HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput as HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput, type prismaNamespace_HospitalSpecializationWhereInput as HospitalSpecializationWhereInput, type prismaNamespace_HospitalSpecializationWhereUniqueInput as HospitalSpecializationWhereUniqueInput, type prismaNamespace_HospitalSumAggregateInputType as HospitalSumAggregateInputType, type prismaNamespace_HospitalSumAggregateOutputType as HospitalSumAggregateOutputType, type prismaNamespace_HospitalSumOrderByAggregateInput as HospitalSumOrderByAggregateInput, type prismaNamespace_HospitalUncheckedCreateInput as HospitalUncheckedCreateInput, type prismaNamespace_HospitalUncheckedCreateNestedOneWithoutUserInput as HospitalUncheckedCreateNestedOneWithoutUserInput, type prismaNamespace_HospitalUncheckedCreateWithoutAppointmentInput as HospitalUncheckedCreateWithoutAppointmentInput, type prismaNamespace_HospitalUncheckedCreateWithoutDoctorApplicationInput as HospitalUncheckedCreateWithoutDoctorApplicationInput, type prismaNamespace_HospitalUncheckedCreateWithoutDoctorHospitalProfileInput as HospitalUncheckedCreateWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalUncheckedCreateWithoutHospitalSpecializationInput as HospitalUncheckedCreateWithoutHospitalSpecializationInput, type prismaNamespace_HospitalUncheckedCreateWithoutReviewInput as HospitalUncheckedCreateWithoutReviewInput, type prismaNamespace_HospitalUncheckedCreateWithoutSavedDoctorHospitalInput as HospitalUncheckedCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalUncheckedCreateWithoutScheduleInput as HospitalUncheckedCreateWithoutScheduleInput, type prismaNamespace_HospitalUncheckedCreateWithoutUserInput as HospitalUncheckedCreateWithoutUserInput, type prismaNamespace_HospitalUncheckedUpdateInput as HospitalUncheckedUpdateInput, type prismaNamespace_HospitalUncheckedUpdateManyInput as HospitalUncheckedUpdateManyInput, type prismaNamespace_HospitalUncheckedUpdateOneWithoutUserNestedInput as HospitalUncheckedUpdateOneWithoutUserNestedInput, type prismaNamespace_HospitalUncheckedUpdateWithoutAppointmentInput as HospitalUncheckedUpdateWithoutAppointmentInput, type prismaNamespace_HospitalUncheckedUpdateWithoutDoctorApplicationInput as HospitalUncheckedUpdateWithoutDoctorApplicationInput, type prismaNamespace_HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput as HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalUncheckedUpdateWithoutHospitalSpecializationInput as HospitalUncheckedUpdateWithoutHospitalSpecializationInput, type prismaNamespace_HospitalUncheckedUpdateWithoutReviewInput as HospitalUncheckedUpdateWithoutReviewInput, type prismaNamespace_HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput as HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalUncheckedUpdateWithoutScheduleInput as HospitalUncheckedUpdateWithoutScheduleInput, type prismaNamespace_HospitalUncheckedUpdateWithoutUserInput as HospitalUncheckedUpdateWithoutUserInput, type prismaNamespace_HospitalUpdateArgs as HospitalUpdateArgs, type prismaNamespace_HospitalUpdateInput as HospitalUpdateInput, type prismaNamespace_HospitalUpdateManyAndReturnArgs as HospitalUpdateManyAndReturnArgs, type prismaNamespace_HospitalUpdateManyArgs as HospitalUpdateManyArgs, type prismaNamespace_HospitalUpdateManyMutationInput as HospitalUpdateManyMutationInput, type prismaNamespace_HospitalUpdateOneRequiredWithoutAppointmentNestedInput as HospitalUpdateOneRequiredWithoutAppointmentNestedInput, type prismaNamespace_HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput as HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput, type prismaNamespace_HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput as HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput, type prismaNamespace_HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput as HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput, type prismaNamespace_HospitalUpdateOneRequiredWithoutScheduleNestedInput as HospitalUpdateOneRequiredWithoutScheduleNestedInput, type prismaNamespace_HospitalUpdateOneWithoutReviewNestedInput as HospitalUpdateOneWithoutReviewNestedInput, type prismaNamespace_HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput as HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput, type prismaNamespace_HospitalUpdateOneWithoutUserNestedInput as HospitalUpdateOneWithoutUserNestedInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutAppointmentInput as HospitalUpdateToOneWithWhereWithoutAppointmentInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput as HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput as HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput as HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutReviewInput as HospitalUpdateToOneWithWhereWithoutReviewInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutScheduleInput as HospitalUpdateToOneWithWhereWithoutScheduleInput, type prismaNamespace_HospitalUpdateToOneWithWhereWithoutUserInput as HospitalUpdateToOneWithWhereWithoutUserInput, type prismaNamespace_HospitalUpdateWithoutAppointmentInput as HospitalUpdateWithoutAppointmentInput, type prismaNamespace_HospitalUpdateWithoutDoctorApplicationInput as HospitalUpdateWithoutDoctorApplicationInput, type prismaNamespace_HospitalUpdateWithoutDoctorHospitalProfileInput as HospitalUpdateWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalUpdateWithoutHospitalSpecializationInput as HospitalUpdateWithoutHospitalSpecializationInput, type prismaNamespace_HospitalUpdateWithoutReviewInput as HospitalUpdateWithoutReviewInput, type prismaNamespace_HospitalUpdateWithoutSavedDoctorHospitalInput as HospitalUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalUpdateWithoutScheduleInput as HospitalUpdateWithoutScheduleInput, type prismaNamespace_HospitalUpdateWithoutUserInput as HospitalUpdateWithoutUserInput, type prismaNamespace_HospitalUpsertArgs as HospitalUpsertArgs, type prismaNamespace_HospitalUpsertWithoutAppointmentInput as HospitalUpsertWithoutAppointmentInput, type prismaNamespace_HospitalUpsertWithoutDoctorApplicationInput as HospitalUpsertWithoutDoctorApplicationInput, type prismaNamespace_HospitalUpsertWithoutDoctorHospitalProfileInput as HospitalUpsertWithoutDoctorHospitalProfileInput, type prismaNamespace_HospitalUpsertWithoutHospitalSpecializationInput as HospitalUpsertWithoutHospitalSpecializationInput, type prismaNamespace_HospitalUpsertWithoutReviewInput as HospitalUpsertWithoutReviewInput, type prismaNamespace_HospitalUpsertWithoutSavedDoctorHospitalInput as HospitalUpsertWithoutSavedDoctorHospitalInput, type prismaNamespace_HospitalUpsertWithoutScheduleInput as HospitalUpsertWithoutScheduleInput, type prismaNamespace_HospitalUpsertWithoutUserInput as HospitalUpsertWithoutUserInput, type prismaNamespace_HospitalWhereInput as HospitalWhereInput, type prismaNamespace_HospitalWhereUniqueInput as HospitalWhereUniqueInput, type prismaNamespace_InputJsonArray as InputJsonArray, type prismaNamespace_InputJsonObject as InputJsonObject, type prismaNamespace_InputJsonValue as InputJsonValue, type prismaNamespace_IntFieldRefInput as IntFieldRefInput, type prismaNamespace_IntFieldUpdateOperationsInput as IntFieldUpdateOperationsInput, type prismaNamespace_IntFilter as IntFilter, type prismaNamespace_IntNullableFilter as IntNullableFilter, type prismaNamespace_IntNullableListFilter as IntNullableListFilter, type prismaNamespace_IntNullableWithAggregatesFilter as IntNullableWithAggregatesFilter, type prismaNamespace_IntWithAggregatesFilter as IntWithAggregatesFilter, type prismaNamespace_IntersectOf as IntersectOf, type prismaNamespace_JsonArray as JsonArray, type prismaNamespace_JsonFieldRefInput as JsonFieldRefInput, prismaNamespace_JsonNull as JsonNull, type prismaNamespace_JsonNullValueFilter as JsonNullValueFilter, type prismaNamespace_JsonNullableFilter as JsonNullableFilter, type prismaNamespace_JsonNullableFilterBase as JsonNullableFilterBase, type prismaNamespace_JsonNullableWithAggregatesFilter as JsonNullableWithAggregatesFilter, type prismaNamespace_JsonNullableWithAggregatesFilterBase as JsonNullableWithAggregatesFilterBase, type prismaNamespace_JsonObject as JsonObject, type prismaNamespace_JsonValue as JsonValue, type prismaNamespace_Keys as Keys, type prismaNamespace_ListDateTimeFieldRefInput as ListDateTimeFieldRefInput, type prismaNamespace_ListDecimalFieldRefInput as ListDecimalFieldRefInput, type prismaNamespace_ListEnumAppointmentStatusFieldRefInput as ListEnumAppointmentStatusFieldRefInput, type prismaNamespace_ListEnumDoctorApplicationStatusFieldRefInput as ListEnumDoctorApplicationStatusFieldRefInput, type prismaNamespace_ListEnumDoctorTypeFieldRefInput as ListEnumDoctorTypeFieldRefInput, type prismaNamespace_ListEnumHospitalTypeFieldRefInput as ListEnumHospitalTypeFieldRefInput, type prismaNamespace_ListEnumRoleFieldRefInput as ListEnumRoleFieldRefInput, type prismaNamespace_ListEnumSchedulePeriodFieldRefInput as ListEnumSchedulePeriodFieldRefInput, type prismaNamespace_ListEnumScheduleStatusFieldRefInput as ListEnumScheduleStatusFieldRefInput, type prismaNamespace_ListEnumScheduleTypeFieldRefInput as ListEnumScheduleTypeFieldRefInput, type prismaNamespace_ListEnumSlotStatusFieldRefInput as ListEnumSlotStatusFieldRefInput, type prismaNamespace_ListFloatFieldRefInput as ListFloatFieldRefInput, type prismaNamespace_ListIntFieldRefInput as ListIntFieldRefInput, type prismaNamespace_ListStringFieldRefInput as ListStringFieldRefInput, type prismaNamespace_LogDefinition as LogDefinition, type prismaNamespace_LogEvent as LogEvent, type prismaNamespace_LogLevel as LogLevel, type prismaNamespace_MaybeTupleToUnion as MaybeTupleToUnion, type prismaNamespace_Merge as Merge, type prismaNamespace_ModelName as ModelName, type prismaNamespace_NestedBoolFilter as NestedBoolFilter, type prismaNamespace_NestedBoolNullableFilter as NestedBoolNullableFilter, type prismaNamespace_NestedBoolNullableWithAggregatesFilter as NestedBoolNullableWithAggregatesFilter, type prismaNamespace_NestedBoolWithAggregatesFilter as NestedBoolWithAggregatesFilter, type prismaNamespace_NestedDateTimeFilter as NestedDateTimeFilter, type prismaNamespace_NestedDateTimeNullableFilter as NestedDateTimeNullableFilter, type prismaNamespace_NestedDateTimeNullableWithAggregatesFilter as NestedDateTimeNullableWithAggregatesFilter, type prismaNamespace_NestedDateTimeWithAggregatesFilter as NestedDateTimeWithAggregatesFilter, type prismaNamespace_NestedDecimalFilter as NestedDecimalFilter, type prismaNamespace_NestedDecimalNullableFilter as NestedDecimalNullableFilter, type prismaNamespace_NestedDecimalNullableWithAggregatesFilter as NestedDecimalNullableWithAggregatesFilter, type prismaNamespace_NestedDecimalWithAggregatesFilter as NestedDecimalWithAggregatesFilter, type prismaNamespace_NestedEnumAppointmentStatusFilter as NestedEnumAppointmentStatusFilter, type prismaNamespace_NestedEnumAppointmentStatusWithAggregatesFilter as NestedEnumAppointmentStatusWithAggregatesFilter, type prismaNamespace_NestedEnumDoctorApplicationStatusFilter as NestedEnumDoctorApplicationStatusFilter, type prismaNamespace_NestedEnumDoctorApplicationStatusWithAggregatesFilter as NestedEnumDoctorApplicationStatusWithAggregatesFilter, type prismaNamespace_NestedEnumDoctorTypeFilter as NestedEnumDoctorTypeFilter, type prismaNamespace_NestedEnumDoctorTypeWithAggregatesFilter as NestedEnumDoctorTypeWithAggregatesFilter, type prismaNamespace_NestedEnumHospitalTypeFilter as NestedEnumHospitalTypeFilter, type prismaNamespace_NestedEnumHospitalTypeWithAggregatesFilter as NestedEnumHospitalTypeWithAggregatesFilter, type prismaNamespace_NestedEnumRoleNullableFilter as NestedEnumRoleNullableFilter, type prismaNamespace_NestedEnumRoleNullableWithAggregatesFilter as NestedEnumRoleNullableWithAggregatesFilter, type prismaNamespace_NestedEnumSchedulePeriodFilter as NestedEnumSchedulePeriodFilter, type prismaNamespace_NestedEnumSchedulePeriodWithAggregatesFilter as NestedEnumSchedulePeriodWithAggregatesFilter, type prismaNamespace_NestedEnumScheduleStatusFilter as NestedEnumScheduleStatusFilter, type prismaNamespace_NestedEnumScheduleStatusWithAggregatesFilter as NestedEnumScheduleStatusWithAggregatesFilter, type prismaNamespace_NestedEnumScheduleTypeFilter as NestedEnumScheduleTypeFilter, type prismaNamespace_NestedEnumScheduleTypeWithAggregatesFilter as NestedEnumScheduleTypeWithAggregatesFilter, type prismaNamespace_NestedEnumSlotStatusFilter as NestedEnumSlotStatusFilter, type prismaNamespace_NestedEnumSlotStatusWithAggregatesFilter as NestedEnumSlotStatusWithAggregatesFilter, type prismaNamespace_NestedFloatFilter as NestedFloatFilter, type prismaNamespace_NestedFloatNullableFilter as NestedFloatNullableFilter, type prismaNamespace_NestedIntFilter as NestedIntFilter, type prismaNamespace_NestedIntNullableFilter as NestedIntNullableFilter, type prismaNamespace_NestedIntNullableWithAggregatesFilter as NestedIntNullableWithAggregatesFilter, type prismaNamespace_NestedIntWithAggregatesFilter as NestedIntWithAggregatesFilter, type prismaNamespace_NestedJsonNullableFilter as NestedJsonNullableFilter, type prismaNamespace_NestedJsonNullableFilterBase as NestedJsonNullableFilterBase, type prismaNamespace_NestedStringFilter as NestedStringFilter, type prismaNamespace_NestedStringNullableFilter as NestedStringNullableFilter, type prismaNamespace_NestedStringNullableWithAggregatesFilter as NestedStringNullableWithAggregatesFilter, type prismaNamespace_NestedStringWithAggregatesFilter as NestedStringWithAggregatesFilter, type prismaNamespace_Not as Not, type prismaNamespace_NotificationAggregateArgs as NotificationAggregateArgs, type prismaNamespace_NotificationCountAggregateInputType as NotificationCountAggregateInputType, type prismaNamespace_NotificationCountAggregateOutputType as NotificationCountAggregateOutputType, type prismaNamespace_NotificationCountArgs as NotificationCountArgs, type prismaNamespace_NotificationCountOrderByAggregateInput as NotificationCountOrderByAggregateInput, type prismaNamespace_NotificationCreateArgs as NotificationCreateArgs, type prismaNamespace_NotificationCreateInput as NotificationCreateInput, type prismaNamespace_NotificationCreateManyAndReturnArgs as NotificationCreateManyAndReturnArgs, type prismaNamespace_NotificationCreateManyArgs as NotificationCreateManyArgs, type prismaNamespace_NotificationCreateManyInput as NotificationCreateManyInput, type prismaNamespace_NotificationCreateManyUserInput as NotificationCreateManyUserInput, type prismaNamespace_NotificationCreateManyUserInputEnvelope as NotificationCreateManyUserInputEnvelope, type prismaNamespace_NotificationCreateNestedManyWithoutUserInput as NotificationCreateNestedManyWithoutUserInput, type prismaNamespace_NotificationCreateOrConnectWithoutUserInput as NotificationCreateOrConnectWithoutUserInput, type prismaNamespace_NotificationCreateWithoutUserInput as NotificationCreateWithoutUserInput, type prismaNamespace_NotificationDefaultArgs as NotificationDefaultArgs, type prismaNamespace_NotificationDelegate as NotificationDelegate, type prismaNamespace_NotificationDeleteArgs as NotificationDeleteArgs, type prismaNamespace_NotificationDeleteManyArgs as NotificationDeleteManyArgs, type prismaNamespace_NotificationFieldRefs as NotificationFieldRefs, type prismaNamespace_NotificationFindFirstArgs as NotificationFindFirstArgs, type prismaNamespace_NotificationFindFirstOrThrowArgs as NotificationFindFirstOrThrowArgs, type prismaNamespace_NotificationFindManyArgs as NotificationFindManyArgs, type prismaNamespace_NotificationFindUniqueArgs as NotificationFindUniqueArgs, type prismaNamespace_NotificationFindUniqueOrThrowArgs as NotificationFindUniqueOrThrowArgs, type prismaNamespace_NotificationGetPayload as NotificationGetPayload, type prismaNamespace_NotificationGroupByArgs as NotificationGroupByArgs, type prismaNamespace_NotificationGroupByOutputType as NotificationGroupByOutputType, type prismaNamespace_NotificationInclude as NotificationInclude, type prismaNamespace_NotificationIncludeCreateManyAndReturn as NotificationIncludeCreateManyAndReturn, type prismaNamespace_NotificationIncludeUpdateManyAndReturn as NotificationIncludeUpdateManyAndReturn, type prismaNamespace_NotificationListRelationFilter as NotificationListRelationFilter, type prismaNamespace_NotificationMaxAggregateInputType as NotificationMaxAggregateInputType, type prismaNamespace_NotificationMaxAggregateOutputType as NotificationMaxAggregateOutputType, type prismaNamespace_NotificationMaxOrderByAggregateInput as NotificationMaxOrderByAggregateInput, type prismaNamespace_NotificationMinAggregateInputType as NotificationMinAggregateInputType, type prismaNamespace_NotificationMinAggregateOutputType as NotificationMinAggregateOutputType, type prismaNamespace_NotificationMinOrderByAggregateInput as NotificationMinOrderByAggregateInput, type prismaNamespace_NotificationModel as NotificationModel, type prismaNamespace_NotificationOmit as NotificationOmit, type prismaNamespace_NotificationOrderByRelationAggregateInput as NotificationOrderByRelationAggregateInput, type prismaNamespace_NotificationOrderByWithAggregationInput as NotificationOrderByWithAggregationInput, type prismaNamespace_NotificationOrderByWithRelationInput as NotificationOrderByWithRelationInput, type prismaNamespace_NotificationScalarFieldEnum as NotificationScalarFieldEnum, type prismaNamespace_NotificationScalarWhereInput as NotificationScalarWhereInput, type prismaNamespace_NotificationScalarWhereWithAggregatesInput as NotificationScalarWhereWithAggregatesInput, type prismaNamespace_NotificationSelect as NotificationSelect, type prismaNamespace_NotificationSelectCreateManyAndReturn as NotificationSelectCreateManyAndReturn, type prismaNamespace_NotificationSelectScalar as NotificationSelectScalar, type prismaNamespace_NotificationSelectUpdateManyAndReturn as NotificationSelectUpdateManyAndReturn, type prismaNamespace_NotificationUncheckedCreateInput as NotificationUncheckedCreateInput, type prismaNamespace_NotificationUncheckedCreateNestedManyWithoutUserInput as NotificationUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_NotificationUncheckedCreateWithoutUserInput as NotificationUncheckedCreateWithoutUserInput, type prismaNamespace_NotificationUncheckedUpdateInput as NotificationUncheckedUpdateInput, type prismaNamespace_NotificationUncheckedUpdateManyInput as NotificationUncheckedUpdateManyInput, type prismaNamespace_NotificationUncheckedUpdateManyWithoutUserInput as NotificationUncheckedUpdateManyWithoutUserInput, type prismaNamespace_NotificationUncheckedUpdateManyWithoutUserNestedInput as NotificationUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_NotificationUncheckedUpdateWithoutUserInput as NotificationUncheckedUpdateWithoutUserInput, type prismaNamespace_NotificationUpdateArgs as NotificationUpdateArgs, type prismaNamespace_NotificationUpdateInput as NotificationUpdateInput, type prismaNamespace_NotificationUpdateManyAndReturnArgs as NotificationUpdateManyAndReturnArgs, type prismaNamespace_NotificationUpdateManyArgs as NotificationUpdateManyArgs, type prismaNamespace_NotificationUpdateManyMutationInput as NotificationUpdateManyMutationInput, type prismaNamespace_NotificationUpdateManyWithWhereWithoutUserInput as NotificationUpdateManyWithWhereWithoutUserInput, type prismaNamespace_NotificationUpdateManyWithoutUserNestedInput as NotificationUpdateManyWithoutUserNestedInput, type prismaNamespace_NotificationUpdateWithWhereUniqueWithoutUserInput as NotificationUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_NotificationUpdateWithoutUserInput as NotificationUpdateWithoutUserInput, type prismaNamespace_NotificationUpsertArgs as NotificationUpsertArgs, type prismaNamespace_NotificationUpsertWithWhereUniqueWithoutUserInput as NotificationUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_NotificationWhereInput as NotificationWhereInput, type prismaNamespace_NotificationWhereUniqueInput as NotificationWhereUniqueInput, prismaNamespace_NullTypes as NullTypes, type prismaNamespace_NullableBoolFieldUpdateOperationsInput as NullableBoolFieldUpdateOperationsInput, type prismaNamespace_NullableDateTimeFieldUpdateOperationsInput as NullableDateTimeFieldUpdateOperationsInput, type prismaNamespace_NullableDecimalFieldUpdateOperationsInput as NullableDecimalFieldUpdateOperationsInput, type prismaNamespace_NullableEnumRoleFieldUpdateOperationsInput as NullableEnumRoleFieldUpdateOperationsInput, type prismaNamespace_NullableIntFieldUpdateOperationsInput as NullableIntFieldUpdateOperationsInput, type prismaNamespace_NullableJsonNullValueInput as NullableJsonNullValueInput, type prismaNamespace_NullableStringFieldUpdateOperationsInput as NullableStringFieldUpdateOperationsInput, type prismaNamespace_NullsOrder as NullsOrder, type prismaNamespace_OptionalFlat as OptionalFlat, type prismaNamespace_Or as Or, type prismaNamespace_Overwrite as Overwrite, type prismaNamespace_PatchUndefined as PatchUndefined, type prismaNamespace_Payload as Payload, type prismaNamespace_PaymentAggregateArgs as PaymentAggregateArgs, type prismaNamespace_PaymentAvgAggregateInputType as PaymentAvgAggregateInputType, type prismaNamespace_PaymentAvgAggregateOutputType as PaymentAvgAggregateOutputType, type prismaNamespace_PaymentAvgOrderByAggregateInput as PaymentAvgOrderByAggregateInput, type prismaNamespace_PaymentCountAggregateInputType as PaymentCountAggregateInputType, type prismaNamespace_PaymentCountAggregateOutputType as PaymentCountAggregateOutputType, type prismaNamespace_PaymentCountArgs as PaymentCountArgs, type prismaNamespace_PaymentCountOrderByAggregateInput as PaymentCountOrderByAggregateInput, type prismaNamespace_PaymentCreateArgs as PaymentCreateArgs, type prismaNamespace_PaymentCreateInput as PaymentCreateInput, type prismaNamespace_PaymentCreateManyAndReturnArgs as PaymentCreateManyAndReturnArgs, type prismaNamespace_PaymentCreateManyArgs as PaymentCreateManyArgs, type prismaNamespace_PaymentCreateManyInput as PaymentCreateManyInput, type prismaNamespace_PaymentCreateManyUserInput as PaymentCreateManyUserInput, type prismaNamespace_PaymentCreateManyUserInputEnvelope as PaymentCreateManyUserInputEnvelope, type prismaNamespace_PaymentCreateNestedManyWithoutUserInput as PaymentCreateNestedManyWithoutUserInput, type prismaNamespace_PaymentCreateNestedOneWithoutAppointmentInput as PaymentCreateNestedOneWithoutAppointmentInput, type prismaNamespace_PaymentCreateOrConnectWithoutAppointmentInput as PaymentCreateOrConnectWithoutAppointmentInput, type prismaNamespace_PaymentCreateOrConnectWithoutUserInput as PaymentCreateOrConnectWithoutUserInput, type prismaNamespace_PaymentCreateWithoutAppointmentInput as PaymentCreateWithoutAppointmentInput, type prismaNamespace_PaymentCreateWithoutUserInput as PaymentCreateWithoutUserInput, type prismaNamespace_PaymentDefaultArgs as PaymentDefaultArgs, type prismaNamespace_PaymentDelegate as PaymentDelegate, type prismaNamespace_PaymentDeleteArgs as PaymentDeleteArgs, type prismaNamespace_PaymentDeleteManyArgs as PaymentDeleteManyArgs, type prismaNamespace_PaymentFieldRefs as PaymentFieldRefs, type prismaNamespace_PaymentFindFirstArgs as PaymentFindFirstArgs, type prismaNamespace_PaymentFindFirstOrThrowArgs as PaymentFindFirstOrThrowArgs, type prismaNamespace_PaymentFindManyArgs as PaymentFindManyArgs, type prismaNamespace_PaymentFindUniqueArgs as PaymentFindUniqueArgs, type prismaNamespace_PaymentFindUniqueOrThrowArgs as PaymentFindUniqueOrThrowArgs, type prismaNamespace_PaymentGetPayload as PaymentGetPayload, type prismaNamespace_PaymentGroupByArgs as PaymentGroupByArgs, type prismaNamespace_PaymentGroupByOutputType as PaymentGroupByOutputType, type prismaNamespace_PaymentInclude as PaymentInclude, type prismaNamespace_PaymentIncludeCreateManyAndReturn as PaymentIncludeCreateManyAndReturn, type prismaNamespace_PaymentIncludeUpdateManyAndReturn as PaymentIncludeUpdateManyAndReturn, type prismaNamespace_PaymentListRelationFilter as PaymentListRelationFilter, type prismaNamespace_PaymentMaxAggregateInputType as PaymentMaxAggregateInputType, type prismaNamespace_PaymentMaxAggregateOutputType as PaymentMaxAggregateOutputType, type prismaNamespace_PaymentMaxOrderByAggregateInput as PaymentMaxOrderByAggregateInput, type prismaNamespace_PaymentMinAggregateInputType as PaymentMinAggregateInputType, type prismaNamespace_PaymentMinAggregateOutputType as PaymentMinAggregateOutputType, type prismaNamespace_PaymentMinOrderByAggregateInput as PaymentMinOrderByAggregateInput, type prismaNamespace_PaymentModel as PaymentModel, type prismaNamespace_PaymentNullableScalarRelationFilter as PaymentNullableScalarRelationFilter, type prismaNamespace_PaymentOmit as PaymentOmit, type prismaNamespace_PaymentOrderByRelationAggregateInput as PaymentOrderByRelationAggregateInput, type prismaNamespace_PaymentOrderByWithAggregationInput as PaymentOrderByWithAggregationInput, type prismaNamespace_PaymentOrderByWithRelationInput as PaymentOrderByWithRelationInput, type prismaNamespace_PaymentScalarFieldEnum as PaymentScalarFieldEnum, type prismaNamespace_PaymentScalarWhereInput as PaymentScalarWhereInput, type prismaNamespace_PaymentScalarWhereWithAggregatesInput as PaymentScalarWhereWithAggregatesInput, type prismaNamespace_PaymentSelect as PaymentSelect, type prismaNamespace_PaymentSelectCreateManyAndReturn as PaymentSelectCreateManyAndReturn, type prismaNamespace_PaymentSelectScalar as PaymentSelectScalar, type prismaNamespace_PaymentSelectUpdateManyAndReturn as PaymentSelectUpdateManyAndReturn, type prismaNamespace_PaymentSumAggregateInputType as PaymentSumAggregateInputType, type prismaNamespace_PaymentSumAggregateOutputType as PaymentSumAggregateOutputType, type prismaNamespace_PaymentSumOrderByAggregateInput as PaymentSumOrderByAggregateInput, type prismaNamespace_PaymentUncheckedCreateInput as PaymentUncheckedCreateInput, type prismaNamespace_PaymentUncheckedCreateNestedManyWithoutUserInput as PaymentUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_PaymentUncheckedCreateNestedOneWithoutAppointmentInput as PaymentUncheckedCreateNestedOneWithoutAppointmentInput, type prismaNamespace_PaymentUncheckedCreateWithoutAppointmentInput as PaymentUncheckedCreateWithoutAppointmentInput, type prismaNamespace_PaymentUncheckedCreateWithoutUserInput as PaymentUncheckedCreateWithoutUserInput, type prismaNamespace_PaymentUncheckedUpdateInput as PaymentUncheckedUpdateInput, type prismaNamespace_PaymentUncheckedUpdateManyInput as PaymentUncheckedUpdateManyInput, type prismaNamespace_PaymentUncheckedUpdateManyWithoutUserInput as PaymentUncheckedUpdateManyWithoutUserInput, type prismaNamespace_PaymentUncheckedUpdateManyWithoutUserNestedInput as PaymentUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_PaymentUncheckedUpdateOneWithoutAppointmentNestedInput as PaymentUncheckedUpdateOneWithoutAppointmentNestedInput, type prismaNamespace_PaymentUncheckedUpdateWithoutAppointmentInput as PaymentUncheckedUpdateWithoutAppointmentInput, type prismaNamespace_PaymentUncheckedUpdateWithoutUserInput as PaymentUncheckedUpdateWithoutUserInput, type prismaNamespace_PaymentUpdateArgs as PaymentUpdateArgs, type prismaNamespace_PaymentUpdateInput as PaymentUpdateInput, type prismaNamespace_PaymentUpdateManyAndReturnArgs as PaymentUpdateManyAndReturnArgs, type prismaNamespace_PaymentUpdateManyArgs as PaymentUpdateManyArgs, type prismaNamespace_PaymentUpdateManyMutationInput as PaymentUpdateManyMutationInput, type prismaNamespace_PaymentUpdateManyWithWhereWithoutUserInput as PaymentUpdateManyWithWhereWithoutUserInput, type prismaNamespace_PaymentUpdateManyWithoutUserNestedInput as PaymentUpdateManyWithoutUserNestedInput, type prismaNamespace_PaymentUpdateOneWithoutAppointmentNestedInput as PaymentUpdateOneWithoutAppointmentNestedInput, type prismaNamespace_PaymentUpdateToOneWithWhereWithoutAppointmentInput as PaymentUpdateToOneWithWhereWithoutAppointmentInput, type prismaNamespace_PaymentUpdateWithWhereUniqueWithoutUserInput as PaymentUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_PaymentUpdateWithoutAppointmentInput as PaymentUpdateWithoutAppointmentInput, type prismaNamespace_PaymentUpdateWithoutUserInput as PaymentUpdateWithoutUserInput, type prismaNamespace_PaymentUpsertArgs as PaymentUpsertArgs, type prismaNamespace_PaymentUpsertWithWhereUniqueWithoutUserInput as PaymentUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_PaymentUpsertWithoutAppointmentInput as PaymentUpsertWithoutAppointmentInput, type prismaNamespace_PaymentWhereInput as PaymentWhereInput, type prismaNamespace_PaymentWhereUniqueInput as PaymentWhereUniqueInput, type prismaNamespace_PickEnumerable as PickEnumerable, type prismaNamespace_PrismaAction as PrismaAction, type prismaNamespace_PrismaClientInitializationError as PrismaClientInitializationError, type prismaNamespace_PrismaClientKnownRequestError as PrismaClientKnownRequestError, type prismaNamespace_PrismaClientOptions as PrismaClientOptions, type prismaNamespace_PrismaClientRustPanicError as PrismaClientRustPanicError, type prismaNamespace_PrismaClientUnknownRequestError as PrismaClientUnknownRequestError, type prismaNamespace_PrismaClientValidationError as PrismaClientValidationError, type prismaNamespace_PrismaPromise as PrismaPromise, type prismaNamespace_PrismaVersion as PrismaVersion, type prismaNamespace_Prisma__AppointmentClient as Prisma__AppointmentClient, type prismaNamespace_Prisma__AuditLogClient as Prisma__AuditLogClient, type prismaNamespace_Prisma__DoctorApplicationClient as Prisma__DoctorApplicationClient, type prismaNamespace_Prisma__DoctorClient as Prisma__DoctorClient, type prismaNamespace_Prisma__DoctorHospitalProfileClient as Prisma__DoctorHospitalProfileClient, type prismaNamespace_Prisma__DoctorSpecializationClient as Prisma__DoctorSpecializationClient, type prismaNamespace_Prisma__HospitalClient as Prisma__HospitalClient, type prismaNamespace_Prisma__HospitalSpecializationClient as Prisma__HospitalSpecializationClient, type prismaNamespace_Prisma__NotificationClient as Prisma__NotificationClient, type prismaNamespace_Prisma__PaymentClient as Prisma__PaymentClient, type prismaNamespace_Prisma__ReviewClient as Prisma__ReviewClient, type prismaNamespace_Prisma__SavedDoctorHospitalClient as Prisma__SavedDoctorHospitalClient, type prismaNamespace_Prisma__ScheduleClient as Prisma__ScheduleClient, type prismaNamespace_Prisma__SearchLogClient as Prisma__SearchLogClient, type prismaNamespace_Prisma__SlotClient as Prisma__SlotClient, type prismaNamespace_Prisma__SpecializationClient as Prisma__SpecializationClient, type prismaNamespace_Prisma__UserClient as Prisma__UserClient, type prismaNamespace_Prisma__accountClient as Prisma__accountClient, type prismaNamespace_Prisma__sessionClient as Prisma__sessionClient, type prismaNamespace_Prisma__verificationClient as Prisma__verificationClient, type prismaNamespace_QueryEvent as QueryEvent, type prismaNamespace_QueryMode as QueryMode, type prismaNamespace_Result as Result, type prismaNamespace_Review$DoctorArgs as Review$DoctorArgs, type prismaNamespace_Review$HospitalArgs as Review$HospitalArgs, type prismaNamespace_ReviewAggregateArgs as ReviewAggregateArgs, type prismaNamespace_ReviewAvgAggregateInputType as ReviewAvgAggregateInputType, type prismaNamespace_ReviewAvgAggregateOutputType as ReviewAvgAggregateOutputType, type prismaNamespace_ReviewAvgOrderByAggregateInput as ReviewAvgOrderByAggregateInput, type prismaNamespace_ReviewCountAggregateInputType as ReviewCountAggregateInputType, type prismaNamespace_ReviewCountAggregateOutputType as ReviewCountAggregateOutputType, type prismaNamespace_ReviewCountArgs as ReviewCountArgs, type prismaNamespace_ReviewCountOrderByAggregateInput as ReviewCountOrderByAggregateInput, type prismaNamespace_ReviewCreateArgs as ReviewCreateArgs, type prismaNamespace_ReviewCreateInput as ReviewCreateInput, type prismaNamespace_ReviewCreateManyAndReturnArgs as ReviewCreateManyAndReturnArgs, type prismaNamespace_ReviewCreateManyArgs as ReviewCreateManyArgs, type prismaNamespace_ReviewCreateManyDoctorInput as ReviewCreateManyDoctorInput, type prismaNamespace_ReviewCreateManyDoctorInputEnvelope as ReviewCreateManyDoctorInputEnvelope, type prismaNamespace_ReviewCreateManyHospitalInput as ReviewCreateManyHospitalInput, type prismaNamespace_ReviewCreateManyHospitalInputEnvelope as ReviewCreateManyHospitalInputEnvelope, type prismaNamespace_ReviewCreateManyInput as ReviewCreateManyInput, type prismaNamespace_ReviewCreateManyUserInput as ReviewCreateManyUserInput, type prismaNamespace_ReviewCreateManyUserInputEnvelope as ReviewCreateManyUserInputEnvelope, type prismaNamespace_ReviewCreateNestedManyWithoutDoctorInput as ReviewCreateNestedManyWithoutDoctorInput, type prismaNamespace_ReviewCreateNestedManyWithoutHospitalInput as ReviewCreateNestedManyWithoutHospitalInput, type prismaNamespace_ReviewCreateNestedManyWithoutUserInput as ReviewCreateNestedManyWithoutUserInput, type prismaNamespace_ReviewCreateOrConnectWithoutDoctorInput as ReviewCreateOrConnectWithoutDoctorInput, type prismaNamespace_ReviewCreateOrConnectWithoutHospitalInput as ReviewCreateOrConnectWithoutHospitalInput, type prismaNamespace_ReviewCreateOrConnectWithoutUserInput as ReviewCreateOrConnectWithoutUserInput, type prismaNamespace_ReviewCreateWithoutDoctorInput as ReviewCreateWithoutDoctorInput, type prismaNamespace_ReviewCreateWithoutHospitalInput as ReviewCreateWithoutHospitalInput, type prismaNamespace_ReviewCreateWithoutUserInput as ReviewCreateWithoutUserInput, type prismaNamespace_ReviewDefaultArgs as ReviewDefaultArgs, type prismaNamespace_ReviewDelegate as ReviewDelegate, type prismaNamespace_ReviewDeleteArgs as ReviewDeleteArgs, type prismaNamespace_ReviewDeleteManyArgs as ReviewDeleteManyArgs, type prismaNamespace_ReviewFieldRefs as ReviewFieldRefs, type prismaNamespace_ReviewFindFirstArgs as ReviewFindFirstArgs, type prismaNamespace_ReviewFindFirstOrThrowArgs as ReviewFindFirstOrThrowArgs, type prismaNamespace_ReviewFindManyArgs as ReviewFindManyArgs, type prismaNamespace_ReviewFindUniqueArgs as ReviewFindUniqueArgs, type prismaNamespace_ReviewFindUniqueOrThrowArgs as ReviewFindUniqueOrThrowArgs, type prismaNamespace_ReviewGetPayload as ReviewGetPayload, type prismaNamespace_ReviewGroupByArgs as ReviewGroupByArgs, type prismaNamespace_ReviewGroupByOutputType as ReviewGroupByOutputType, type prismaNamespace_ReviewInclude as ReviewInclude, type prismaNamespace_ReviewIncludeCreateManyAndReturn as ReviewIncludeCreateManyAndReturn, type prismaNamespace_ReviewIncludeUpdateManyAndReturn as ReviewIncludeUpdateManyAndReturn, type prismaNamespace_ReviewListRelationFilter as ReviewListRelationFilter, type prismaNamespace_ReviewMaxAggregateInputType as ReviewMaxAggregateInputType, type prismaNamespace_ReviewMaxAggregateOutputType as ReviewMaxAggregateOutputType, type prismaNamespace_ReviewMaxOrderByAggregateInput as ReviewMaxOrderByAggregateInput, type prismaNamespace_ReviewMinAggregateInputType as ReviewMinAggregateInputType, type prismaNamespace_ReviewMinAggregateOutputType as ReviewMinAggregateOutputType, type prismaNamespace_ReviewMinOrderByAggregateInput as ReviewMinOrderByAggregateInput, type prismaNamespace_ReviewModel as ReviewModel, type prismaNamespace_ReviewOmit as ReviewOmit, type prismaNamespace_ReviewOrderByRelationAggregateInput as ReviewOrderByRelationAggregateInput, type prismaNamespace_ReviewOrderByWithAggregationInput as ReviewOrderByWithAggregationInput, type prismaNamespace_ReviewOrderByWithRelationInput as ReviewOrderByWithRelationInput, type prismaNamespace_ReviewScalarFieldEnum as ReviewScalarFieldEnum, type prismaNamespace_ReviewScalarWhereInput as ReviewScalarWhereInput, type prismaNamespace_ReviewScalarWhereWithAggregatesInput as ReviewScalarWhereWithAggregatesInput, type prismaNamespace_ReviewSelect as ReviewSelect, type prismaNamespace_ReviewSelectCreateManyAndReturn as ReviewSelectCreateManyAndReturn, type prismaNamespace_ReviewSelectScalar as ReviewSelectScalar, type prismaNamespace_ReviewSelectUpdateManyAndReturn as ReviewSelectUpdateManyAndReturn, type prismaNamespace_ReviewSumAggregateInputType as ReviewSumAggregateInputType, type prismaNamespace_ReviewSumAggregateOutputType as ReviewSumAggregateOutputType, type prismaNamespace_ReviewSumOrderByAggregateInput as ReviewSumOrderByAggregateInput, type prismaNamespace_ReviewUncheckedCreateInput as ReviewUncheckedCreateInput, type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutDoctorInput as ReviewUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutHospitalInput as ReviewUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_ReviewUncheckedCreateNestedManyWithoutUserInput as ReviewUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_ReviewUncheckedCreateWithoutDoctorInput as ReviewUncheckedCreateWithoutDoctorInput, type prismaNamespace_ReviewUncheckedCreateWithoutHospitalInput as ReviewUncheckedCreateWithoutHospitalInput, type prismaNamespace_ReviewUncheckedCreateWithoutUserInput as ReviewUncheckedCreateWithoutUserInput, type prismaNamespace_ReviewUncheckedUpdateInput as ReviewUncheckedUpdateInput, type prismaNamespace_ReviewUncheckedUpdateManyInput as ReviewUncheckedUpdateManyInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutDoctorInput as ReviewUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutDoctorNestedInput as ReviewUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutHospitalInput as ReviewUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutHospitalNestedInput as ReviewUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutUserInput as ReviewUncheckedUpdateManyWithoutUserInput, type prismaNamespace_ReviewUncheckedUpdateManyWithoutUserNestedInput as ReviewUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_ReviewUncheckedUpdateWithoutDoctorInput as ReviewUncheckedUpdateWithoutDoctorInput, type prismaNamespace_ReviewUncheckedUpdateWithoutHospitalInput as ReviewUncheckedUpdateWithoutHospitalInput, type prismaNamespace_ReviewUncheckedUpdateWithoutUserInput as ReviewUncheckedUpdateWithoutUserInput, type prismaNamespace_ReviewUpdateArgs as ReviewUpdateArgs, type prismaNamespace_ReviewUpdateInput as ReviewUpdateInput, type prismaNamespace_ReviewUpdateManyAndReturnArgs as ReviewUpdateManyAndReturnArgs, type prismaNamespace_ReviewUpdateManyArgs as ReviewUpdateManyArgs, type prismaNamespace_ReviewUpdateManyMutationInput as ReviewUpdateManyMutationInput, type prismaNamespace_ReviewUpdateManyWithWhereWithoutDoctorInput as ReviewUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_ReviewUpdateManyWithWhereWithoutHospitalInput as ReviewUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_ReviewUpdateManyWithWhereWithoutUserInput as ReviewUpdateManyWithWhereWithoutUserInput, type prismaNamespace_ReviewUpdateManyWithoutDoctorNestedInput as ReviewUpdateManyWithoutDoctorNestedInput, type prismaNamespace_ReviewUpdateManyWithoutHospitalNestedInput as ReviewUpdateManyWithoutHospitalNestedInput, type prismaNamespace_ReviewUpdateManyWithoutUserNestedInput as ReviewUpdateManyWithoutUserNestedInput, type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutDoctorInput as ReviewUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutHospitalInput as ReviewUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_ReviewUpdateWithWhereUniqueWithoutUserInput as ReviewUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_ReviewUpdateWithoutDoctorInput as ReviewUpdateWithoutDoctorInput, type prismaNamespace_ReviewUpdateWithoutHospitalInput as ReviewUpdateWithoutHospitalInput, type prismaNamespace_ReviewUpdateWithoutUserInput as ReviewUpdateWithoutUserInput, type prismaNamespace_ReviewUpsertArgs as ReviewUpsertArgs, type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutDoctorInput as ReviewUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutHospitalInput as ReviewUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_ReviewUpsertWithWhereUniqueWithoutUserInput as ReviewUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_ReviewWhereInput as ReviewWhereInput, type prismaNamespace_ReviewWhereUniqueInput as ReviewWhereUniqueInput, type prismaNamespace_SavedDoctorHospital$DoctorArgs as SavedDoctorHospital$DoctorArgs, type prismaNamespace_SavedDoctorHospital$HospitalArgs as SavedDoctorHospital$HospitalArgs, type prismaNamespace_SavedDoctorHospitalAggregateArgs as SavedDoctorHospitalAggregateArgs, type prismaNamespace_SavedDoctorHospitalCountAggregateInputType as SavedDoctorHospitalCountAggregateInputType, type prismaNamespace_SavedDoctorHospitalCountAggregateOutputType as SavedDoctorHospitalCountAggregateOutputType, type prismaNamespace_SavedDoctorHospitalCountArgs as SavedDoctorHospitalCountArgs, type prismaNamespace_SavedDoctorHospitalCountOrderByAggregateInput as SavedDoctorHospitalCountOrderByAggregateInput, type prismaNamespace_SavedDoctorHospitalCreateArgs as SavedDoctorHospitalCreateArgs, type prismaNamespace_SavedDoctorHospitalCreateInput as SavedDoctorHospitalCreateInput, type prismaNamespace_SavedDoctorHospitalCreateManyAndReturnArgs as SavedDoctorHospitalCreateManyAndReturnArgs, type prismaNamespace_SavedDoctorHospitalCreateManyArgs as SavedDoctorHospitalCreateManyArgs, type prismaNamespace_SavedDoctorHospitalCreateManyDoctorInput as SavedDoctorHospitalCreateManyDoctorInput, type prismaNamespace_SavedDoctorHospitalCreateManyDoctorInputEnvelope as SavedDoctorHospitalCreateManyDoctorInputEnvelope, type prismaNamespace_SavedDoctorHospitalCreateManyHospitalInput as SavedDoctorHospitalCreateManyHospitalInput, type prismaNamespace_SavedDoctorHospitalCreateManyHospitalInputEnvelope as SavedDoctorHospitalCreateManyHospitalInputEnvelope, type prismaNamespace_SavedDoctorHospitalCreateManyInput as SavedDoctorHospitalCreateManyInput, type prismaNamespace_SavedDoctorHospitalCreateManyUserInput as SavedDoctorHospitalCreateManyUserInput, type prismaNamespace_SavedDoctorHospitalCreateManyUserInputEnvelope as SavedDoctorHospitalCreateManyUserInputEnvelope, type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutDoctorInput as SavedDoctorHospitalCreateNestedManyWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutHospitalInput as SavedDoctorHospitalCreateNestedManyWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalCreateNestedManyWithoutUserInput as SavedDoctorHospitalCreateNestedManyWithoutUserInput, type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutDoctorInput as SavedDoctorHospitalCreateOrConnectWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutHospitalInput as SavedDoctorHospitalCreateOrConnectWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalCreateOrConnectWithoutUserInput as SavedDoctorHospitalCreateOrConnectWithoutUserInput, type prismaNamespace_SavedDoctorHospitalCreateWithoutDoctorInput as SavedDoctorHospitalCreateWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalCreateWithoutHospitalInput as SavedDoctorHospitalCreateWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalCreateWithoutUserInput as SavedDoctorHospitalCreateWithoutUserInput, type prismaNamespace_SavedDoctorHospitalDefaultArgs as SavedDoctorHospitalDefaultArgs, type prismaNamespace_SavedDoctorHospitalDelegate as SavedDoctorHospitalDelegate, type prismaNamespace_SavedDoctorHospitalDeleteArgs as SavedDoctorHospitalDeleteArgs, type prismaNamespace_SavedDoctorHospitalDeleteManyArgs as SavedDoctorHospitalDeleteManyArgs, type prismaNamespace_SavedDoctorHospitalFieldRefs as SavedDoctorHospitalFieldRefs, type prismaNamespace_SavedDoctorHospitalFindFirstArgs as SavedDoctorHospitalFindFirstArgs, type prismaNamespace_SavedDoctorHospitalFindFirstOrThrowArgs as SavedDoctorHospitalFindFirstOrThrowArgs, type prismaNamespace_SavedDoctorHospitalFindManyArgs as SavedDoctorHospitalFindManyArgs, type prismaNamespace_SavedDoctorHospitalFindUniqueArgs as SavedDoctorHospitalFindUniqueArgs, type prismaNamespace_SavedDoctorHospitalFindUniqueOrThrowArgs as SavedDoctorHospitalFindUniqueOrThrowArgs, type prismaNamespace_SavedDoctorHospitalGetPayload as SavedDoctorHospitalGetPayload, type prismaNamespace_SavedDoctorHospitalGroupByArgs as SavedDoctorHospitalGroupByArgs, type prismaNamespace_SavedDoctorHospitalGroupByOutputType as SavedDoctorHospitalGroupByOutputType, type prismaNamespace_SavedDoctorHospitalInclude as SavedDoctorHospitalInclude, type prismaNamespace_SavedDoctorHospitalIncludeCreateManyAndReturn as SavedDoctorHospitalIncludeCreateManyAndReturn, type prismaNamespace_SavedDoctorHospitalIncludeUpdateManyAndReturn as SavedDoctorHospitalIncludeUpdateManyAndReturn, type prismaNamespace_SavedDoctorHospitalListRelationFilter as SavedDoctorHospitalListRelationFilter, type prismaNamespace_SavedDoctorHospitalMaxAggregateInputType as SavedDoctorHospitalMaxAggregateInputType, type prismaNamespace_SavedDoctorHospitalMaxAggregateOutputType as SavedDoctorHospitalMaxAggregateOutputType, type prismaNamespace_SavedDoctorHospitalMaxOrderByAggregateInput as SavedDoctorHospitalMaxOrderByAggregateInput, type prismaNamespace_SavedDoctorHospitalMinAggregateInputType as SavedDoctorHospitalMinAggregateInputType, type prismaNamespace_SavedDoctorHospitalMinAggregateOutputType as SavedDoctorHospitalMinAggregateOutputType, type prismaNamespace_SavedDoctorHospitalMinOrderByAggregateInput as SavedDoctorHospitalMinOrderByAggregateInput, type prismaNamespace_SavedDoctorHospitalModel as SavedDoctorHospitalModel, type prismaNamespace_SavedDoctorHospitalOmit as SavedDoctorHospitalOmit, type prismaNamespace_SavedDoctorHospitalOrderByRelationAggregateInput as SavedDoctorHospitalOrderByRelationAggregateInput, type prismaNamespace_SavedDoctorHospitalOrderByWithAggregationInput as SavedDoctorHospitalOrderByWithAggregationInput, type prismaNamespace_SavedDoctorHospitalOrderByWithRelationInput as SavedDoctorHospitalOrderByWithRelationInput, type prismaNamespace_SavedDoctorHospitalScalarFieldEnum as SavedDoctorHospitalScalarFieldEnum, type prismaNamespace_SavedDoctorHospitalScalarWhereInput as SavedDoctorHospitalScalarWhereInput, type prismaNamespace_SavedDoctorHospitalScalarWhereWithAggregatesInput as SavedDoctorHospitalScalarWhereWithAggregatesInput, type prismaNamespace_SavedDoctorHospitalSelect as SavedDoctorHospitalSelect, type prismaNamespace_SavedDoctorHospitalSelectCreateManyAndReturn as SavedDoctorHospitalSelectCreateManyAndReturn, type prismaNamespace_SavedDoctorHospitalSelectScalar as SavedDoctorHospitalSelectScalar, type prismaNamespace_SavedDoctorHospitalSelectUpdateManyAndReturn as SavedDoctorHospitalSelectUpdateManyAndReturn, type prismaNamespace_SavedDoctorHospitalUncheckedCreateInput as SavedDoctorHospitalUncheckedCreateInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput as SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput as SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput as SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutDoctorInput as SavedDoctorHospitalUncheckedCreateWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutHospitalInput as SavedDoctorHospitalUncheckedCreateWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUncheckedCreateWithoutUserInput as SavedDoctorHospitalUncheckedCreateWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateInput as SavedDoctorHospitalUncheckedUpdateInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyInput as SavedDoctorHospitalUncheckedUpdateManyInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput as SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput as SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput as SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput as SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput as SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput as SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput as SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput as SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUncheckedUpdateWithoutUserInput as SavedDoctorHospitalUncheckedUpdateWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUpdateArgs as SavedDoctorHospitalUpdateArgs, type prismaNamespace_SavedDoctorHospitalUpdateInput as SavedDoctorHospitalUpdateInput, type prismaNamespace_SavedDoctorHospitalUpdateManyAndReturnArgs as SavedDoctorHospitalUpdateManyAndReturnArgs, type prismaNamespace_SavedDoctorHospitalUpdateManyArgs as SavedDoctorHospitalUpdateManyArgs, type prismaNamespace_SavedDoctorHospitalUpdateManyMutationInput as SavedDoctorHospitalUpdateManyMutationInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput as SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput as SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput as SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput as SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput as SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput, type prismaNamespace_SavedDoctorHospitalUpdateManyWithoutUserNestedInput as SavedDoctorHospitalUpdateManyWithoutUserNestedInput, type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput as SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput as SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput as SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUpdateWithoutDoctorInput as SavedDoctorHospitalUpdateWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUpdateWithoutHospitalInput as SavedDoctorHospitalUpdateWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUpdateWithoutUserInput as SavedDoctorHospitalUpdateWithoutUserInput, type prismaNamespace_SavedDoctorHospitalUpsertArgs as SavedDoctorHospitalUpsertArgs, type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput as SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput as SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput as SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_SavedDoctorHospitalWhereInput as SavedDoctorHospitalWhereInput, type prismaNamespace_SavedDoctorHospitalWhereUniqueInput as SavedDoctorHospitalWhereUniqueInput, type prismaNamespace_Schedule$AppointmentArgs as Schedule$AppointmentArgs, type prismaNamespace_Schedule$SlotArgs as Schedule$SlotArgs, type prismaNamespace_ScheduleAggregateArgs as ScheduleAggregateArgs, type prismaNamespace_ScheduleAvgAggregateInputType as ScheduleAvgAggregateInputType, type prismaNamespace_ScheduleAvgAggregateOutputType as ScheduleAvgAggregateOutputType, type prismaNamespace_ScheduleAvgOrderByAggregateInput as ScheduleAvgOrderByAggregateInput, type prismaNamespace_ScheduleCountAggregateInputType as ScheduleCountAggregateInputType, type prismaNamespace_ScheduleCountAggregateOutputType as ScheduleCountAggregateOutputType, type prismaNamespace_ScheduleCountArgs as ScheduleCountArgs, type prismaNamespace_ScheduleCountOrderByAggregateInput as ScheduleCountOrderByAggregateInput, type prismaNamespace_ScheduleCountOutputType as ScheduleCountOutputType, type prismaNamespace_ScheduleCountOutputTypeCountAppointmentArgs as ScheduleCountOutputTypeCountAppointmentArgs, type prismaNamespace_ScheduleCountOutputTypeCountSlotArgs as ScheduleCountOutputTypeCountSlotArgs, type prismaNamespace_ScheduleCountOutputTypeDefaultArgs as ScheduleCountOutputTypeDefaultArgs, type prismaNamespace_ScheduleCountOutputTypeSelect as ScheduleCountOutputTypeSelect, type prismaNamespace_ScheduleCreateArgs as ScheduleCreateArgs, type prismaNamespace_ScheduleCreateInput as ScheduleCreateInput, type prismaNamespace_ScheduleCreateManyAndReturnArgs as ScheduleCreateManyAndReturnArgs, type prismaNamespace_ScheduleCreateManyArgs as ScheduleCreateManyArgs, type prismaNamespace_ScheduleCreateManyDoctorInput as ScheduleCreateManyDoctorInput, type prismaNamespace_ScheduleCreateManyDoctorInputEnvelope as ScheduleCreateManyDoctorInputEnvelope, type prismaNamespace_ScheduleCreateManyHospitalInput as ScheduleCreateManyHospitalInput, type prismaNamespace_ScheduleCreateManyHospitalInputEnvelope as ScheduleCreateManyHospitalInputEnvelope, type prismaNamespace_ScheduleCreateManyInput as ScheduleCreateManyInput, type prismaNamespace_ScheduleCreateManyUserInput as ScheduleCreateManyUserInput, type prismaNamespace_ScheduleCreateManyUserInputEnvelope as ScheduleCreateManyUserInputEnvelope, type prismaNamespace_ScheduleCreateNestedManyWithoutDoctorInput as ScheduleCreateNestedManyWithoutDoctorInput, type prismaNamespace_ScheduleCreateNestedManyWithoutHospitalInput as ScheduleCreateNestedManyWithoutHospitalInput, type prismaNamespace_ScheduleCreateNestedManyWithoutUserInput as ScheduleCreateNestedManyWithoutUserInput, type prismaNamespace_ScheduleCreateNestedOneWithoutAppointmentInput as ScheduleCreateNestedOneWithoutAppointmentInput, type prismaNamespace_ScheduleCreateNestedOneWithoutSlotInput as ScheduleCreateNestedOneWithoutSlotInput, type prismaNamespace_ScheduleCreateOrConnectWithoutAppointmentInput as ScheduleCreateOrConnectWithoutAppointmentInput, type prismaNamespace_ScheduleCreateOrConnectWithoutDoctorInput as ScheduleCreateOrConnectWithoutDoctorInput, type prismaNamespace_ScheduleCreateOrConnectWithoutHospitalInput as ScheduleCreateOrConnectWithoutHospitalInput, type prismaNamespace_ScheduleCreateOrConnectWithoutSlotInput as ScheduleCreateOrConnectWithoutSlotInput, type prismaNamespace_ScheduleCreateOrConnectWithoutUserInput as ScheduleCreateOrConnectWithoutUserInput, type prismaNamespace_ScheduleCreateWithoutAppointmentInput as ScheduleCreateWithoutAppointmentInput, type prismaNamespace_ScheduleCreateWithoutDoctorInput as ScheduleCreateWithoutDoctorInput, type prismaNamespace_ScheduleCreateWithoutHospitalInput as ScheduleCreateWithoutHospitalInput, type prismaNamespace_ScheduleCreateWithoutSlotInput as ScheduleCreateWithoutSlotInput, type prismaNamespace_ScheduleCreateWithoutUserInput as ScheduleCreateWithoutUserInput, type prismaNamespace_ScheduleCreatedayOfWeekInput as ScheduleCreatedayOfWeekInput, type prismaNamespace_ScheduleDefaultArgs as ScheduleDefaultArgs, type prismaNamespace_ScheduleDelegate as ScheduleDelegate, type prismaNamespace_ScheduleDeleteArgs as ScheduleDeleteArgs, type prismaNamespace_ScheduleDeleteManyArgs as ScheduleDeleteManyArgs, type prismaNamespace_ScheduleFieldRefs as ScheduleFieldRefs, type prismaNamespace_ScheduleFindFirstArgs as ScheduleFindFirstArgs, type prismaNamespace_ScheduleFindFirstOrThrowArgs as ScheduleFindFirstOrThrowArgs, type prismaNamespace_ScheduleFindManyArgs as ScheduleFindManyArgs, type prismaNamespace_ScheduleFindUniqueArgs as ScheduleFindUniqueArgs, type prismaNamespace_ScheduleFindUniqueOrThrowArgs as ScheduleFindUniqueOrThrowArgs, type prismaNamespace_ScheduleGetPayload as ScheduleGetPayload, type prismaNamespace_ScheduleGroupByArgs as ScheduleGroupByArgs, type prismaNamespace_ScheduleGroupByOutputType as ScheduleGroupByOutputType, type prismaNamespace_ScheduleInclude as ScheduleInclude, type prismaNamespace_ScheduleIncludeCreateManyAndReturn as ScheduleIncludeCreateManyAndReturn, type prismaNamespace_ScheduleIncludeUpdateManyAndReturn as ScheduleIncludeUpdateManyAndReturn, type prismaNamespace_ScheduleListRelationFilter as ScheduleListRelationFilter, type prismaNamespace_ScheduleMaxAggregateInputType as ScheduleMaxAggregateInputType, type prismaNamespace_ScheduleMaxAggregateOutputType as ScheduleMaxAggregateOutputType, type prismaNamespace_ScheduleMaxOrderByAggregateInput as ScheduleMaxOrderByAggregateInput, type prismaNamespace_ScheduleMinAggregateInputType as ScheduleMinAggregateInputType, type prismaNamespace_ScheduleMinAggregateOutputType as ScheduleMinAggregateOutputType, type prismaNamespace_ScheduleMinOrderByAggregateInput as ScheduleMinOrderByAggregateInput, type prismaNamespace_ScheduleModel as ScheduleModel, type prismaNamespace_ScheduleOmit as ScheduleOmit, type prismaNamespace_ScheduleOrderByRelationAggregateInput as ScheduleOrderByRelationAggregateInput, type prismaNamespace_ScheduleOrderByWithAggregationInput as ScheduleOrderByWithAggregationInput, type prismaNamespace_ScheduleOrderByWithRelationInput as ScheduleOrderByWithRelationInput, type prismaNamespace_ScheduleScalarFieldEnum as ScheduleScalarFieldEnum, type prismaNamespace_ScheduleScalarRelationFilter as ScheduleScalarRelationFilter, type prismaNamespace_ScheduleScalarWhereInput as ScheduleScalarWhereInput, type prismaNamespace_ScheduleScalarWhereWithAggregatesInput as ScheduleScalarWhereWithAggregatesInput, type prismaNamespace_ScheduleSelect as ScheduleSelect, type prismaNamespace_ScheduleSelectCreateManyAndReturn as ScheduleSelectCreateManyAndReturn, type prismaNamespace_ScheduleSelectScalar as ScheduleSelectScalar, type prismaNamespace_ScheduleSelectUpdateManyAndReturn as ScheduleSelectUpdateManyAndReturn, type prismaNamespace_ScheduleSumAggregateInputType as ScheduleSumAggregateInputType, type prismaNamespace_ScheduleSumAggregateOutputType as ScheduleSumAggregateOutputType, type prismaNamespace_ScheduleSumOrderByAggregateInput as ScheduleSumOrderByAggregateInput, type prismaNamespace_ScheduleUncheckedCreateInput as ScheduleUncheckedCreateInput, type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutDoctorInput as ScheduleUncheckedCreateNestedManyWithoutDoctorInput, type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutHospitalInput as ScheduleUncheckedCreateNestedManyWithoutHospitalInput, type prismaNamespace_ScheduleUncheckedCreateNestedManyWithoutUserInput as ScheduleUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_ScheduleUncheckedCreateWithoutAppointmentInput as ScheduleUncheckedCreateWithoutAppointmentInput, type prismaNamespace_ScheduleUncheckedCreateWithoutDoctorInput as ScheduleUncheckedCreateWithoutDoctorInput, type prismaNamespace_ScheduleUncheckedCreateWithoutHospitalInput as ScheduleUncheckedCreateWithoutHospitalInput, type prismaNamespace_ScheduleUncheckedCreateWithoutSlotInput as ScheduleUncheckedCreateWithoutSlotInput, type prismaNamespace_ScheduleUncheckedCreateWithoutUserInput as ScheduleUncheckedCreateWithoutUserInput, type prismaNamespace_ScheduleUncheckedUpdateInput as ScheduleUncheckedUpdateInput, type prismaNamespace_ScheduleUncheckedUpdateManyInput as ScheduleUncheckedUpdateManyInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutDoctorInput as ScheduleUncheckedUpdateManyWithoutDoctorInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutDoctorNestedInput as ScheduleUncheckedUpdateManyWithoutDoctorNestedInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutHospitalInput as ScheduleUncheckedUpdateManyWithoutHospitalInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutHospitalNestedInput as ScheduleUncheckedUpdateManyWithoutHospitalNestedInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutUserInput as ScheduleUncheckedUpdateManyWithoutUserInput, type prismaNamespace_ScheduleUncheckedUpdateManyWithoutUserNestedInput as ScheduleUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_ScheduleUncheckedUpdateWithoutAppointmentInput as ScheduleUncheckedUpdateWithoutAppointmentInput, type prismaNamespace_ScheduleUncheckedUpdateWithoutDoctorInput as ScheduleUncheckedUpdateWithoutDoctorInput, type prismaNamespace_ScheduleUncheckedUpdateWithoutHospitalInput as ScheduleUncheckedUpdateWithoutHospitalInput, type prismaNamespace_ScheduleUncheckedUpdateWithoutSlotInput as ScheduleUncheckedUpdateWithoutSlotInput, type prismaNamespace_ScheduleUncheckedUpdateWithoutUserInput as ScheduleUncheckedUpdateWithoutUserInput, type prismaNamespace_ScheduleUpdateArgs as ScheduleUpdateArgs, type prismaNamespace_ScheduleUpdateInput as ScheduleUpdateInput, type prismaNamespace_ScheduleUpdateManyAndReturnArgs as ScheduleUpdateManyAndReturnArgs, type prismaNamespace_ScheduleUpdateManyArgs as ScheduleUpdateManyArgs, type prismaNamespace_ScheduleUpdateManyMutationInput as ScheduleUpdateManyMutationInput, type prismaNamespace_ScheduleUpdateManyWithWhereWithoutDoctorInput as ScheduleUpdateManyWithWhereWithoutDoctorInput, type prismaNamespace_ScheduleUpdateManyWithWhereWithoutHospitalInput as ScheduleUpdateManyWithWhereWithoutHospitalInput, type prismaNamespace_ScheduleUpdateManyWithWhereWithoutUserInput as ScheduleUpdateManyWithWhereWithoutUserInput, type prismaNamespace_ScheduleUpdateManyWithoutDoctorNestedInput as ScheduleUpdateManyWithoutDoctorNestedInput, type prismaNamespace_ScheduleUpdateManyWithoutHospitalNestedInput as ScheduleUpdateManyWithoutHospitalNestedInput, type prismaNamespace_ScheduleUpdateManyWithoutUserNestedInput as ScheduleUpdateManyWithoutUserNestedInput, type prismaNamespace_ScheduleUpdateOneRequiredWithoutAppointmentNestedInput as ScheduleUpdateOneRequiredWithoutAppointmentNestedInput, type prismaNamespace_ScheduleUpdateOneRequiredWithoutSlotNestedInput as ScheduleUpdateOneRequiredWithoutSlotNestedInput, type prismaNamespace_ScheduleUpdateToOneWithWhereWithoutAppointmentInput as ScheduleUpdateToOneWithWhereWithoutAppointmentInput, type prismaNamespace_ScheduleUpdateToOneWithWhereWithoutSlotInput as ScheduleUpdateToOneWithWhereWithoutSlotInput, type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutDoctorInput as ScheduleUpdateWithWhereUniqueWithoutDoctorInput, type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutHospitalInput as ScheduleUpdateWithWhereUniqueWithoutHospitalInput, type prismaNamespace_ScheduleUpdateWithWhereUniqueWithoutUserInput as ScheduleUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_ScheduleUpdateWithoutAppointmentInput as ScheduleUpdateWithoutAppointmentInput, type prismaNamespace_ScheduleUpdateWithoutDoctorInput as ScheduleUpdateWithoutDoctorInput, type prismaNamespace_ScheduleUpdateWithoutHospitalInput as ScheduleUpdateWithoutHospitalInput, type prismaNamespace_ScheduleUpdateWithoutSlotInput as ScheduleUpdateWithoutSlotInput, type prismaNamespace_ScheduleUpdateWithoutUserInput as ScheduleUpdateWithoutUserInput, type prismaNamespace_ScheduleUpdatedayOfWeekInput as ScheduleUpdatedayOfWeekInput, type prismaNamespace_ScheduleUpsertArgs as ScheduleUpsertArgs, type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutDoctorInput as ScheduleUpsertWithWhereUniqueWithoutDoctorInput, type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutHospitalInput as ScheduleUpsertWithWhereUniqueWithoutHospitalInput, type prismaNamespace_ScheduleUpsertWithWhereUniqueWithoutUserInput as ScheduleUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_ScheduleUpsertWithoutAppointmentInput as ScheduleUpsertWithoutAppointmentInput, type prismaNamespace_ScheduleUpsertWithoutSlotInput as ScheduleUpsertWithoutSlotInput, type prismaNamespace_ScheduleWhereInput as ScheduleWhereInput, type prismaNamespace_ScheduleWhereUniqueInput as ScheduleWhereUniqueInput, type prismaNamespace_SearchLogAggregateArgs as SearchLogAggregateArgs, type prismaNamespace_SearchLogCountAggregateInputType as SearchLogCountAggregateInputType, type prismaNamespace_SearchLogCountAggregateOutputType as SearchLogCountAggregateOutputType, type prismaNamespace_SearchLogCountArgs as SearchLogCountArgs, type prismaNamespace_SearchLogCountOrderByAggregateInput as SearchLogCountOrderByAggregateInput, type prismaNamespace_SearchLogCreateArgs as SearchLogCreateArgs, type prismaNamespace_SearchLogCreateInput as SearchLogCreateInput, type prismaNamespace_SearchLogCreateManyAndReturnArgs as SearchLogCreateManyAndReturnArgs, type prismaNamespace_SearchLogCreateManyArgs as SearchLogCreateManyArgs, type prismaNamespace_SearchLogCreateManyInput as SearchLogCreateManyInput, type prismaNamespace_SearchLogCreateManyUserInput as SearchLogCreateManyUserInput, type prismaNamespace_SearchLogCreateManyUserInputEnvelope as SearchLogCreateManyUserInputEnvelope, type prismaNamespace_SearchLogCreateNestedManyWithoutUserInput as SearchLogCreateNestedManyWithoutUserInput, type prismaNamespace_SearchLogCreateOrConnectWithoutUserInput as SearchLogCreateOrConnectWithoutUserInput, type prismaNamespace_SearchLogCreateWithoutUserInput as SearchLogCreateWithoutUserInput, type prismaNamespace_SearchLogDefaultArgs as SearchLogDefaultArgs, type prismaNamespace_SearchLogDelegate as SearchLogDelegate, type prismaNamespace_SearchLogDeleteArgs as SearchLogDeleteArgs, type prismaNamespace_SearchLogDeleteManyArgs as SearchLogDeleteManyArgs, type prismaNamespace_SearchLogFieldRefs as SearchLogFieldRefs, type prismaNamespace_SearchLogFindFirstArgs as SearchLogFindFirstArgs, type prismaNamespace_SearchLogFindFirstOrThrowArgs as SearchLogFindFirstOrThrowArgs, type prismaNamespace_SearchLogFindManyArgs as SearchLogFindManyArgs, type prismaNamespace_SearchLogFindUniqueArgs as SearchLogFindUniqueArgs, type prismaNamespace_SearchLogFindUniqueOrThrowArgs as SearchLogFindUniqueOrThrowArgs, type prismaNamespace_SearchLogGetPayload as SearchLogGetPayload, type prismaNamespace_SearchLogGroupByArgs as SearchLogGroupByArgs, type prismaNamespace_SearchLogGroupByOutputType as SearchLogGroupByOutputType, type prismaNamespace_SearchLogInclude as SearchLogInclude, type prismaNamespace_SearchLogIncludeCreateManyAndReturn as SearchLogIncludeCreateManyAndReturn, type prismaNamespace_SearchLogIncludeUpdateManyAndReturn as SearchLogIncludeUpdateManyAndReturn, type prismaNamespace_SearchLogListRelationFilter as SearchLogListRelationFilter, type prismaNamespace_SearchLogMaxAggregateInputType as SearchLogMaxAggregateInputType, type prismaNamespace_SearchLogMaxAggregateOutputType as SearchLogMaxAggregateOutputType, type prismaNamespace_SearchLogMaxOrderByAggregateInput as SearchLogMaxOrderByAggregateInput, type prismaNamespace_SearchLogMinAggregateInputType as SearchLogMinAggregateInputType, type prismaNamespace_SearchLogMinAggregateOutputType as SearchLogMinAggregateOutputType, type prismaNamespace_SearchLogMinOrderByAggregateInput as SearchLogMinOrderByAggregateInput, type prismaNamespace_SearchLogModel as SearchLogModel, type prismaNamespace_SearchLogOmit as SearchLogOmit, type prismaNamespace_SearchLogOrderByRelationAggregateInput as SearchLogOrderByRelationAggregateInput, type prismaNamespace_SearchLogOrderByWithAggregationInput as SearchLogOrderByWithAggregationInput, type prismaNamespace_SearchLogOrderByWithRelationInput as SearchLogOrderByWithRelationInput, type prismaNamespace_SearchLogScalarFieldEnum as SearchLogScalarFieldEnum, type prismaNamespace_SearchLogScalarWhereInput as SearchLogScalarWhereInput, type prismaNamespace_SearchLogScalarWhereWithAggregatesInput as SearchLogScalarWhereWithAggregatesInput, type prismaNamespace_SearchLogSelect as SearchLogSelect, type prismaNamespace_SearchLogSelectCreateManyAndReturn as SearchLogSelectCreateManyAndReturn, type prismaNamespace_SearchLogSelectScalar as SearchLogSelectScalar, type prismaNamespace_SearchLogSelectUpdateManyAndReturn as SearchLogSelectUpdateManyAndReturn, type prismaNamespace_SearchLogUncheckedCreateInput as SearchLogUncheckedCreateInput, type prismaNamespace_SearchLogUncheckedCreateNestedManyWithoutUserInput as SearchLogUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_SearchLogUncheckedCreateWithoutUserInput as SearchLogUncheckedCreateWithoutUserInput, type prismaNamespace_SearchLogUncheckedUpdateInput as SearchLogUncheckedUpdateInput, type prismaNamespace_SearchLogUncheckedUpdateManyInput as SearchLogUncheckedUpdateManyInput, type prismaNamespace_SearchLogUncheckedUpdateManyWithoutUserInput as SearchLogUncheckedUpdateManyWithoutUserInput, type prismaNamespace_SearchLogUncheckedUpdateManyWithoutUserNestedInput as SearchLogUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_SearchLogUncheckedUpdateWithoutUserInput as SearchLogUncheckedUpdateWithoutUserInput, type prismaNamespace_SearchLogUpdateArgs as SearchLogUpdateArgs, type prismaNamespace_SearchLogUpdateInput as SearchLogUpdateInput, type prismaNamespace_SearchLogUpdateManyAndReturnArgs as SearchLogUpdateManyAndReturnArgs, type prismaNamespace_SearchLogUpdateManyArgs as SearchLogUpdateManyArgs, type prismaNamespace_SearchLogUpdateManyMutationInput as SearchLogUpdateManyMutationInput, type prismaNamespace_SearchLogUpdateManyWithWhereWithoutUserInput as SearchLogUpdateManyWithWhereWithoutUserInput, type prismaNamespace_SearchLogUpdateManyWithoutUserNestedInput as SearchLogUpdateManyWithoutUserNestedInput, type prismaNamespace_SearchLogUpdateWithWhereUniqueWithoutUserInput as SearchLogUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_SearchLogUpdateWithoutUserInput as SearchLogUpdateWithoutUserInput, type prismaNamespace_SearchLogUpsertArgs as SearchLogUpsertArgs, type prismaNamespace_SearchLogUpsertWithWhereUniqueWithoutUserInput as SearchLogUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_SearchLogWhereInput as SearchLogWhereInput, type prismaNamespace_SearchLogWhereUniqueInput as SearchLogWhereUniqueInput, type prismaNamespace_SelectSubset as SelectSubset, type prismaNamespace_SessionAggregateArgs as SessionAggregateArgs, type prismaNamespace_SessionCountAggregateInputType as SessionCountAggregateInputType, type prismaNamespace_SessionCountAggregateOutputType as SessionCountAggregateOutputType, type prismaNamespace_SessionGroupByOutputType as SessionGroupByOutputType, type prismaNamespace_SessionListRelationFilter as SessionListRelationFilter, type prismaNamespace_SessionMaxAggregateInputType as SessionMaxAggregateInputType, type prismaNamespace_SessionMaxAggregateOutputType as SessionMaxAggregateOutputType, type prismaNamespace_SessionMinAggregateInputType as SessionMinAggregateInputType, type prismaNamespace_SessionMinAggregateOutputType as SessionMinAggregateOutputType, type prismaNamespace_SessionScalarFieldEnum as SessionScalarFieldEnum, type prismaNamespace_Slot$AppointmentArgs as Slot$AppointmentArgs, type prismaNamespace_SlotAggregateArgs as SlotAggregateArgs, type prismaNamespace_SlotCountAggregateInputType as SlotCountAggregateInputType, type prismaNamespace_SlotCountAggregateOutputType as SlotCountAggregateOutputType, type prismaNamespace_SlotCountArgs as SlotCountArgs, type prismaNamespace_SlotCountOrderByAggregateInput as SlotCountOrderByAggregateInput, type prismaNamespace_SlotCreateArgs as SlotCreateArgs, type prismaNamespace_SlotCreateInput as SlotCreateInput, type prismaNamespace_SlotCreateManyAndReturnArgs as SlotCreateManyAndReturnArgs, type prismaNamespace_SlotCreateManyArgs as SlotCreateManyArgs, type prismaNamespace_SlotCreateManyInput as SlotCreateManyInput, type prismaNamespace_SlotCreateManyScheduleInput as SlotCreateManyScheduleInput, type prismaNamespace_SlotCreateManyScheduleInputEnvelope as SlotCreateManyScheduleInputEnvelope, type prismaNamespace_SlotCreateNestedManyWithoutScheduleInput as SlotCreateNestedManyWithoutScheduleInput, type prismaNamespace_SlotCreateNestedOneWithoutAppointmentInput as SlotCreateNestedOneWithoutAppointmentInput, type prismaNamespace_SlotCreateOrConnectWithoutAppointmentInput as SlotCreateOrConnectWithoutAppointmentInput, type prismaNamespace_SlotCreateOrConnectWithoutScheduleInput as SlotCreateOrConnectWithoutScheduleInput, type prismaNamespace_SlotCreateWithoutAppointmentInput as SlotCreateWithoutAppointmentInput, type prismaNamespace_SlotCreateWithoutScheduleInput as SlotCreateWithoutScheduleInput, type prismaNamespace_SlotDefaultArgs as SlotDefaultArgs, type prismaNamespace_SlotDelegate as SlotDelegate, type prismaNamespace_SlotDeleteArgs as SlotDeleteArgs, type prismaNamespace_SlotDeleteManyArgs as SlotDeleteManyArgs, type prismaNamespace_SlotFieldRefs as SlotFieldRefs, type prismaNamespace_SlotFindFirstArgs as SlotFindFirstArgs, type prismaNamespace_SlotFindFirstOrThrowArgs as SlotFindFirstOrThrowArgs, type prismaNamespace_SlotFindManyArgs as SlotFindManyArgs, type prismaNamespace_SlotFindUniqueArgs as SlotFindUniqueArgs, type prismaNamespace_SlotFindUniqueOrThrowArgs as SlotFindUniqueOrThrowArgs, type prismaNamespace_SlotGetPayload as SlotGetPayload, type prismaNamespace_SlotGroupByArgs as SlotGroupByArgs, type prismaNamespace_SlotGroupByOutputType as SlotGroupByOutputType, type prismaNamespace_SlotInclude as SlotInclude, type prismaNamespace_SlotIncludeCreateManyAndReturn as SlotIncludeCreateManyAndReturn, type prismaNamespace_SlotIncludeUpdateManyAndReturn as SlotIncludeUpdateManyAndReturn, type prismaNamespace_SlotListRelationFilter as SlotListRelationFilter, type prismaNamespace_SlotMaxAggregateInputType as SlotMaxAggregateInputType, type prismaNamespace_SlotMaxAggregateOutputType as SlotMaxAggregateOutputType, type prismaNamespace_SlotMaxOrderByAggregateInput as SlotMaxOrderByAggregateInput, type prismaNamespace_SlotMinAggregateInputType as SlotMinAggregateInputType, type prismaNamespace_SlotMinAggregateOutputType as SlotMinAggregateOutputType, type prismaNamespace_SlotMinOrderByAggregateInput as SlotMinOrderByAggregateInput, type prismaNamespace_SlotModel as SlotModel, type prismaNamespace_SlotNullableScalarRelationFilter as SlotNullableScalarRelationFilter, type prismaNamespace_SlotOmit as SlotOmit, type prismaNamespace_SlotOrderByRelationAggregateInput as SlotOrderByRelationAggregateInput, type prismaNamespace_SlotOrderByWithAggregationInput as SlotOrderByWithAggregationInput, type prismaNamespace_SlotOrderByWithRelationInput as SlotOrderByWithRelationInput, type prismaNamespace_SlotScalarFieldEnum as SlotScalarFieldEnum, type prismaNamespace_SlotScalarWhereInput as SlotScalarWhereInput, type prismaNamespace_SlotScalarWhereWithAggregatesInput as SlotScalarWhereWithAggregatesInput, type prismaNamespace_SlotSelect as SlotSelect, type prismaNamespace_SlotSelectCreateManyAndReturn as SlotSelectCreateManyAndReturn, type prismaNamespace_SlotSelectScalar as SlotSelectScalar, type prismaNamespace_SlotSelectUpdateManyAndReturn as SlotSelectUpdateManyAndReturn, type prismaNamespace_SlotSlotStartScheduleIdDateCompoundUniqueInput as SlotSlotStartScheduleIdDateCompoundUniqueInput, type prismaNamespace_SlotUncheckedCreateInput as SlotUncheckedCreateInput, type prismaNamespace_SlotUncheckedCreateNestedManyWithoutScheduleInput as SlotUncheckedCreateNestedManyWithoutScheduleInput, type prismaNamespace_SlotUncheckedCreateNestedOneWithoutAppointmentInput as SlotUncheckedCreateNestedOneWithoutAppointmentInput, type prismaNamespace_SlotUncheckedCreateWithoutAppointmentInput as SlotUncheckedCreateWithoutAppointmentInput, type prismaNamespace_SlotUncheckedCreateWithoutScheduleInput as SlotUncheckedCreateWithoutScheduleInput, type prismaNamespace_SlotUncheckedUpdateInput as SlotUncheckedUpdateInput, type prismaNamespace_SlotUncheckedUpdateManyInput as SlotUncheckedUpdateManyInput, type prismaNamespace_SlotUncheckedUpdateManyWithoutScheduleInput as SlotUncheckedUpdateManyWithoutScheduleInput, type prismaNamespace_SlotUncheckedUpdateManyWithoutScheduleNestedInput as SlotUncheckedUpdateManyWithoutScheduleNestedInput, type prismaNamespace_SlotUncheckedUpdateOneWithoutAppointmentNestedInput as SlotUncheckedUpdateOneWithoutAppointmentNestedInput, type prismaNamespace_SlotUncheckedUpdateWithoutAppointmentInput as SlotUncheckedUpdateWithoutAppointmentInput, type prismaNamespace_SlotUncheckedUpdateWithoutScheduleInput as SlotUncheckedUpdateWithoutScheduleInput, type prismaNamespace_SlotUpdateArgs as SlotUpdateArgs, type prismaNamespace_SlotUpdateInput as SlotUpdateInput, type prismaNamespace_SlotUpdateManyAndReturnArgs as SlotUpdateManyAndReturnArgs, type prismaNamespace_SlotUpdateManyArgs as SlotUpdateManyArgs, type prismaNamespace_SlotUpdateManyMutationInput as SlotUpdateManyMutationInput, type prismaNamespace_SlotUpdateManyWithWhereWithoutScheduleInput as SlotUpdateManyWithWhereWithoutScheduleInput, type prismaNamespace_SlotUpdateManyWithoutScheduleNestedInput as SlotUpdateManyWithoutScheduleNestedInput, type prismaNamespace_SlotUpdateOneWithoutAppointmentNestedInput as SlotUpdateOneWithoutAppointmentNestedInput, type prismaNamespace_SlotUpdateToOneWithWhereWithoutAppointmentInput as SlotUpdateToOneWithWhereWithoutAppointmentInput, type prismaNamespace_SlotUpdateWithWhereUniqueWithoutScheduleInput as SlotUpdateWithWhereUniqueWithoutScheduleInput, type prismaNamespace_SlotUpdateWithoutAppointmentInput as SlotUpdateWithoutAppointmentInput, type prismaNamespace_SlotUpdateWithoutScheduleInput as SlotUpdateWithoutScheduleInput, type prismaNamespace_SlotUpsertArgs as SlotUpsertArgs, type prismaNamespace_SlotUpsertWithWhereUniqueWithoutScheduleInput as SlotUpsertWithWhereUniqueWithoutScheduleInput, type prismaNamespace_SlotUpsertWithoutAppointmentInput as SlotUpsertWithoutAppointmentInput, type prismaNamespace_SlotWhereInput as SlotWhereInput, type prismaNamespace_SlotWhereUniqueInput as SlotWhereUniqueInput, type prismaNamespace_SortOrder as SortOrder, type prismaNamespace_SortOrderInput as SortOrderInput, type prismaNamespace_Specialization$DoctorSpecializationArgs as Specialization$DoctorSpecializationArgs, type prismaNamespace_Specialization$HospitalSpecializationArgs as Specialization$HospitalSpecializationArgs, type prismaNamespace_SpecializationAggregateArgs as SpecializationAggregateArgs, type prismaNamespace_SpecializationCountAggregateInputType as SpecializationCountAggregateInputType, type prismaNamespace_SpecializationCountAggregateOutputType as SpecializationCountAggregateOutputType, type prismaNamespace_SpecializationCountArgs as SpecializationCountArgs, type prismaNamespace_SpecializationCountOrderByAggregateInput as SpecializationCountOrderByAggregateInput, type prismaNamespace_SpecializationCountOutputType as SpecializationCountOutputType, type prismaNamespace_SpecializationCountOutputTypeCountDoctorSpecializationArgs as SpecializationCountOutputTypeCountDoctorSpecializationArgs, type prismaNamespace_SpecializationCountOutputTypeCountHospitalSpecializationArgs as SpecializationCountOutputTypeCountHospitalSpecializationArgs, type prismaNamespace_SpecializationCountOutputTypeDefaultArgs as SpecializationCountOutputTypeDefaultArgs, type prismaNamespace_SpecializationCountOutputTypeSelect as SpecializationCountOutputTypeSelect, type prismaNamespace_SpecializationCreateArgs as SpecializationCreateArgs, type prismaNamespace_SpecializationCreateInput as SpecializationCreateInput, type prismaNamespace_SpecializationCreateManyAndReturnArgs as SpecializationCreateManyAndReturnArgs, type prismaNamespace_SpecializationCreateManyArgs as SpecializationCreateManyArgs, type prismaNamespace_SpecializationCreateManyInput as SpecializationCreateManyInput, type prismaNamespace_SpecializationCreateNestedOneWithoutDoctorSpecializationInput as SpecializationCreateNestedOneWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationCreateNestedOneWithoutHospitalSpecializationInput as SpecializationCreateNestedOneWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationCreateOrConnectWithoutDoctorSpecializationInput as SpecializationCreateOrConnectWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationCreateOrConnectWithoutHospitalSpecializationInput as SpecializationCreateOrConnectWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationCreateWithoutDoctorSpecializationInput as SpecializationCreateWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationCreateWithoutHospitalSpecializationInput as SpecializationCreateWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationDefaultArgs as SpecializationDefaultArgs, type prismaNamespace_SpecializationDelegate as SpecializationDelegate, type prismaNamespace_SpecializationDeleteArgs as SpecializationDeleteArgs, type prismaNamespace_SpecializationDeleteManyArgs as SpecializationDeleteManyArgs, type prismaNamespace_SpecializationFieldRefs as SpecializationFieldRefs, type prismaNamespace_SpecializationFindFirstArgs as SpecializationFindFirstArgs, type prismaNamespace_SpecializationFindFirstOrThrowArgs as SpecializationFindFirstOrThrowArgs, type prismaNamespace_SpecializationFindManyArgs as SpecializationFindManyArgs, type prismaNamespace_SpecializationFindUniqueArgs as SpecializationFindUniqueArgs, type prismaNamespace_SpecializationFindUniqueOrThrowArgs as SpecializationFindUniqueOrThrowArgs, type prismaNamespace_SpecializationGetPayload as SpecializationGetPayload, type prismaNamespace_SpecializationGroupByArgs as SpecializationGroupByArgs, type prismaNamespace_SpecializationGroupByOutputType as SpecializationGroupByOutputType, type prismaNamespace_SpecializationInclude as SpecializationInclude, type prismaNamespace_SpecializationIncludeCreateManyAndReturn as SpecializationIncludeCreateManyAndReturn, type prismaNamespace_SpecializationIncludeUpdateManyAndReturn as SpecializationIncludeUpdateManyAndReturn, type prismaNamespace_SpecializationMaxAggregateInputType as SpecializationMaxAggregateInputType, type prismaNamespace_SpecializationMaxAggregateOutputType as SpecializationMaxAggregateOutputType, type prismaNamespace_SpecializationMaxOrderByAggregateInput as SpecializationMaxOrderByAggregateInput, type prismaNamespace_SpecializationMinAggregateInputType as SpecializationMinAggregateInputType, type prismaNamespace_SpecializationMinAggregateOutputType as SpecializationMinAggregateOutputType, type prismaNamespace_SpecializationMinOrderByAggregateInput as SpecializationMinOrderByAggregateInput, type prismaNamespace_SpecializationModel as SpecializationModel, type prismaNamespace_SpecializationOmit as SpecializationOmit, type prismaNamespace_SpecializationOrderByWithAggregationInput as SpecializationOrderByWithAggregationInput, type prismaNamespace_SpecializationOrderByWithRelationInput as SpecializationOrderByWithRelationInput, type prismaNamespace_SpecializationScalarFieldEnum as SpecializationScalarFieldEnum, type prismaNamespace_SpecializationScalarRelationFilter as SpecializationScalarRelationFilter, type prismaNamespace_SpecializationScalarWhereWithAggregatesInput as SpecializationScalarWhereWithAggregatesInput, type prismaNamespace_SpecializationSelect as SpecializationSelect, type prismaNamespace_SpecializationSelectCreateManyAndReturn as SpecializationSelectCreateManyAndReturn, type prismaNamespace_SpecializationSelectScalar as SpecializationSelectScalar, type prismaNamespace_SpecializationSelectUpdateManyAndReturn as SpecializationSelectUpdateManyAndReturn, type prismaNamespace_SpecializationUncheckedCreateInput as SpecializationUncheckedCreateInput, type prismaNamespace_SpecializationUncheckedCreateWithoutDoctorSpecializationInput as SpecializationUncheckedCreateWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationUncheckedCreateWithoutHospitalSpecializationInput as SpecializationUncheckedCreateWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationUncheckedUpdateInput as SpecializationUncheckedUpdateInput, type prismaNamespace_SpecializationUncheckedUpdateManyInput as SpecializationUncheckedUpdateManyInput, type prismaNamespace_SpecializationUncheckedUpdateWithoutDoctorSpecializationInput as SpecializationUncheckedUpdateWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationUncheckedUpdateWithoutHospitalSpecializationInput as SpecializationUncheckedUpdateWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationUpdateArgs as SpecializationUpdateArgs, type prismaNamespace_SpecializationUpdateInput as SpecializationUpdateInput, type prismaNamespace_SpecializationUpdateManyAndReturnArgs as SpecializationUpdateManyAndReturnArgs, type prismaNamespace_SpecializationUpdateManyArgs as SpecializationUpdateManyArgs, type prismaNamespace_SpecializationUpdateManyMutationInput as SpecializationUpdateManyMutationInput, type prismaNamespace_SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput as SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput, type prismaNamespace_SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput as SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput, type prismaNamespace_SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput as SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput as SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationUpdateWithoutDoctorSpecializationInput as SpecializationUpdateWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationUpdateWithoutHospitalSpecializationInput as SpecializationUpdateWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationUpsertArgs as SpecializationUpsertArgs, type prismaNamespace_SpecializationUpsertWithoutDoctorSpecializationInput as SpecializationUpsertWithoutDoctorSpecializationInput, type prismaNamespace_SpecializationUpsertWithoutHospitalSpecializationInput as SpecializationUpsertWithoutHospitalSpecializationInput, type prismaNamespace_SpecializationWhereInput as SpecializationWhereInput, type prismaNamespace_SpecializationWhereUniqueInput as SpecializationWhereUniqueInput, type prismaNamespace_Sql as Sql, type prismaNamespace_Strict as Strict, type prismaNamespace_StringFieldRefInput as StringFieldRefInput, type prismaNamespace_StringFieldUpdateOperationsInput as StringFieldUpdateOperationsInput, type prismaNamespace_StringFilter as StringFilter, type prismaNamespace_StringNullableFilter as StringNullableFilter, type prismaNamespace_StringNullableListFilter as StringNullableListFilter, type prismaNamespace_StringNullableWithAggregatesFilter as StringNullableWithAggregatesFilter, type prismaNamespace_StringWithAggregatesFilter as StringWithAggregatesFilter, type prismaNamespace_Subset as Subset, type prismaNamespace_SubsetIntersection as SubsetIntersection, type prismaNamespace_TransactionClient as TransactionClient, type prismaNamespace_TransactionIsolationLevel as TransactionIsolationLevel, type prismaNamespace_True as True, type prismaNamespace_TypeMap as TypeMap, type prismaNamespace_TypeMapCb as TypeMapCb, type prismaNamespace_UnEnumerate as UnEnumerate, type prismaNamespace_Union as Union, type prismaNamespace_User$Appointment_Appointment_approvedByToUserArgs as User$Appointment_Appointment_approvedByToUserArgs, type prismaNamespace_User$Appointment_Appointment_customerIdToUserArgs as User$Appointment_Appointment_customerIdToUserArgs, type prismaNamespace_User$AuditLogArgs as User$AuditLogArgs, type prismaNamespace_User$DoctorApplicationArgs as User$DoctorApplicationArgs, type prismaNamespace_User$DoctorArgs as User$DoctorArgs, type prismaNamespace_User$HospitalArgs as User$HospitalArgs, type prismaNamespace_User$NotificationArgs as User$NotificationArgs, type prismaNamespace_User$PaymentArgs as User$PaymentArgs, type prismaNamespace_User$ReviewArgs as User$ReviewArgs, type prismaNamespace_User$SavedDoctorHospitalArgs as User$SavedDoctorHospitalArgs, type prismaNamespace_User$ScheduleArgs as User$ScheduleArgs, type prismaNamespace_User$SearchLogArgs as User$SearchLogArgs, type prismaNamespace_User$accountArgs as User$accountArgs, type prismaNamespace_User$sessionArgs as User$sessionArgs, type prismaNamespace_UserAggregateArgs as UserAggregateArgs, type prismaNamespace_UserCountAggregateInputType as UserCountAggregateInputType, type prismaNamespace_UserCountAggregateOutputType as UserCountAggregateOutputType, type prismaNamespace_UserCountArgs as UserCountArgs, type prismaNamespace_UserCountOrderByAggregateInput as UserCountOrderByAggregateInput, type prismaNamespace_UserCountOutputType as UserCountOutputType, type prismaNamespace_UserCountOutputTypeCountAccountArgs as UserCountOutputTypeCountAccountArgs, type prismaNamespace_UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs as UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs, type prismaNamespace_UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs as UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs, type prismaNamespace_UserCountOutputTypeCountAuditLogArgs as UserCountOutputTypeCountAuditLogArgs, type prismaNamespace_UserCountOutputTypeCountDoctorApplicationArgs as UserCountOutputTypeCountDoctorApplicationArgs, type prismaNamespace_UserCountOutputTypeCountNotificationArgs as UserCountOutputTypeCountNotificationArgs, type prismaNamespace_UserCountOutputTypeCountPaymentArgs as UserCountOutputTypeCountPaymentArgs, type prismaNamespace_UserCountOutputTypeCountReviewArgs as UserCountOutputTypeCountReviewArgs, type prismaNamespace_UserCountOutputTypeCountSavedDoctorHospitalArgs as UserCountOutputTypeCountSavedDoctorHospitalArgs, type prismaNamespace_UserCountOutputTypeCountScheduleArgs as UserCountOutputTypeCountScheduleArgs, type prismaNamespace_UserCountOutputTypeCountSearchLogArgs as UserCountOutputTypeCountSearchLogArgs, type prismaNamespace_UserCountOutputTypeCountSessionArgs as UserCountOutputTypeCountSessionArgs, type prismaNamespace_UserCountOutputTypeDefaultArgs as UserCountOutputTypeDefaultArgs, type prismaNamespace_UserCountOutputTypeSelect as UserCountOutputTypeSelect, type prismaNamespace_UserCreateArgs as UserCreateArgs, type prismaNamespace_UserCreateInput as UserCreateInput, type prismaNamespace_UserCreateManyAndReturnArgs as UserCreateManyAndReturnArgs, type prismaNamespace_UserCreateManyArgs as UserCreateManyArgs, type prismaNamespace_UserCreateManyInput as UserCreateManyInput, type prismaNamespace_UserCreateNestedOneWithoutAccountInput as UserCreateNestedOneWithoutAccountInput, type prismaNamespace_UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput as UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput as UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserCreateNestedOneWithoutAuditLogInput as UserCreateNestedOneWithoutAuditLogInput, type prismaNamespace_UserCreateNestedOneWithoutDoctorApplicationInput as UserCreateNestedOneWithoutDoctorApplicationInput, type prismaNamespace_UserCreateNestedOneWithoutDoctorInput as UserCreateNestedOneWithoutDoctorInput, type prismaNamespace_UserCreateNestedOneWithoutHospitalInput as UserCreateNestedOneWithoutHospitalInput, type prismaNamespace_UserCreateNestedOneWithoutNotificationInput as UserCreateNestedOneWithoutNotificationInput, type prismaNamespace_UserCreateNestedOneWithoutPaymentInput as UserCreateNestedOneWithoutPaymentInput, type prismaNamespace_UserCreateNestedOneWithoutReviewInput as UserCreateNestedOneWithoutReviewInput, type prismaNamespace_UserCreateNestedOneWithoutSavedDoctorHospitalInput as UserCreateNestedOneWithoutSavedDoctorHospitalInput, type prismaNamespace_UserCreateNestedOneWithoutScheduleInput as UserCreateNestedOneWithoutScheduleInput, type prismaNamespace_UserCreateNestedOneWithoutSearchLogInput as UserCreateNestedOneWithoutSearchLogInput, type prismaNamespace_UserCreateNestedOneWithoutSessionInput as UserCreateNestedOneWithoutSessionInput, type prismaNamespace_UserCreateOrConnectWithoutAccountInput as UserCreateOrConnectWithoutAccountInput, type prismaNamespace_UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput as UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput as UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserCreateOrConnectWithoutAuditLogInput as UserCreateOrConnectWithoutAuditLogInput, type prismaNamespace_UserCreateOrConnectWithoutDoctorApplicationInput as UserCreateOrConnectWithoutDoctorApplicationInput, type prismaNamespace_UserCreateOrConnectWithoutDoctorInput as UserCreateOrConnectWithoutDoctorInput, type prismaNamespace_UserCreateOrConnectWithoutHospitalInput as UserCreateOrConnectWithoutHospitalInput, type prismaNamespace_UserCreateOrConnectWithoutNotificationInput as UserCreateOrConnectWithoutNotificationInput, type prismaNamespace_UserCreateOrConnectWithoutPaymentInput as UserCreateOrConnectWithoutPaymentInput, type prismaNamespace_UserCreateOrConnectWithoutReviewInput as UserCreateOrConnectWithoutReviewInput, type prismaNamespace_UserCreateOrConnectWithoutSavedDoctorHospitalInput as UserCreateOrConnectWithoutSavedDoctorHospitalInput, type prismaNamespace_UserCreateOrConnectWithoutScheduleInput as UserCreateOrConnectWithoutScheduleInput, type prismaNamespace_UserCreateOrConnectWithoutSearchLogInput as UserCreateOrConnectWithoutSearchLogInput, type prismaNamespace_UserCreateOrConnectWithoutSessionInput as UserCreateOrConnectWithoutSessionInput, type prismaNamespace_UserCreateWithoutAccountInput as UserCreateWithoutAccountInput, type prismaNamespace_UserCreateWithoutAppointment_Appointment_approvedByToUserInput as UserCreateWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserCreateWithoutAppointment_Appointment_customerIdToUserInput as UserCreateWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserCreateWithoutAuditLogInput as UserCreateWithoutAuditLogInput, type prismaNamespace_UserCreateWithoutDoctorApplicationInput as UserCreateWithoutDoctorApplicationInput, type prismaNamespace_UserCreateWithoutDoctorInput as UserCreateWithoutDoctorInput, type prismaNamespace_UserCreateWithoutHospitalInput as UserCreateWithoutHospitalInput, type prismaNamespace_UserCreateWithoutNotificationInput as UserCreateWithoutNotificationInput, type prismaNamespace_UserCreateWithoutPaymentInput as UserCreateWithoutPaymentInput, type prismaNamespace_UserCreateWithoutReviewInput as UserCreateWithoutReviewInput, type prismaNamespace_UserCreateWithoutSavedDoctorHospitalInput as UserCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_UserCreateWithoutScheduleInput as UserCreateWithoutScheduleInput, type prismaNamespace_UserCreateWithoutSearchLogInput as UserCreateWithoutSearchLogInput, type prismaNamespace_UserCreateWithoutSessionInput as UserCreateWithoutSessionInput, type prismaNamespace_UserDefaultArgs as UserDefaultArgs, type prismaNamespace_UserDelegate as UserDelegate, type prismaNamespace_UserDeleteArgs as UserDeleteArgs, type prismaNamespace_UserDeleteManyArgs as UserDeleteManyArgs, type prismaNamespace_UserFieldRefs as UserFieldRefs, type prismaNamespace_UserFindFirstArgs as UserFindFirstArgs, type prismaNamespace_UserFindFirstOrThrowArgs as UserFindFirstOrThrowArgs, type prismaNamespace_UserFindManyArgs as UserFindManyArgs, type prismaNamespace_UserFindUniqueArgs as UserFindUniqueArgs, type prismaNamespace_UserFindUniqueOrThrowArgs as UserFindUniqueOrThrowArgs, type prismaNamespace_UserGetPayload as UserGetPayload, type prismaNamespace_UserGroupByArgs as UserGroupByArgs, type prismaNamespace_UserGroupByOutputType as UserGroupByOutputType, type prismaNamespace_UserInclude as UserInclude, type prismaNamespace_UserIncludeCreateManyAndReturn as UserIncludeCreateManyAndReturn, type prismaNamespace_UserIncludeUpdateManyAndReturn as UserIncludeUpdateManyAndReturn, type prismaNamespace_UserMaxAggregateInputType as UserMaxAggregateInputType, type prismaNamespace_UserMaxAggregateOutputType as UserMaxAggregateOutputType, type prismaNamespace_UserMaxOrderByAggregateInput as UserMaxOrderByAggregateInput, type prismaNamespace_UserMinAggregateInputType as UserMinAggregateInputType, type prismaNamespace_UserMinAggregateOutputType as UserMinAggregateOutputType, type prismaNamespace_UserMinOrderByAggregateInput as UserMinOrderByAggregateInput, type prismaNamespace_UserModel as UserModel, type prismaNamespace_UserNullableScalarRelationFilter as UserNullableScalarRelationFilter, type prismaNamespace_UserOmit as UserOmit, type prismaNamespace_UserOrderByWithAggregationInput as UserOrderByWithAggregationInput, type prismaNamespace_UserOrderByWithRelationInput as UserOrderByWithRelationInput, type prismaNamespace_UserScalarFieldEnum as UserScalarFieldEnum, type prismaNamespace_UserScalarRelationFilter as UserScalarRelationFilter, type prismaNamespace_UserScalarWhereWithAggregatesInput as UserScalarWhereWithAggregatesInput, type prismaNamespace_UserSelect as UserSelect, type prismaNamespace_UserSelectCreateManyAndReturn as UserSelectCreateManyAndReturn, type prismaNamespace_UserSelectScalar as UserSelectScalar, type prismaNamespace_UserSelectUpdateManyAndReturn as UserSelectUpdateManyAndReturn, type prismaNamespace_UserUncheckedCreateInput as UserUncheckedCreateInput, type prismaNamespace_UserUncheckedCreateWithoutAccountInput as UserUncheckedCreateWithoutAccountInput, type prismaNamespace_UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput as UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput as UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserUncheckedCreateWithoutAuditLogInput as UserUncheckedCreateWithoutAuditLogInput, type prismaNamespace_UserUncheckedCreateWithoutDoctorApplicationInput as UserUncheckedCreateWithoutDoctorApplicationInput, type prismaNamespace_UserUncheckedCreateWithoutDoctorInput as UserUncheckedCreateWithoutDoctorInput, type prismaNamespace_UserUncheckedCreateWithoutHospitalInput as UserUncheckedCreateWithoutHospitalInput, type prismaNamespace_UserUncheckedCreateWithoutNotificationInput as UserUncheckedCreateWithoutNotificationInput, type prismaNamespace_UserUncheckedCreateWithoutPaymentInput as UserUncheckedCreateWithoutPaymentInput, type prismaNamespace_UserUncheckedCreateWithoutReviewInput as UserUncheckedCreateWithoutReviewInput, type prismaNamespace_UserUncheckedCreateWithoutSavedDoctorHospitalInput as UserUncheckedCreateWithoutSavedDoctorHospitalInput, type prismaNamespace_UserUncheckedCreateWithoutScheduleInput as UserUncheckedCreateWithoutScheduleInput, type prismaNamespace_UserUncheckedCreateWithoutSearchLogInput as UserUncheckedCreateWithoutSearchLogInput, type prismaNamespace_UserUncheckedCreateWithoutSessionInput as UserUncheckedCreateWithoutSessionInput, type prismaNamespace_UserUncheckedUpdateInput as UserUncheckedUpdateInput, type prismaNamespace_UserUncheckedUpdateManyInput as UserUncheckedUpdateManyInput, type prismaNamespace_UserUncheckedUpdateWithoutAccountInput as UserUncheckedUpdateWithoutAccountInput, type prismaNamespace_UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput as UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput as UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserUncheckedUpdateWithoutAuditLogInput as UserUncheckedUpdateWithoutAuditLogInput, type prismaNamespace_UserUncheckedUpdateWithoutDoctorApplicationInput as UserUncheckedUpdateWithoutDoctorApplicationInput, type prismaNamespace_UserUncheckedUpdateWithoutDoctorInput as UserUncheckedUpdateWithoutDoctorInput, type prismaNamespace_UserUncheckedUpdateWithoutHospitalInput as UserUncheckedUpdateWithoutHospitalInput, type prismaNamespace_UserUncheckedUpdateWithoutNotificationInput as UserUncheckedUpdateWithoutNotificationInput, type prismaNamespace_UserUncheckedUpdateWithoutPaymentInput as UserUncheckedUpdateWithoutPaymentInput, type prismaNamespace_UserUncheckedUpdateWithoutReviewInput as UserUncheckedUpdateWithoutReviewInput, type prismaNamespace_UserUncheckedUpdateWithoutSavedDoctorHospitalInput as UserUncheckedUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_UserUncheckedUpdateWithoutScheduleInput as UserUncheckedUpdateWithoutScheduleInput, type prismaNamespace_UserUncheckedUpdateWithoutSearchLogInput as UserUncheckedUpdateWithoutSearchLogInput, type prismaNamespace_UserUncheckedUpdateWithoutSessionInput as UserUncheckedUpdateWithoutSessionInput, type prismaNamespace_UserUpdateArgs as UserUpdateArgs, type prismaNamespace_UserUpdateInput as UserUpdateInput, type prismaNamespace_UserUpdateManyAndReturnArgs as UserUpdateManyAndReturnArgs, type prismaNamespace_UserUpdateManyArgs as UserUpdateManyArgs, type prismaNamespace_UserUpdateManyMutationInput as UserUpdateManyMutationInput, type prismaNamespace_UserUpdateOneRequiredWithoutAccountNestedInput as UserUpdateOneRequiredWithoutAccountNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput as UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutAuditLogNestedInput as UserUpdateOneRequiredWithoutAuditLogNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutDoctorApplicationNestedInput as UserUpdateOneRequiredWithoutDoctorApplicationNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutDoctorNestedInput as UserUpdateOneRequiredWithoutDoctorNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutHospitalNestedInput as UserUpdateOneRequiredWithoutHospitalNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutNotificationNestedInput as UserUpdateOneRequiredWithoutNotificationNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutPaymentNestedInput as UserUpdateOneRequiredWithoutPaymentNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutReviewNestedInput as UserUpdateOneRequiredWithoutReviewNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput as UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutScheduleNestedInput as UserUpdateOneRequiredWithoutScheduleNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutSearchLogNestedInput as UserUpdateOneRequiredWithoutSearchLogNestedInput, type prismaNamespace_UserUpdateOneRequiredWithoutSessionNestedInput as UserUpdateOneRequiredWithoutSessionNestedInput, type prismaNamespace_UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput as UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutAccountInput as UserUpdateToOneWithWhereWithoutAccountInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput as UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput as UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutAuditLogInput as UserUpdateToOneWithWhereWithoutAuditLogInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutDoctorApplicationInput as UserUpdateToOneWithWhereWithoutDoctorApplicationInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutDoctorInput as UserUpdateToOneWithWhereWithoutDoctorInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutHospitalInput as UserUpdateToOneWithWhereWithoutHospitalInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutNotificationInput as UserUpdateToOneWithWhereWithoutNotificationInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutPaymentInput as UserUpdateToOneWithWhereWithoutPaymentInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutReviewInput as UserUpdateToOneWithWhereWithoutReviewInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutScheduleInput as UserUpdateToOneWithWhereWithoutScheduleInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutSearchLogInput as UserUpdateToOneWithWhereWithoutSearchLogInput, type prismaNamespace_UserUpdateToOneWithWhereWithoutSessionInput as UserUpdateToOneWithWhereWithoutSessionInput, type prismaNamespace_UserUpdateWithoutAccountInput as UserUpdateWithoutAccountInput, type prismaNamespace_UserUpdateWithoutAppointment_Appointment_approvedByToUserInput as UserUpdateWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserUpdateWithoutAppointment_Appointment_customerIdToUserInput as UserUpdateWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserUpdateWithoutAuditLogInput as UserUpdateWithoutAuditLogInput, type prismaNamespace_UserUpdateWithoutDoctorApplicationInput as UserUpdateWithoutDoctorApplicationInput, type prismaNamespace_UserUpdateWithoutDoctorInput as UserUpdateWithoutDoctorInput, type prismaNamespace_UserUpdateWithoutHospitalInput as UserUpdateWithoutHospitalInput, type prismaNamespace_UserUpdateWithoutNotificationInput as UserUpdateWithoutNotificationInput, type prismaNamespace_UserUpdateWithoutPaymentInput as UserUpdateWithoutPaymentInput, type prismaNamespace_UserUpdateWithoutReviewInput as UserUpdateWithoutReviewInput, type prismaNamespace_UserUpdateWithoutSavedDoctorHospitalInput as UserUpdateWithoutSavedDoctorHospitalInput, type prismaNamespace_UserUpdateWithoutScheduleInput as UserUpdateWithoutScheduleInput, type prismaNamespace_UserUpdateWithoutSearchLogInput as UserUpdateWithoutSearchLogInput, type prismaNamespace_UserUpdateWithoutSessionInput as UserUpdateWithoutSessionInput, type prismaNamespace_UserUpsertArgs as UserUpsertArgs, type prismaNamespace_UserUpsertWithoutAccountInput as UserUpsertWithoutAccountInput, type prismaNamespace_UserUpsertWithoutAppointment_Appointment_approvedByToUserInput as UserUpsertWithoutAppointment_Appointment_approvedByToUserInput, type prismaNamespace_UserUpsertWithoutAppointment_Appointment_customerIdToUserInput as UserUpsertWithoutAppointment_Appointment_customerIdToUserInput, type prismaNamespace_UserUpsertWithoutAuditLogInput as UserUpsertWithoutAuditLogInput, type prismaNamespace_UserUpsertWithoutDoctorApplicationInput as UserUpsertWithoutDoctorApplicationInput, type prismaNamespace_UserUpsertWithoutDoctorInput as UserUpsertWithoutDoctorInput, type prismaNamespace_UserUpsertWithoutHospitalInput as UserUpsertWithoutHospitalInput, type prismaNamespace_UserUpsertWithoutNotificationInput as UserUpsertWithoutNotificationInput, type prismaNamespace_UserUpsertWithoutPaymentInput as UserUpsertWithoutPaymentInput, type prismaNamespace_UserUpsertWithoutReviewInput as UserUpsertWithoutReviewInput, type prismaNamespace_UserUpsertWithoutSavedDoctorHospitalInput as UserUpsertWithoutSavedDoctorHospitalInput, type prismaNamespace_UserUpsertWithoutScheduleInput as UserUpsertWithoutScheduleInput, type prismaNamespace_UserUpsertWithoutSearchLogInput as UserUpsertWithoutSearchLogInput, type prismaNamespace_UserUpsertWithoutSessionInput as UserUpsertWithoutSessionInput, type prismaNamespace_UserWhereInput as UserWhereInput, type prismaNamespace_UserWhereUniqueInput as UserWhereUniqueInput, type prismaNamespace_VerificationAggregateArgs as VerificationAggregateArgs, type prismaNamespace_VerificationCountAggregateInputType as VerificationCountAggregateInputType, type prismaNamespace_VerificationCountAggregateOutputType as VerificationCountAggregateOutputType, type prismaNamespace_VerificationGroupByOutputType as VerificationGroupByOutputType, type prismaNamespace_VerificationMaxAggregateInputType as VerificationMaxAggregateInputType, type prismaNamespace_VerificationMaxAggregateOutputType as VerificationMaxAggregateOutputType, type prismaNamespace_VerificationMinAggregateInputType as VerificationMinAggregateInputType, type prismaNamespace_VerificationMinAggregateOutputType as VerificationMinAggregateOutputType, type prismaNamespace_VerificationScalarFieldEnum as VerificationScalarFieldEnum, type prismaNamespace_XOR as XOR, type prismaNamespace_accountCountArgs as accountCountArgs, type prismaNamespace_accountCountOrderByAggregateInput as accountCountOrderByAggregateInput, type prismaNamespace_accountCreateArgs as accountCreateArgs, type prismaNamespace_accountCreateInput as accountCreateInput, type prismaNamespace_accountCreateManyAndReturnArgs as accountCreateManyAndReturnArgs, type prismaNamespace_accountCreateManyArgs as accountCreateManyArgs, type prismaNamespace_accountCreateManyInput as accountCreateManyInput, type prismaNamespace_accountCreateManyUserInput as accountCreateManyUserInput, type prismaNamespace_accountCreateManyUserInputEnvelope as accountCreateManyUserInputEnvelope, type prismaNamespace_accountCreateNestedManyWithoutUserInput as accountCreateNestedManyWithoutUserInput, type prismaNamespace_accountCreateOrConnectWithoutUserInput as accountCreateOrConnectWithoutUserInput, type prismaNamespace_accountCreateWithoutUserInput as accountCreateWithoutUserInput, type prismaNamespace_accountDefaultArgs as accountDefaultArgs, type prismaNamespace_accountDelegate as accountDelegate, type prismaNamespace_accountDeleteArgs as accountDeleteArgs, type prismaNamespace_accountDeleteManyArgs as accountDeleteManyArgs, type prismaNamespace_accountFieldRefs as accountFieldRefs, type prismaNamespace_accountFindFirstArgs as accountFindFirstArgs, type prismaNamespace_accountFindFirstOrThrowArgs as accountFindFirstOrThrowArgs, type prismaNamespace_accountFindManyArgs as accountFindManyArgs, type prismaNamespace_accountFindUniqueArgs as accountFindUniqueArgs, type prismaNamespace_accountFindUniqueOrThrowArgs as accountFindUniqueOrThrowArgs, type prismaNamespace_accountGetPayload as accountGetPayload, type prismaNamespace_accountGroupByArgs as accountGroupByArgs, type prismaNamespace_accountInclude as accountInclude, type prismaNamespace_accountIncludeCreateManyAndReturn as accountIncludeCreateManyAndReturn, type prismaNamespace_accountIncludeUpdateManyAndReturn as accountIncludeUpdateManyAndReturn, type prismaNamespace_accountMaxOrderByAggregateInput as accountMaxOrderByAggregateInput, type prismaNamespace_accountMinOrderByAggregateInput as accountMinOrderByAggregateInput, type prismaNamespace_accountModel as accountModel, type prismaNamespace_accountOmit as accountOmit, type prismaNamespace_accountOrderByRelationAggregateInput as accountOrderByRelationAggregateInput, type prismaNamespace_accountOrderByWithAggregationInput as accountOrderByWithAggregationInput, type prismaNamespace_accountOrderByWithRelationInput as accountOrderByWithRelationInput, type prismaNamespace_accountScalarWhereInput as accountScalarWhereInput, type prismaNamespace_accountScalarWhereWithAggregatesInput as accountScalarWhereWithAggregatesInput, type prismaNamespace_accountSelect as accountSelect, type prismaNamespace_accountSelectCreateManyAndReturn as accountSelectCreateManyAndReturn, type prismaNamespace_accountSelectScalar as accountSelectScalar, type prismaNamespace_accountSelectUpdateManyAndReturn as accountSelectUpdateManyAndReturn, type prismaNamespace_accountUncheckedCreateInput as accountUncheckedCreateInput, type prismaNamespace_accountUncheckedCreateNestedManyWithoutUserInput as accountUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_accountUncheckedCreateWithoutUserInput as accountUncheckedCreateWithoutUserInput, type prismaNamespace_accountUncheckedUpdateInput as accountUncheckedUpdateInput, type prismaNamespace_accountUncheckedUpdateManyInput as accountUncheckedUpdateManyInput, type prismaNamespace_accountUncheckedUpdateManyWithoutUserInput as accountUncheckedUpdateManyWithoutUserInput, type prismaNamespace_accountUncheckedUpdateManyWithoutUserNestedInput as accountUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_accountUncheckedUpdateWithoutUserInput as accountUncheckedUpdateWithoutUserInput, type prismaNamespace_accountUpdateArgs as accountUpdateArgs, type prismaNamespace_accountUpdateInput as accountUpdateInput, type prismaNamespace_accountUpdateManyAndReturnArgs as accountUpdateManyAndReturnArgs, type prismaNamespace_accountUpdateManyArgs as accountUpdateManyArgs, type prismaNamespace_accountUpdateManyMutationInput as accountUpdateManyMutationInput, type prismaNamespace_accountUpdateManyWithWhereWithoutUserInput as accountUpdateManyWithWhereWithoutUserInput, type prismaNamespace_accountUpdateManyWithoutUserNestedInput as accountUpdateManyWithoutUserNestedInput, type prismaNamespace_accountUpdateWithWhereUniqueWithoutUserInput as accountUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_accountUpdateWithoutUserInput as accountUpdateWithoutUserInput, type prismaNamespace_accountUpsertArgs as accountUpsertArgs, type prismaNamespace_accountUpsertWithWhereUniqueWithoutUserInput as accountUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_accountWhereInput as accountWhereInput, type prismaNamespace_accountWhereUniqueInput as accountWhereUniqueInput, prismaNamespace_defineExtension as defineExtension, prismaNamespace_empty as empty, prismaNamespace_getExtensionContext as getExtensionContext, prismaNamespace_join as join, prismaNamespace_prismaVersion as prismaVersion, prismaNamespace_raw as raw, type prismaNamespace_sessionCountArgs as sessionCountArgs, type prismaNamespace_sessionCountOrderByAggregateInput as sessionCountOrderByAggregateInput, type prismaNamespace_sessionCreateArgs as sessionCreateArgs, type prismaNamespace_sessionCreateInput as sessionCreateInput, type prismaNamespace_sessionCreateManyAndReturnArgs as sessionCreateManyAndReturnArgs, type prismaNamespace_sessionCreateManyArgs as sessionCreateManyArgs, type prismaNamespace_sessionCreateManyInput as sessionCreateManyInput, type prismaNamespace_sessionCreateManyUserInput as sessionCreateManyUserInput, type prismaNamespace_sessionCreateManyUserInputEnvelope as sessionCreateManyUserInputEnvelope, type prismaNamespace_sessionCreateNestedManyWithoutUserInput as sessionCreateNestedManyWithoutUserInput, type prismaNamespace_sessionCreateOrConnectWithoutUserInput as sessionCreateOrConnectWithoutUserInput, type prismaNamespace_sessionCreateWithoutUserInput as sessionCreateWithoutUserInput, type prismaNamespace_sessionDefaultArgs as sessionDefaultArgs, type prismaNamespace_sessionDelegate as sessionDelegate, type prismaNamespace_sessionDeleteArgs as sessionDeleteArgs, type prismaNamespace_sessionDeleteManyArgs as sessionDeleteManyArgs, type prismaNamespace_sessionFieldRefs as sessionFieldRefs, type prismaNamespace_sessionFindFirstArgs as sessionFindFirstArgs, type prismaNamespace_sessionFindFirstOrThrowArgs as sessionFindFirstOrThrowArgs, type prismaNamespace_sessionFindManyArgs as sessionFindManyArgs, type prismaNamespace_sessionFindUniqueArgs as sessionFindUniqueArgs, type prismaNamespace_sessionFindUniqueOrThrowArgs as sessionFindUniqueOrThrowArgs, type prismaNamespace_sessionGetPayload as sessionGetPayload, type prismaNamespace_sessionGroupByArgs as sessionGroupByArgs, type prismaNamespace_sessionInclude as sessionInclude, type prismaNamespace_sessionIncludeCreateManyAndReturn as sessionIncludeCreateManyAndReturn, type prismaNamespace_sessionIncludeUpdateManyAndReturn as sessionIncludeUpdateManyAndReturn, type prismaNamespace_sessionMaxOrderByAggregateInput as sessionMaxOrderByAggregateInput, type prismaNamespace_sessionMinOrderByAggregateInput as sessionMinOrderByAggregateInput, type prismaNamespace_sessionModel as sessionModel, type prismaNamespace_sessionOmit as sessionOmit, type prismaNamespace_sessionOrderByRelationAggregateInput as sessionOrderByRelationAggregateInput, type prismaNamespace_sessionOrderByWithAggregationInput as sessionOrderByWithAggregationInput, type prismaNamespace_sessionOrderByWithRelationInput as sessionOrderByWithRelationInput, type prismaNamespace_sessionScalarWhereInput as sessionScalarWhereInput, type prismaNamespace_sessionScalarWhereWithAggregatesInput as sessionScalarWhereWithAggregatesInput, type prismaNamespace_sessionSelect as sessionSelect, type prismaNamespace_sessionSelectCreateManyAndReturn as sessionSelectCreateManyAndReturn, type prismaNamespace_sessionSelectScalar as sessionSelectScalar, type prismaNamespace_sessionSelectUpdateManyAndReturn as sessionSelectUpdateManyAndReturn, type prismaNamespace_sessionUncheckedCreateInput as sessionUncheckedCreateInput, type prismaNamespace_sessionUncheckedCreateNestedManyWithoutUserInput as sessionUncheckedCreateNestedManyWithoutUserInput, type prismaNamespace_sessionUncheckedCreateWithoutUserInput as sessionUncheckedCreateWithoutUserInput, type prismaNamespace_sessionUncheckedUpdateInput as sessionUncheckedUpdateInput, type prismaNamespace_sessionUncheckedUpdateManyInput as sessionUncheckedUpdateManyInput, type prismaNamespace_sessionUncheckedUpdateManyWithoutUserInput as sessionUncheckedUpdateManyWithoutUserInput, type prismaNamespace_sessionUncheckedUpdateManyWithoutUserNestedInput as sessionUncheckedUpdateManyWithoutUserNestedInput, type prismaNamespace_sessionUncheckedUpdateWithoutUserInput as sessionUncheckedUpdateWithoutUserInput, type prismaNamespace_sessionUpdateArgs as sessionUpdateArgs, type prismaNamespace_sessionUpdateInput as sessionUpdateInput, type prismaNamespace_sessionUpdateManyAndReturnArgs as sessionUpdateManyAndReturnArgs, type prismaNamespace_sessionUpdateManyArgs as sessionUpdateManyArgs, type prismaNamespace_sessionUpdateManyMutationInput as sessionUpdateManyMutationInput, type prismaNamespace_sessionUpdateManyWithWhereWithoutUserInput as sessionUpdateManyWithWhereWithoutUserInput, type prismaNamespace_sessionUpdateManyWithoutUserNestedInput as sessionUpdateManyWithoutUserNestedInput, type prismaNamespace_sessionUpdateWithWhereUniqueWithoutUserInput as sessionUpdateWithWhereUniqueWithoutUserInput, type prismaNamespace_sessionUpdateWithoutUserInput as sessionUpdateWithoutUserInput, type prismaNamespace_sessionUpsertArgs as sessionUpsertArgs, type prismaNamespace_sessionUpsertWithWhereUniqueWithoutUserInput as sessionUpsertWithWhereUniqueWithoutUserInput, type prismaNamespace_sessionWhereInput as sessionWhereInput, type prismaNamespace_sessionWhereUniqueInput as sessionWhereUniqueInput, prismaNamespace_sql as sql, type prismaNamespace_verificationCountArgs as verificationCountArgs, type prismaNamespace_verificationCountOrderByAggregateInput as verificationCountOrderByAggregateInput, type prismaNamespace_verificationCreateArgs as verificationCreateArgs, type prismaNamespace_verificationCreateInput as verificationCreateInput, type prismaNamespace_verificationCreateManyAndReturnArgs as verificationCreateManyAndReturnArgs, type prismaNamespace_verificationCreateManyArgs as verificationCreateManyArgs, type prismaNamespace_verificationCreateManyInput as verificationCreateManyInput, type prismaNamespace_verificationDefaultArgs as verificationDefaultArgs, type prismaNamespace_verificationDelegate as verificationDelegate, type prismaNamespace_verificationDeleteArgs as verificationDeleteArgs, type prismaNamespace_verificationDeleteManyArgs as verificationDeleteManyArgs, type prismaNamespace_verificationFieldRefs as verificationFieldRefs, type prismaNamespace_verificationFindFirstArgs as verificationFindFirstArgs, type prismaNamespace_verificationFindFirstOrThrowArgs as verificationFindFirstOrThrowArgs, type prismaNamespace_verificationFindManyArgs as verificationFindManyArgs, type prismaNamespace_verificationFindUniqueArgs as verificationFindUniqueArgs, type prismaNamespace_verificationFindUniqueOrThrowArgs as verificationFindUniqueOrThrowArgs, type prismaNamespace_verificationGetPayload as verificationGetPayload, type prismaNamespace_verificationGroupByArgs as verificationGroupByArgs, type prismaNamespace_verificationMaxOrderByAggregateInput as verificationMaxOrderByAggregateInput, type prismaNamespace_verificationMinOrderByAggregateInput as verificationMinOrderByAggregateInput, type prismaNamespace_verificationModel as verificationModel, type prismaNamespace_verificationOmit as verificationOmit, type prismaNamespace_verificationOrderByWithAggregationInput as verificationOrderByWithAggregationInput, type prismaNamespace_verificationOrderByWithRelationInput as verificationOrderByWithRelationInput, type prismaNamespace_verificationScalarWhereWithAggregatesInput as verificationScalarWhereWithAggregatesInput, type prismaNamespace_verificationSelect as verificationSelect, type prismaNamespace_verificationSelectCreateManyAndReturn as verificationSelectCreateManyAndReturn, type prismaNamespace_verificationSelectScalar as verificationSelectScalar, type prismaNamespace_verificationSelectUpdateManyAndReturn as verificationSelectUpdateManyAndReturn, type prismaNamespace_verificationUncheckedCreateInput as verificationUncheckedCreateInput, type prismaNamespace_verificationUncheckedUpdateInput as verificationUncheckedUpdateInput, type prismaNamespace_verificationUncheckedUpdateManyInput as verificationUncheckedUpdateManyInput, type prismaNamespace_verificationUpdateArgs as verificationUpdateArgs, type prismaNamespace_verificationUpdateInput as verificationUpdateInput, type prismaNamespace_verificationUpdateManyAndReturnArgs as verificationUpdateManyAndReturnArgs, type prismaNamespace_verificationUpdateManyArgs as verificationUpdateManyArgs, type prismaNamespace_verificationUpdateManyMutationInput as verificationUpdateManyMutationInput, type prismaNamespace_verificationUpsertArgs as verificationUpsertArgs, type prismaNamespace_verificationWhereInput as verificationWhereInput, type prismaNamespace_verificationWhereUniqueInput as verificationWhereUniqueInput };
}

type LogOptions<ClientOptions extends PrismaClientOptions> = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<ClientOptions['log']> : never : never;
interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   *
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Appointments
   * const appointments = await prisma.appointment.findMany()
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */
    new <Options extends PrismaClientOptions = PrismaClientOptions, LogOpts extends LogOptions<Options> = LogOptions<Options>, OmitOpts extends PrismaClientOptions['omit'] = Options extends {
        omit: infer U;
    } ? U : PrismaClientOptions['omit'], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs>(options: Subset<Options, PrismaClientOptions>): PrismaClient<LogOpts, OmitOpts, ExtArgs>;
}
/**
 * ## Prisma Client
 *
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Appointments
 * const appointments = await prisma.appointment.findMany()
 * ```
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
interface PrismaClient<in LogOpts extends LogLevel = never, in out OmitOpts extends PrismaClientOptions['omit'] = undefined, in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> {
    [K: symbol]: {
        types: TypeMap<ExtArgs>['other'];
    };
    $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): PrismaClient;
    /**
     * Connect with the database
     */
    $connect(): runtime.Types.Utils.JsPromise<void>;
    /**
     * Disconnect from the database
     */
    $disconnect(): runtime.Types.Utils.JsPromise<void>;
    /**
       * Executes a prepared raw query and returns the number of affected rows.
       * @example
       * ```
       * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
       * ```
       *
       * Read more in our [docs](https://pris.ly/d/raw-queries).
       */
    $executeRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;
    /**
     * Executes a raw query and returns the number of affected rows.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;
    /**
     * Performs a prepared raw query and returns the `SELECT` data.
     * @example
     * ```
     * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;
    /**
     * Performs a raw query and returns the `SELECT` data.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://pris.ly/d/raw-queries).
     */
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;
    /**
     * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
     * @example
     * ```
     * const [george, bob, alice] = await prisma.$transaction([
     *   prisma.user.create({ data: { name: 'George' } }),
     *   prisma.user.create({ data: { name: 'Bob' } }),
     *   prisma.user.create({ data: { name: 'Alice' } }),
     * ])
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
     */
    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {
        isolationLevel?: TransactionIsolationLevel;
    }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;
    $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: {
        maxWait?: number;
        timeout?: number;
        isolationLevel?: TransactionIsolationLevel;
    }): runtime.Types.Utils.JsPromise<R>;
    $extends: runtime.Types.Extensions.ExtendsHook<"extends", TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<TypeMapCb<OmitOpts>, {
        extArgs: ExtArgs;
    }>>;
    /**
 * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
  * Example usage:
  * ```ts
  * // Fetch zero or more Appointments
  * const appointments = await prisma.appointment.findMany()
  * ```
  */
    get appointment(): AppointmentDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more AuditLogs
      * const auditLogs = await prisma.auditLog.findMany()
      * ```
      */
    get auditLog(): AuditLogDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Doctors
      * const doctors = await prisma.doctor.findMany()
      * ```
      */
    get doctor(): DoctorDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.doctorApplication`: Exposes CRUD operations for the **DoctorApplication** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more DoctorApplications
      * const doctorApplications = await prisma.doctorApplication.findMany()
      * ```
      */
    get doctorApplication(): DoctorApplicationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.doctorHospitalProfile`: Exposes CRUD operations for the **DoctorHospitalProfile** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more DoctorHospitalProfiles
      * const doctorHospitalProfiles = await prisma.doctorHospitalProfile.findMany()
      * ```
      */
    get doctorHospitalProfile(): DoctorHospitalProfileDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.doctorSpecialization`: Exposes CRUD operations for the **DoctorSpecialization** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more DoctorSpecializations
      * const doctorSpecializations = await prisma.doctorSpecialization.findMany()
      * ```
      */
    get doctorSpecialization(): DoctorSpecializationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Hospitals
      * const hospitals = await prisma.hospital.findMany()
      * ```
      */
    get hospital(): HospitalDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.hospitalSpecialization`: Exposes CRUD operations for the **HospitalSpecialization** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more HospitalSpecializations
      * const hospitalSpecializations = await prisma.hospitalSpecialization.findMany()
      * ```
      */
    get hospitalSpecialization(): HospitalSpecializationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Notifications
      * const notifications = await prisma.notification.findMany()
      * ```
      */
    get notification(): NotificationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Payments
      * const payments = await prisma.payment.findMany()
      * ```
      */
    get payment(): PaymentDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.review`: Exposes CRUD operations for the **Review** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Reviews
      * const reviews = await prisma.review.findMany()
      * ```
      */
    get review(): ReviewDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.savedDoctorHospital`: Exposes CRUD operations for the **SavedDoctorHospital** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more SavedDoctorHospitals
      * const savedDoctorHospitals = await prisma.savedDoctorHospital.findMany()
      * ```
      */
    get savedDoctorHospital(): SavedDoctorHospitalDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Schedules
      * const schedules = await prisma.schedule.findMany()
      * ```
      */
    get schedule(): ScheduleDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.searchLog`: Exposes CRUD operations for the **SearchLog** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more SearchLogs
      * const searchLogs = await prisma.searchLog.findMany()
      * ```
      */
    get searchLog(): SearchLogDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.slot`: Exposes CRUD operations for the **Slot** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Slots
      * const slots = await prisma.slot.findMany()
      * ```
      */
    get slot(): SlotDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.specialization`: Exposes CRUD operations for the **Specialization** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Specializations
      * const specializations = await prisma.specialization.findMany()
      * ```
      */
    get specialization(): SpecializationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.user`: Exposes CRUD operations for the **User** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Users
      * const users = await prisma.user.findMany()
      * ```
      */
    get user(): UserDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.account`: Exposes CRUD operations for the **account** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Accounts
      * const accounts = await prisma.account.findMany()
      * ```
      */
    get account(): accountDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.session`: Exposes CRUD operations for the **session** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Sessions
      * const sessions = await prisma.session.findMany()
      * ```
      */
    get session(): sessionDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
    /**
     * `prisma.verification`: Exposes CRUD operations for the **verification** model.
      * Example usage:
      * ```ts
      * // Fetch zero or more Verifications
      * const verifications = await prisma.verification.findMany()
      * ```
      */
    get verification(): verificationDelegate<ExtArgs, {
        omit: OmitOpts;
    }>;
}
declare function getPrismaClientClass(): PrismaClientConstructor;

export { type $AppointmentPayload as $, type AppointmentModel as A, type SlotMinAggregateOutputType as A$, type SearchLogUpdateArgs as A0, type SearchLogUpdateInput as A1, type SearchLogUpdateManyAndReturnArgs as A2, type SearchLogUpdateManyArgs as A3, type SearchLogUpdateManyMutationInput as A4, type SearchLogUpdateManyWithWhereWithoutUserInput as A5, type SearchLogUpdateManyWithoutUserNestedInput as A6, type SearchLogUpdateWithWhereUniqueWithoutUserInput as A7, type SearchLogUpdateWithoutUserInput as A8, type SearchLogUpsertArgs as A9, type SlotCreateNestedManyWithoutScheduleInput as AA, type SlotCreateNestedOneWithoutAppointmentInput as AB, type SlotCreateOrConnectWithoutAppointmentInput as AC, type SlotCreateOrConnectWithoutScheduleInput as AD, type SlotCreateWithoutAppointmentInput as AE, type SlotCreateWithoutScheduleInput as AF, type SlotDefaultArgs as AG, type SlotDelegate as AH, type SlotDeleteArgs as AI, type SlotDeleteManyArgs as AJ, type SlotFieldRefs as AK, type SlotFindFirstArgs as AL, type SlotFindFirstOrThrowArgs as AM, type SlotFindManyArgs as AN, type SlotFindUniqueArgs as AO, type SlotFindUniqueOrThrowArgs as AP, type SlotGetPayload as AQ, type SlotGroupByArgs as AR, type SlotGroupByOutputType as AS, type SlotInclude as AT, type SlotIncludeCreateManyAndReturn as AU, type SlotIncludeUpdateManyAndReturn as AV, type SlotListRelationFilter as AW, type SlotMaxAggregateInputType as AX, type SlotMaxAggregateOutputType as AY, type SlotMaxOrderByAggregateInput as AZ, type SlotMinAggregateInputType as A_, type SearchLogUpsertWithWhereUniqueWithoutUserInput as Aa, type SearchLogWhereInput as Ab, type SearchLogWhereUniqueInput as Ac, type SelectSubset as Ad, type SessionAggregateArgs as Ae, type SessionCountAggregateInputType as Af, type SessionCountAggregateOutputType as Ag, type SessionGroupByOutputType as Ah, type SessionListRelationFilter as Ai, type SessionMaxAggregateInputType as Aj, type SessionMaxAggregateOutputType as Ak, type SessionMinAggregateInputType as Al, type SessionMinAggregateOutputType as Am, type Slot$AppointmentArgs as An, type SlotAggregateArgs as Ao, type SlotCountAggregateInputType as Ap, type SlotCountAggregateOutputType as Aq, type SlotCountArgs as Ar, type SlotCountOrderByAggregateInput as As, type SlotCreateArgs as At, type SlotCreateInput as Au, type SlotCreateManyAndReturnArgs as Av, type SlotCreateManyArgs as Aw, type SlotCreateManyInput as Ax, type SlotCreateManyScheduleInput as Ay, type SlotCreateManyScheduleInputEnvelope as Az, type $SavedDoctorHospitalPayload as B, type SpecializationCreateOrConnectWithoutHospitalSpecializationInput as B$, type SlotMinOrderByAggregateInput as B0, type SlotNullableScalarRelationFilter as B1, type SlotOmit as B2, type SlotOrderByRelationAggregateInput as B3, type SlotOrderByWithAggregationInput as B4, type SlotOrderByWithRelationInput as B5, type SlotScalarWhereInput as B6, type SlotScalarWhereWithAggregatesInput as B7, type SlotSelect as B8, type SlotSelectCreateManyAndReturn as B9, type SlotUpdateWithoutScheduleInput as BA, type SlotUpsertArgs as BB, type SlotUpsertWithWhereUniqueWithoutScheduleInput as BC, type SlotUpsertWithoutAppointmentInput as BD, type SlotWhereInput as BE, type SlotWhereUniqueInput as BF, type SortOrderInput as BG, type Specialization$DoctorSpecializationArgs as BH, type Specialization$HospitalSpecializationArgs as BI, type SpecializationAggregateArgs as BJ, type SpecializationCountAggregateInputType as BK, type SpecializationCountAggregateOutputType as BL, type SpecializationCountArgs as BM, type SpecializationCountOrderByAggregateInput as BN, type SpecializationCountOutputType as BO, type SpecializationCountOutputTypeCountDoctorSpecializationArgs as BP, type SpecializationCountOutputTypeCountHospitalSpecializationArgs as BQ, type SpecializationCountOutputTypeDefaultArgs as BR, type SpecializationCountOutputTypeSelect as BS, type SpecializationCreateArgs as BT, type SpecializationCreateInput as BU, type SpecializationCreateManyAndReturnArgs as BV, type SpecializationCreateManyArgs as BW, type SpecializationCreateManyInput as BX, type SpecializationCreateNestedOneWithoutDoctorSpecializationInput as BY, type SpecializationCreateNestedOneWithoutHospitalSpecializationInput as BZ, type SpecializationCreateOrConnectWithoutDoctorSpecializationInput as B_, type SlotSelectScalar as Ba, type SlotSelectUpdateManyAndReturn as Bb, type SlotSlotStartScheduleIdDateCompoundUniqueInput as Bc, type SlotUncheckedCreateInput as Bd, type SlotUncheckedCreateNestedManyWithoutScheduleInput as Be, type SlotUncheckedCreateNestedOneWithoutAppointmentInput as Bf, type SlotUncheckedCreateWithoutAppointmentInput as Bg, type SlotUncheckedCreateWithoutScheduleInput as Bh, type SlotUncheckedUpdateInput as Bi, type SlotUncheckedUpdateManyInput as Bj, type SlotUncheckedUpdateManyWithoutScheduleInput as Bk, type SlotUncheckedUpdateManyWithoutScheduleNestedInput as Bl, type SlotUncheckedUpdateOneWithoutAppointmentNestedInput as Bm, type SlotUncheckedUpdateWithoutAppointmentInput as Bn, type SlotUncheckedUpdateWithoutScheduleInput as Bo, type SlotUpdateArgs as Bp, type SlotUpdateInput as Bq, type SlotUpdateManyAndReturnArgs as Br, type SlotUpdateManyArgs as Bs, type SlotUpdateManyMutationInput as Bt, type SlotUpdateManyWithWhereWithoutScheduleInput as Bu, type SlotUpdateManyWithoutScheduleNestedInput as Bv, type SlotUpdateOneWithoutAppointmentNestedInput as Bw, type SlotUpdateToOneWithWhereWithoutAppointmentInput as Bx, type SlotUpdateWithWhereUniqueWithoutScheduleInput as By, type SlotUpdateWithoutAppointmentInput as Bz, type $SchedulePayload as C, type StringNullableWithAggregatesFilter as C$, type SpecializationCreateWithoutDoctorSpecializationInput as C0, type SpecializationCreateWithoutHospitalSpecializationInput as C1, type SpecializationDefaultArgs as C2, type SpecializationDelegate as C3, type SpecializationDeleteArgs as C4, type SpecializationDeleteManyArgs as C5, type SpecializationFieldRefs as C6, type SpecializationFindFirstArgs as C7, type SpecializationFindFirstOrThrowArgs as C8, type SpecializationFindManyArgs as C9, type SpecializationUncheckedUpdateInput as CA, type SpecializationUncheckedUpdateManyInput as CB, type SpecializationUncheckedUpdateWithoutDoctorSpecializationInput as CC, type SpecializationUncheckedUpdateWithoutHospitalSpecializationInput as CD, type SpecializationUpdateArgs as CE, type SpecializationUpdateInput as CF, type SpecializationUpdateManyAndReturnArgs as CG, type SpecializationUpdateManyArgs as CH, type SpecializationUpdateManyMutationInput as CI, type SpecializationUpdateOneRequiredWithoutDoctorSpecializationNestedInput as CJ, type SpecializationUpdateOneRequiredWithoutHospitalSpecializationNestedInput as CK, type SpecializationUpdateToOneWithWhereWithoutDoctorSpecializationInput as CL, type SpecializationUpdateToOneWithWhereWithoutHospitalSpecializationInput as CM, type SpecializationUpdateWithoutDoctorSpecializationInput as CN, type SpecializationUpdateWithoutHospitalSpecializationInput as CO, type SpecializationUpsertArgs as CP, type SpecializationUpsertWithoutDoctorSpecializationInput as CQ, type SpecializationUpsertWithoutHospitalSpecializationInput as CR, type SpecializationWhereInput as CS, type SpecializationWhereUniqueInput as CT, Sql as CU, type Strict as CV, type StringFieldRefInput as CW, type StringFieldUpdateOperationsInput as CX, type StringFilter as CY, type StringNullableFilter as CZ, type StringNullableListFilter as C_, type SpecializationFindUniqueArgs as Ca, type SpecializationFindUniqueOrThrowArgs as Cb, type SpecializationGetPayload as Cc, type SpecializationGroupByArgs as Cd, type SpecializationGroupByOutputType as Ce, type SpecializationInclude as Cf, type SpecializationIncludeCreateManyAndReturn as Cg, type SpecializationIncludeUpdateManyAndReturn as Ch, type SpecializationMaxAggregateInputType as Ci, type SpecializationMaxAggregateOutputType as Cj, type SpecializationMaxOrderByAggregateInput as Ck, type SpecializationMinAggregateInputType as Cl, type SpecializationMinAggregateOutputType as Cm, type SpecializationMinOrderByAggregateInput as Cn, type SpecializationOmit as Co, type SpecializationOrderByWithAggregationInput as Cp, type SpecializationOrderByWithRelationInput as Cq, type SpecializationScalarRelationFilter as Cr, type SpecializationScalarWhereWithAggregatesInput as Cs, type SpecializationSelect as Ct, type SpecializationSelectCreateManyAndReturn as Cu, type SpecializationSelectScalar as Cv, type SpecializationSelectUpdateManyAndReturn as Cw, type SpecializationUncheckedCreateInput as Cx, type SpecializationUncheckedCreateWithoutDoctorSpecializationInput as Cy, type SpecializationUncheckedCreateWithoutHospitalSpecializationInput as Cz, type DoctorModel as D, type UserCreateOrConnectWithoutAppointment_Appointment_approvedByToUserInput as D$, type StringWithAggregatesFilter as D0, type Subset as D1, type SubsetIntersection as D2, type TransactionClient as D3, type True as D4, type TypeMap as D5, type TypeMapCb as D6, type UnEnumerate as D7, type Union as D8, type User$Appointment_Appointment_approvedByToUserArgs as D9, type UserCountOutputTypeCountReviewArgs as DA, type UserCountOutputTypeCountSavedDoctorHospitalArgs as DB, type UserCountOutputTypeCountScheduleArgs as DC, type UserCountOutputTypeCountSearchLogArgs as DD, type UserCountOutputTypeCountSessionArgs as DE, type UserCountOutputTypeDefaultArgs as DF, type UserCountOutputTypeSelect as DG, type UserCreateArgs as DH, type UserCreateInput as DI, type UserCreateManyAndReturnArgs as DJ, type UserCreateManyArgs as DK, type UserCreateManyInput as DL, type UserCreateNestedOneWithoutAccountInput as DM, type UserCreateNestedOneWithoutAppointment_Appointment_approvedByToUserInput as DN, type UserCreateNestedOneWithoutAppointment_Appointment_customerIdToUserInput as DO, type UserCreateNestedOneWithoutAuditLogInput as DP, type UserCreateNestedOneWithoutDoctorApplicationInput as DQ, type UserCreateNestedOneWithoutDoctorInput as DR, type UserCreateNestedOneWithoutHospitalInput as DS, type UserCreateNestedOneWithoutNotificationInput as DT, type UserCreateNestedOneWithoutPaymentInput as DU, type UserCreateNestedOneWithoutReviewInput as DV, type UserCreateNestedOneWithoutSavedDoctorHospitalInput as DW, type UserCreateNestedOneWithoutScheduleInput as DX, type UserCreateNestedOneWithoutSearchLogInput as DY, type UserCreateNestedOneWithoutSessionInput as DZ, type UserCreateOrConnectWithoutAccountInput as D_, type User$Appointment_Appointment_customerIdToUserArgs as Da, type User$AuditLogArgs as Db, type User$DoctorApplicationArgs as Dc, type User$DoctorArgs as Dd, type User$HospitalArgs as De, type User$NotificationArgs as Df, type User$PaymentArgs as Dg, type User$ReviewArgs as Dh, type User$SavedDoctorHospitalArgs as Di, type User$ScheduleArgs as Dj, type User$SearchLogArgs as Dk, type User$accountArgs as Dl, type User$sessionArgs as Dm, type UserAggregateArgs as Dn, type UserCountAggregateInputType as Do, type UserCountAggregateOutputType as Dp, type UserCountArgs as Dq, type UserCountOrderByAggregateInput as Dr, type UserCountOutputType as Ds, type UserCountOutputTypeCountAccountArgs as Dt, type UserCountOutputTypeCountAppointment_Appointment_approvedByToUserArgs as Du, type UserCountOutputTypeCountAppointment_Appointment_customerIdToUserArgs as Dv, type UserCountOutputTypeCountAuditLogArgs as Dw, type UserCountOutputTypeCountDoctorApplicationArgs as Dx, type UserCountOutputTypeCountNotificationArgs as Dy, type UserCountOutputTypeCountPaymentArgs as Dz, type $SearchLogPayload as E, type UserUncheckedCreateWithoutDoctorApplicationInput as E$, type UserCreateOrConnectWithoutAppointment_Appointment_customerIdToUserInput as E0, type UserCreateOrConnectWithoutAuditLogInput as E1, type UserCreateOrConnectWithoutDoctorApplicationInput as E2, type UserCreateOrConnectWithoutDoctorInput as E3, type UserCreateOrConnectWithoutHospitalInput as E4, type UserCreateOrConnectWithoutNotificationInput as E5, type UserCreateOrConnectWithoutPaymentInput as E6, type UserCreateOrConnectWithoutReviewInput as E7, type UserCreateOrConnectWithoutSavedDoctorHospitalInput as E8, type UserCreateOrConnectWithoutScheduleInput as E9, type UserGetPayload as EA, type UserGroupByArgs as EB, type UserGroupByOutputType as EC, type UserInclude as ED, type UserIncludeCreateManyAndReturn as EE, type UserIncludeUpdateManyAndReturn as EF, type UserMaxAggregateInputType as EG, type UserMaxAggregateOutputType as EH, type UserMaxOrderByAggregateInput as EI, type UserMinAggregateInputType as EJ, type UserMinAggregateOutputType as EK, type UserMinOrderByAggregateInput as EL, type UserNullableScalarRelationFilter as EM, type UserOmit as EN, type UserOrderByWithAggregationInput as EO, type UserOrderByWithRelationInput as EP, type UserScalarRelationFilter as EQ, type UserScalarWhereWithAggregatesInput as ER, type UserSelect as ES, type UserSelectCreateManyAndReturn as ET, type UserSelectScalar as EU, type UserSelectUpdateManyAndReturn as EV, type UserUncheckedCreateInput as EW, type UserUncheckedCreateWithoutAccountInput as EX, type UserUncheckedCreateWithoutAppointment_Appointment_approvedByToUserInput as EY, type UserUncheckedCreateWithoutAppointment_Appointment_customerIdToUserInput as EZ, type UserUncheckedCreateWithoutAuditLogInput as E_, type UserCreateOrConnectWithoutSearchLogInput as Ea, type UserCreateOrConnectWithoutSessionInput as Eb, type UserCreateWithoutAccountInput as Ec, type UserCreateWithoutAppointment_Appointment_approvedByToUserInput as Ed, type UserCreateWithoutAppointment_Appointment_customerIdToUserInput as Ee, type UserCreateWithoutAuditLogInput as Ef, type UserCreateWithoutDoctorApplicationInput as Eg, type UserCreateWithoutDoctorInput as Eh, type UserCreateWithoutHospitalInput as Ei, type UserCreateWithoutNotificationInput as Ej, type UserCreateWithoutPaymentInput as Ek, type UserCreateWithoutReviewInput as El, type UserCreateWithoutSavedDoctorHospitalInput as Em, type UserCreateWithoutScheduleInput as En, type UserCreateWithoutSearchLogInput as Eo, type UserCreateWithoutSessionInput as Ep, type UserDefaultArgs as Eq, type UserDelegate as Er, type UserDeleteArgs as Es, type UserDeleteManyArgs as Et, type UserFieldRefs as Eu, type UserFindFirstArgs as Ev, type UserFindFirstOrThrowArgs as Ew, type UserFindManyArgs as Ex, type UserFindUniqueArgs as Ey, type UserFindUniqueOrThrowArgs as Ez, type $SlotPayload as F, type UserUpdateWithoutDoctorInput as F$, type UserUncheckedCreateWithoutDoctorInput as F0, type UserUncheckedCreateWithoutHospitalInput as F1, type UserUncheckedCreateWithoutNotificationInput as F2, type UserUncheckedCreateWithoutPaymentInput as F3, type UserUncheckedCreateWithoutReviewInput as F4, type UserUncheckedCreateWithoutSavedDoctorHospitalInput as F5, type UserUncheckedCreateWithoutScheduleInput as F6, type UserUncheckedCreateWithoutSearchLogInput as F7, type UserUncheckedCreateWithoutSessionInput as F8, type UserUncheckedUpdateInput as F9, type UserUpdateOneRequiredWithoutNotificationNestedInput as FA, type UserUpdateOneRequiredWithoutPaymentNestedInput as FB, type UserUpdateOneRequiredWithoutReviewNestedInput as FC, type UserUpdateOneRequiredWithoutSavedDoctorHospitalNestedInput as FD, type UserUpdateOneRequiredWithoutScheduleNestedInput as FE, type UserUpdateOneRequiredWithoutSearchLogNestedInput as FF, type UserUpdateOneRequiredWithoutSessionNestedInput as FG, type UserUpdateOneWithoutAppointment_Appointment_approvedByToUserNestedInput as FH, type UserUpdateToOneWithWhereWithoutAccountInput as FI, type UserUpdateToOneWithWhereWithoutAppointment_Appointment_approvedByToUserInput as FJ, type UserUpdateToOneWithWhereWithoutAppointment_Appointment_customerIdToUserInput as FK, type UserUpdateToOneWithWhereWithoutAuditLogInput as FL, type UserUpdateToOneWithWhereWithoutDoctorApplicationInput as FM, type UserUpdateToOneWithWhereWithoutDoctorInput as FN, type UserUpdateToOneWithWhereWithoutHospitalInput as FO, type UserUpdateToOneWithWhereWithoutNotificationInput as FP, type UserUpdateToOneWithWhereWithoutPaymentInput as FQ, type UserUpdateToOneWithWhereWithoutReviewInput as FR, type UserUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as FS, type UserUpdateToOneWithWhereWithoutScheduleInput as FT, type UserUpdateToOneWithWhereWithoutSearchLogInput as FU, type UserUpdateToOneWithWhereWithoutSessionInput as FV, type UserUpdateWithoutAccountInput as FW, type UserUpdateWithoutAppointment_Appointment_approvedByToUserInput as FX, type UserUpdateWithoutAppointment_Appointment_customerIdToUserInput as FY, type UserUpdateWithoutAuditLogInput as FZ, type UserUpdateWithoutDoctorApplicationInput as F_, type UserUncheckedUpdateManyInput as Fa, type UserUncheckedUpdateWithoutAccountInput as Fb, type UserUncheckedUpdateWithoutAppointment_Appointment_approvedByToUserInput as Fc, type UserUncheckedUpdateWithoutAppointment_Appointment_customerIdToUserInput as Fd, type UserUncheckedUpdateWithoutAuditLogInput as Fe, type UserUncheckedUpdateWithoutDoctorApplicationInput as Ff, type UserUncheckedUpdateWithoutDoctorInput as Fg, type UserUncheckedUpdateWithoutHospitalInput as Fh, type UserUncheckedUpdateWithoutNotificationInput as Fi, type UserUncheckedUpdateWithoutPaymentInput as Fj, type UserUncheckedUpdateWithoutReviewInput as Fk, type UserUncheckedUpdateWithoutSavedDoctorHospitalInput as Fl, type UserUncheckedUpdateWithoutScheduleInput as Fm, type UserUncheckedUpdateWithoutSearchLogInput as Fn, type UserUncheckedUpdateWithoutSessionInput as Fo, type UserUpdateArgs as Fp, type UserUpdateInput as Fq, type UserUpdateManyAndReturnArgs as Fr, type UserUpdateManyArgs as Fs, type UserUpdateManyMutationInput as Ft, type UserUpdateOneRequiredWithoutAccountNestedInput as Fu, type UserUpdateOneRequiredWithoutAppointment_Appointment_customerIdToUserNestedInput as Fv, type UserUpdateOneRequiredWithoutAuditLogNestedInput as Fw, type UserUpdateOneRequiredWithoutDoctorApplicationNestedInput as Fx, type UserUpdateOneRequiredWithoutDoctorNestedInput as Fy, type UserUpdateOneRequiredWithoutHospitalNestedInput as Fz, type $SpecializationPayload as G, type accountOmit as G$, type UserUpdateWithoutHospitalInput as G0, type UserUpdateWithoutNotificationInput as G1, type UserUpdateWithoutPaymentInput as G2, type UserUpdateWithoutReviewInput as G3, type UserUpdateWithoutSavedDoctorHospitalInput as G4, type UserUpdateWithoutScheduleInput as G5, type UserUpdateWithoutSearchLogInput as G6, type UserUpdateWithoutSessionInput as G7, type UserUpsertArgs as G8, type UserUpsertWithoutAccountInput as G9, type accountCreateArgs as GA, type accountCreateInput as GB, type accountCreateManyAndReturnArgs as GC, type accountCreateManyArgs as GD, type accountCreateManyInput as GE, type accountCreateManyUserInput as GF, type accountCreateManyUserInputEnvelope as GG, type accountCreateNestedManyWithoutUserInput as GH, type accountCreateOrConnectWithoutUserInput as GI, type accountCreateWithoutUserInput as GJ, type accountDefaultArgs as GK, type accountDelegate as GL, type accountDeleteArgs as GM, type accountDeleteManyArgs as GN, type accountFieldRefs as GO, type accountFindFirstArgs as GP, type accountFindFirstOrThrowArgs as GQ, type accountFindManyArgs as GR, type accountFindUniqueArgs as GS, type accountFindUniqueOrThrowArgs as GT, type accountGetPayload as GU, type accountGroupByArgs as GV, type accountInclude as GW, type accountIncludeCreateManyAndReturn as GX, type accountIncludeUpdateManyAndReturn as GY, type accountMaxOrderByAggregateInput as GZ, type accountMinOrderByAggregateInput as G_, type UserUpsertWithoutAppointment_Appointment_approvedByToUserInput as Ga, type UserUpsertWithoutAppointment_Appointment_customerIdToUserInput as Gb, type UserUpsertWithoutAuditLogInput as Gc, type UserUpsertWithoutDoctorApplicationInput as Gd, type UserUpsertWithoutDoctorInput as Ge, type UserUpsertWithoutHospitalInput as Gf, type UserUpsertWithoutNotificationInput as Gg, type UserUpsertWithoutPaymentInput as Gh, type UserUpsertWithoutReviewInput as Gi, type UserUpsertWithoutSavedDoctorHospitalInput as Gj, type UserUpsertWithoutScheduleInput as Gk, type UserUpsertWithoutSearchLogInput as Gl, type UserUpsertWithoutSessionInput as Gm, type UserWhereInput as Gn, type UserWhereUniqueInput as Go, type VerificationAggregateArgs as Gp, type VerificationCountAggregateInputType as Gq, type VerificationCountAggregateOutputType as Gr, type VerificationGroupByOutputType as Gs, type VerificationMaxAggregateInputType as Gt, type VerificationMaxAggregateOutputType as Gu, type VerificationMinAggregateInputType as Gv, type VerificationMinAggregateOutputType as Gw, type XOR as Gx, type accountCountArgs as Gy, type accountCountOrderByAggregateInput as Gz, type HospitalModel as H, type sessionMaxOrderByAggregateInput as H$, type accountOrderByRelationAggregateInput as H0, type accountOrderByWithAggregationInput as H1, type accountOrderByWithRelationInput as H2, type accountScalarWhereInput as H3, type accountScalarWhereWithAggregatesInput as H4, type accountSelect as H5, type accountSelectCreateManyAndReturn as H6, type accountSelectScalar as H7, type accountSelectUpdateManyAndReturn as H8, type accountUncheckedCreateInput as H9, type sessionCountArgs as HA, type sessionCountOrderByAggregateInput as HB, type sessionCreateArgs as HC, type sessionCreateInput as HD, type sessionCreateManyAndReturnArgs as HE, type sessionCreateManyArgs as HF, type sessionCreateManyInput as HG, type sessionCreateManyUserInput as HH, type sessionCreateManyUserInputEnvelope as HI, type sessionCreateNestedManyWithoutUserInput as HJ, type sessionCreateOrConnectWithoutUserInput as HK, type sessionCreateWithoutUserInput as HL, type sessionDefaultArgs as HM, type sessionDelegate as HN, type sessionDeleteArgs as HO, type sessionDeleteManyArgs as HP, type sessionFieldRefs as HQ, type sessionFindFirstArgs as HR, type sessionFindFirstOrThrowArgs as HS, type sessionFindManyArgs as HT, type sessionFindUniqueArgs as HU, type sessionFindUniqueOrThrowArgs as HV, type sessionGetPayload as HW, type sessionGroupByArgs as HX, type sessionInclude as HY, type sessionIncludeCreateManyAndReturn as HZ, type sessionIncludeUpdateManyAndReturn as H_, type accountUncheckedCreateNestedManyWithoutUserInput as Ha, type accountUncheckedCreateWithoutUserInput as Hb, type accountUncheckedUpdateInput as Hc, type accountUncheckedUpdateManyInput as Hd, type accountUncheckedUpdateManyWithoutUserInput as He, type accountUncheckedUpdateManyWithoutUserNestedInput as Hf, type accountUncheckedUpdateWithoutUserInput as Hg, type accountUpdateArgs as Hh, type accountUpdateInput as Hi, type accountUpdateManyAndReturnArgs as Hj, type accountUpdateManyArgs as Hk, type accountUpdateManyMutationInput as Hl, type accountUpdateManyWithWhereWithoutUserInput as Hm, type accountUpdateManyWithoutUserNestedInput as Hn, type accountUpdateWithWhereUniqueWithoutUserInput as Ho, type accountUpdateWithoutUserInput as Hp, type accountUpsertArgs as Hq, type accountUpsertWithWhereUniqueWithoutUserInput as Hr, type accountWhereInput as Hs, type accountWhereUniqueInput as Ht, defineExtension as Hu, empty as Hv, getExtensionContext as Hw, join as Hx, prismaVersion as Hy, raw as Hz, type $UserPayload as I, type verificationUncheckedUpdateInput as I$, type sessionMinOrderByAggregateInput as I0, type sessionOmit as I1, type sessionOrderByRelationAggregateInput as I2, type sessionOrderByWithAggregationInput as I3, type sessionOrderByWithRelationInput as I4, type sessionScalarWhereInput as I5, type sessionScalarWhereWithAggregatesInput as I6, type sessionSelect as I7, type sessionSelectCreateManyAndReturn as I8, type sessionSelectScalar as I9, type verificationCreateInput as IA, type verificationCreateManyAndReturnArgs as IB, type verificationCreateManyArgs as IC, type verificationCreateManyInput as ID, type verificationDefaultArgs as IE, type verificationDelegate as IF, type verificationDeleteArgs as IG, type verificationDeleteManyArgs as IH, type verificationFieldRefs as II, type verificationFindFirstArgs as IJ, type verificationFindFirstOrThrowArgs as IK, type verificationFindManyArgs as IL, type verificationFindUniqueArgs as IM, type verificationFindUniqueOrThrowArgs as IN, type verificationGetPayload as IO, type verificationGroupByArgs as IP, type verificationMaxOrderByAggregateInput as IQ, type verificationMinOrderByAggregateInput as IR, type verificationOmit as IS, type verificationOrderByWithAggregationInput as IT, type verificationOrderByWithRelationInput as IU, type verificationScalarWhereWithAggregatesInput as IV, type verificationSelect as IW, type verificationSelectCreateManyAndReturn as IX, type verificationSelectScalar as IY, type verificationSelectUpdateManyAndReturn as IZ, type verificationUncheckedCreateInput as I_, type sessionSelectUpdateManyAndReturn as Ia, type sessionUncheckedCreateInput as Ib, type sessionUncheckedCreateNestedManyWithoutUserInput as Ic, type sessionUncheckedCreateWithoutUserInput as Id, type sessionUncheckedUpdateInput as Ie, type sessionUncheckedUpdateManyInput as If, type sessionUncheckedUpdateManyWithoutUserInput as Ig, type sessionUncheckedUpdateManyWithoutUserNestedInput as Ih, type sessionUncheckedUpdateWithoutUserInput as Ii, type sessionUpdateArgs as Ij, type sessionUpdateInput as Ik, type sessionUpdateManyAndReturnArgs as Il, type sessionUpdateManyArgs as Im, type sessionUpdateManyMutationInput as In, type sessionUpdateManyWithWhereWithoutUserInput as Io, type sessionUpdateManyWithoutUserNestedInput as Ip, type sessionUpdateWithWhereUniqueWithoutUserInput as Iq, type sessionUpdateWithoutUserInput as Ir, type sessionUpsertArgs as Is, type sessionUpsertWithWhereUniqueWithoutUserInput as It, type sessionWhereInput as Iu, type sessionWhereUniqueInput as Iv, sql as Iw, type verificationCountArgs as Ix, type verificationCountOrderByAggregateInput as Iy, type verificationCreateArgs as Iz, type $accountPayload as J, type verificationUncheckedUpdateManyInput as J0, type verificationUpdateArgs as J1, type verificationUpdateInput as J2, type verificationUpdateManyAndReturnArgs as J3, type verificationUpdateManyArgs as J4, type verificationUpdateManyMutationInput as J5, type verificationUpsertArgs as J6, type verificationWhereInput as J7, type verificationWhereUniqueInput as J8, Decimal as J9, SortOrder as JA, NullableJsonNullValueInput as JB, QueryMode as JC, NullsOrder as JD, JsonNullValueFilter as JE, type LogOptions as JF, getPrismaClientClass as JG, NullTypes as Ja, DbNull as Jb, JsonNull as Jc, AnyNull as Jd, ModelName as Je, TransactionIsolationLevel as Jf, AppointmentScalarFieldEnum as Jg, AuditLogScalarFieldEnum as Jh, DoctorScalarFieldEnum as Ji, DoctorApplicationScalarFieldEnum as Jj, DoctorHospitalProfileScalarFieldEnum as Jk, DoctorSpecializationScalarFieldEnum as Jl, HospitalScalarFieldEnum as Jm, HospitalSpecializationScalarFieldEnum as Jn, NotificationScalarFieldEnum as Jo, PaymentScalarFieldEnum as Jp, ReviewScalarFieldEnum as Jq, SavedDoctorHospitalScalarFieldEnum as Jr, ScheduleScalarFieldEnum as Js, SearchLogScalarFieldEnum as Jt, SlotScalarFieldEnum as Ju, SpecializationScalarFieldEnum as Jv, UserScalarFieldEnum as Jw, AccountScalarFieldEnum as Jx, SessionScalarFieldEnum as Jy, VerificationScalarFieldEnum as Jz, type $sessionPayload as K, type LogLevel as L, type $verificationPayload as M, type NotificationModel as N, type AccountAggregateArgs as O, type PaymentModel as P, type AccountCountAggregateInputType as Q, type ReviewModel as R, type SavedDoctorHospitalModel as S, type AccountCountAggregateOutputType as T, type UserModel as U, type AccountGroupByOutputType as V, type AccountListRelationFilter as W, type AccountMaxAggregateInputType as X, type AccountMaxAggregateOutputType as Y, type AccountMinAggregateInputType as Z, type AccountMinAggregateOutputType as _, type AuditLogModel as a, type AppointmentCreateWithoutUser_Appointment_customerIdToUserInput as a$, type AggregateAccount as a0, type AggregateAppointment as a1, type AggregateAuditLog as a2, type AggregateDoctor as a3, type AggregateDoctorApplication as a4, type AggregateDoctorHospitalProfile as a5, type AggregateDoctorSpecialization as a6, type AggregateHospital as a7, type AggregateHospitalSpecialization as a8, type AggregateNotification as a9, type AppointmentCreateManyInput as aA, type AppointmentCreateManyScheduleInput as aB, type AppointmentCreateManyScheduleInputEnvelope as aC, type AppointmentCreateManyUser_Appointment_approvedByToUserInput as aD, type AppointmentCreateManyUser_Appointment_approvedByToUserInputEnvelope as aE, type AppointmentCreateManyUser_Appointment_customerIdToUserInput as aF, type AppointmentCreateManyUser_Appointment_customerIdToUserInputEnvelope as aG, type AppointmentCreateNestedManyWithoutDoctorInput as aH, type AppointmentCreateNestedManyWithoutHospitalInput as aI, type AppointmentCreateNestedManyWithoutScheduleInput as aJ, type AppointmentCreateNestedManyWithoutUser_Appointment_approvedByToUserInput as aK, type AppointmentCreateNestedManyWithoutUser_Appointment_customerIdToUserInput as aL, type AppointmentCreateNestedOneWithoutPaymentInput as aM, type AppointmentCreateNestedOneWithoutSlotInput as aN, type AppointmentCreateOrConnectWithoutDoctorInput as aO, type AppointmentCreateOrConnectWithoutHospitalInput as aP, type AppointmentCreateOrConnectWithoutPaymentInput as aQ, type AppointmentCreateOrConnectWithoutScheduleInput as aR, type AppointmentCreateOrConnectWithoutSlotInput as aS, type AppointmentCreateOrConnectWithoutUser_Appointment_approvedByToUserInput as aT, type AppointmentCreateOrConnectWithoutUser_Appointment_customerIdToUserInput as aU, type AppointmentCreateWithoutDoctorInput as aV, type AppointmentCreateWithoutHospitalInput as aW, type AppointmentCreateWithoutPaymentInput as aX, type AppointmentCreateWithoutScheduleInput as aY, type AppointmentCreateWithoutSlotInput as aZ, type AppointmentCreateWithoutUser_Appointment_approvedByToUserInput as a_, type AggregatePayment as aa, type AggregateReview as ab, type AggregateSavedDoctorHospital as ac, type AggregateSchedule as ad, type AggregateSearchLog as ae, type AggregateSession as af, type AggregateSlot as ag, type AggregateSpecialization as ah, type AggregateUser as ai, type AggregateVerification as aj, type Appointment$PaymentArgs as ak, type Appointment$SlotArgs as al, type Appointment$User_Appointment_approvedByToUserArgs as am, type AppointmentAggregateArgs as an, type AppointmentCountAggregateInputType as ao, type AppointmentCountAggregateOutputType as ap, type AppointmentCountArgs as aq, type AppointmentCountOrderByAggregateInput as ar, type AppointmentCreateArgs as as, type AppointmentCreateInput as at, type AppointmentCreateManyAndReturnArgs as au, type AppointmentCreateManyArgs as av, type AppointmentCreateManyDoctorInput as aw, type AppointmentCreateManyDoctorInputEnvelope as ax, type AppointmentCreateManyHospitalInput as ay, type AppointmentCreateManyHospitalInputEnvelope as az, type DoctorApplicationModel as b, type AppointmentUncheckedUpdateWithoutScheduleInput as b$, type AppointmentDefaultArgs as b0, type AppointmentDelegate as b1, type AppointmentDeleteArgs as b2, type AppointmentDeleteManyArgs as b3, type AppointmentFieldRefs as b4, type AppointmentFindFirstArgs as b5, type AppointmentFindFirstOrThrowArgs as b6, type AppointmentFindManyArgs as b7, type AppointmentFindUniqueArgs as b8, type AppointmentFindUniqueOrThrowArgs as b9, type AppointmentUncheckedCreateNestedManyWithoutDoctorInput as bA, type AppointmentUncheckedCreateNestedManyWithoutHospitalInput as bB, type AppointmentUncheckedCreateNestedManyWithoutScheduleInput as bC, type AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_approvedByToUserInput as bD, type AppointmentUncheckedCreateNestedManyWithoutUser_Appointment_customerIdToUserInput as bE, type AppointmentUncheckedCreateWithoutDoctorInput as bF, type AppointmentUncheckedCreateWithoutHospitalInput as bG, type AppointmentUncheckedCreateWithoutPaymentInput as bH, type AppointmentUncheckedCreateWithoutScheduleInput as bI, type AppointmentUncheckedCreateWithoutSlotInput as bJ, type AppointmentUncheckedCreateWithoutUser_Appointment_approvedByToUserInput as bK, type AppointmentUncheckedCreateWithoutUser_Appointment_customerIdToUserInput as bL, type AppointmentUncheckedUpdateInput as bM, type AppointmentUncheckedUpdateManyInput as bN, type AppointmentUncheckedUpdateManyWithoutDoctorInput as bO, type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput as bP, type AppointmentUncheckedUpdateManyWithoutHospitalInput as bQ, type AppointmentUncheckedUpdateManyWithoutHospitalNestedInput as bR, type AppointmentUncheckedUpdateManyWithoutScheduleInput as bS, type AppointmentUncheckedUpdateManyWithoutScheduleNestedInput as bT, type AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserInput as bU, type AppointmentUncheckedUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput as bV, type AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserInput as bW, type AppointmentUncheckedUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput as bX, type AppointmentUncheckedUpdateWithoutDoctorInput as bY, type AppointmentUncheckedUpdateWithoutHospitalInput as bZ, type AppointmentUncheckedUpdateWithoutPaymentInput as b_, type AppointmentGetPayload as ba, type AppointmentGroupByArgs as bb, type AppointmentGroupByOutputType as bc, type AppointmentInclude as bd, type AppointmentIncludeCreateManyAndReturn as be, type AppointmentIncludeUpdateManyAndReturn as bf, type AppointmentListRelationFilter as bg, type AppointmentMaxAggregateInputType as bh, type AppointmentMaxAggregateOutputType as bi, type AppointmentMaxOrderByAggregateInput as bj, type AppointmentMinAggregateInputType as bk, type AppointmentMinAggregateOutputType as bl, type AppointmentMinOrderByAggregateInput as bm, type AppointmentNullableScalarRelationFilter as bn, type AppointmentOmit as bo, type AppointmentOrderByRelationAggregateInput as bp, type AppointmentOrderByWithAggregationInput as bq, type AppointmentOrderByWithRelationInput as br, type AppointmentScalarRelationFilter as bs, type AppointmentScalarWhereInput as bt, type AppointmentScalarWhereWithAggregatesInput as bu, type AppointmentSelect as bv, type AppointmentSelectCreateManyAndReturn as bw, type AppointmentSelectScalar as bx, type AppointmentSelectUpdateManyAndReturn as by, type AppointmentUncheckedCreateInput as bz, type DoctorHospitalProfileModel as c, type AuditLogDelegate as c$, type AppointmentUncheckedUpdateWithoutSlotInput as c0, type AppointmentUncheckedUpdateWithoutUser_Appointment_approvedByToUserInput as c1, type AppointmentUncheckedUpdateWithoutUser_Appointment_customerIdToUserInput as c2, type AppointmentUpdateArgs as c3, type AppointmentUpdateInput as c4, type AppointmentUpdateManyAndReturnArgs as c5, type AppointmentUpdateManyArgs as c6, type AppointmentUpdateManyMutationInput as c7, type AppointmentUpdateManyWithWhereWithoutDoctorInput as c8, type AppointmentUpdateManyWithWhereWithoutHospitalInput as c9, type AppointmentUpsertWithWhereUniqueWithoutHospitalInput as cA, type AppointmentUpsertWithWhereUniqueWithoutScheduleInput as cB, type AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput as cC, type AppointmentUpsertWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput as cD, type AppointmentUpsertWithoutPaymentInput as cE, type AppointmentUpsertWithoutSlotInput as cF, type AppointmentWhereInput as cG, type AppointmentWhereUniqueInput as cH, type Args as cI, type At as cJ, type AtLeast as cK, type AuditLogAggregateArgs as cL, type AuditLogCountAggregateInputType as cM, type AuditLogCountAggregateOutputType as cN, type AuditLogCountArgs as cO, type AuditLogCountOrderByAggregateInput as cP, type AuditLogCreateArgs as cQ, type AuditLogCreateInput as cR, type AuditLogCreateManyAndReturnArgs as cS, type AuditLogCreateManyArgs as cT, type AuditLogCreateManyInput as cU, type AuditLogCreateManyUserInput as cV, type AuditLogCreateManyUserInputEnvelope as cW, type AuditLogCreateNestedManyWithoutUserInput as cX, type AuditLogCreateOrConnectWithoutUserInput as cY, type AuditLogCreateWithoutUserInput as cZ, type AuditLogDefaultArgs as c_, type AppointmentUpdateManyWithWhereWithoutScheduleInput as ca, type AppointmentUpdateManyWithWhereWithoutUser_Appointment_approvedByToUserInput as cb, type AppointmentUpdateManyWithWhereWithoutUser_Appointment_customerIdToUserInput as cc, type AppointmentUpdateManyWithoutDoctorNestedInput as cd, type AppointmentUpdateManyWithoutHospitalNestedInput as ce, type AppointmentUpdateManyWithoutScheduleNestedInput as cf, type AppointmentUpdateManyWithoutUser_Appointment_approvedByToUserNestedInput as cg, type AppointmentUpdateManyWithoutUser_Appointment_customerIdToUserNestedInput as ch, type AppointmentUpdateOneRequiredWithoutPaymentNestedInput as ci, type AppointmentUpdateOneWithoutSlotNestedInput as cj, type AppointmentUpdateToOneWithWhereWithoutPaymentInput as ck, type AppointmentUpdateToOneWithWhereWithoutSlotInput as cl, type AppointmentUpdateWithWhereUniqueWithoutDoctorInput as cm, type AppointmentUpdateWithWhereUniqueWithoutHospitalInput as cn, type AppointmentUpdateWithWhereUniqueWithoutScheduleInput as co, type AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_approvedByToUserInput as cp, type AppointmentUpdateWithWhereUniqueWithoutUser_Appointment_customerIdToUserInput as cq, type AppointmentUpdateWithoutDoctorInput as cr, type AppointmentUpdateWithoutHospitalInput as cs, type AppointmentUpdateWithoutPaymentInput as ct, type AppointmentUpdateWithoutScheduleInput as cu, type AppointmentUpdateWithoutSlotInput as cv, type AppointmentUpdateWithoutUser_Appointment_approvedByToUserInput as cw, type AppointmentUpdateWithoutUser_Appointment_customerIdToUserInput as cx, type AppointmentUpsertArgs as cy, type AppointmentUpsertWithWhereUniqueWithoutDoctorInput as cz, type DoctorSpecializationModel as d, type ComputeRaw as d$, type AuditLogDeleteArgs as d0, type AuditLogDeleteManyArgs as d1, type AuditLogFieldRefs as d2, type AuditLogFindFirstArgs as d3, type AuditLogFindFirstOrThrowArgs as d4, type AuditLogFindManyArgs as d5, type AuditLogFindUniqueArgs as d6, type AuditLogFindUniqueOrThrowArgs as d7, type AuditLogGetPayload as d8, type AuditLogGroupByArgs as d9, type AuditLogUncheckedUpdateManyInput as dA, type AuditLogUncheckedUpdateManyWithoutUserInput as dB, type AuditLogUncheckedUpdateManyWithoutUserNestedInput as dC, type AuditLogUncheckedUpdateWithoutUserInput as dD, type AuditLogUpdateArgs as dE, type AuditLogUpdateInput as dF, type AuditLogUpdateManyAndReturnArgs as dG, type AuditLogUpdateManyArgs as dH, type AuditLogUpdateManyMutationInput as dI, type AuditLogUpdateManyWithWhereWithoutUserInput as dJ, type AuditLogUpdateManyWithoutUserNestedInput as dK, type AuditLogUpdateWithWhereUniqueWithoutUserInput as dL, type AuditLogUpdateWithoutUserInput as dM, type AuditLogUpsertArgs as dN, type AuditLogUpsertWithWhereUniqueWithoutUserInput as dO, type AuditLogWhereInput as dP, type AuditLogWhereUniqueInput as dQ, type BatchPayload as dR, type BoolFieldUpdateOperationsInput as dS, type BoolFilter as dT, type BoolNullableFilter as dU, type BoolNullableWithAggregatesFilter as dV, type BoolWithAggregatesFilter as dW, type Boolean as dX, type BooleanFieldRefInput as dY, type Bytes as dZ, type CheckIsLogLevel as d_, type AuditLogGroupByOutputType as da, type AuditLogInclude as db, type AuditLogIncludeCreateManyAndReturn as dc, type AuditLogIncludeUpdateManyAndReturn as dd, type AuditLogListRelationFilter as de, type AuditLogMaxAggregateInputType as df, type AuditLogMaxAggregateOutputType as dg, type AuditLogMaxOrderByAggregateInput as dh, type AuditLogMinAggregateInputType as di, type AuditLogMinAggregateOutputType as dj, type AuditLogMinOrderByAggregateInput as dk, type AuditLogOmit as dl, type AuditLogOrderByRelationAggregateInput as dm, type AuditLogOrderByWithAggregationInput as dn, type AuditLogOrderByWithRelationInput as dp, type AuditLogScalarWhereInput as dq, type AuditLogScalarWhereWithAggregatesInput as dr, type AuditLogSelect as ds, type AuditLogSelectCreateManyAndReturn as dt, type AuditLogSelectScalar as du, type AuditLogSelectUpdateManyAndReturn as dv, type AuditLogUncheckedCreateInput as dw, type AuditLogUncheckedCreateNestedManyWithoutUserInput as dx, type AuditLogUncheckedCreateWithoutUserInput as dy, type AuditLogUncheckedUpdateInput as dz, type HospitalSpecializationModel as e, type DoctorApplicationMaxAggregateInputType as e$, type DMMF as e0, type DateTimeFieldRefInput as e1, type DateTimeFieldUpdateOperationsInput as e2, type DateTimeFilter as e3, type DateTimeNullableFilter as e4, type DateTimeNullableWithAggregatesFilter as e5, type DateTimeWithAggregatesFilter as e6, type DecimalFieldRefInput as e7, type DecimalFieldUpdateOperationsInput as e8, type DecimalFilter as e9, type DoctorApplicationCreateManyInput as eA, type DoctorApplicationCreateManyUserInput as eB, type DoctorApplicationCreateManyUserInputEnvelope as eC, type DoctorApplicationCreateNestedManyWithoutHospitalInput as eD, type DoctorApplicationCreateNestedManyWithoutUserInput as eE, type DoctorApplicationCreateOrConnectWithoutHospitalInput as eF, type DoctorApplicationCreateOrConnectWithoutUserInput as eG, type DoctorApplicationCreateWithoutHospitalInput as eH, type DoctorApplicationCreateWithoutUserInput as eI, type DoctorApplicationCreatespecializationIdsInput as eJ, type DoctorApplicationDefaultArgs as eK, type DoctorApplicationDelegate as eL, type DoctorApplicationDeleteArgs as eM, type DoctorApplicationDeleteManyArgs as eN, type DoctorApplicationFieldRefs as eO, type DoctorApplicationFindFirstArgs as eP, type DoctorApplicationFindFirstOrThrowArgs as eQ, type DoctorApplicationFindManyArgs as eR, type DoctorApplicationFindUniqueArgs as eS, type DoctorApplicationFindUniqueOrThrowArgs as eT, type DoctorApplicationGetPayload as eU, type DoctorApplicationGroupByArgs as eV, type DoctorApplicationGroupByOutputType as eW, type DoctorApplicationInclude as eX, type DoctorApplicationIncludeCreateManyAndReturn as eY, type DoctorApplicationIncludeUpdateManyAndReturn as eZ, type DoctorApplicationListRelationFilter as e_, type DecimalJsLike as ea, type DecimalNullableFilter as eb, type DecimalNullableWithAggregatesFilter as ec, type DecimalWithAggregatesFilter as ed, type DefaultPrismaClient as ee, type Doctor$AppointmentArgs as ef, type Doctor$DoctorHospitalProfileArgs as eg, type Doctor$DoctorSpecializationArgs as eh, type Doctor$ReviewArgs as ei, type Doctor$SavedDoctorHospitalArgs as ej, type Doctor$ScheduleArgs as ek, type DoctorAggregateArgs as el, type DoctorApplicationAggregateArgs as em, type DoctorApplicationAvgAggregateInputType as en, type DoctorApplicationAvgAggregateOutputType as eo, type DoctorApplicationAvgOrderByAggregateInput as ep, type DoctorApplicationCountAggregateInputType as eq, type DoctorApplicationCountAggregateOutputType as er, type DoctorApplicationCountArgs as es, type DoctorApplicationCountOrderByAggregateInput as et, type DoctorApplicationCreateArgs as eu, type DoctorApplicationCreateInput as ev, type DoctorApplicationCreateManyAndReturnArgs as ew, type DoctorApplicationCreateManyArgs as ex, type DoctorApplicationCreateManyHospitalInput as ey, type DoctorApplicationCreateManyHospitalInputEnvelope as ez, type ScheduleModel as f, type DoctorCountOutputTypeCountSavedDoctorHospitalArgs as f$, type DoctorApplicationMaxAggregateOutputType as f0, type DoctorApplicationMaxOrderByAggregateInput as f1, type DoctorApplicationMinAggregateInputType as f2, type DoctorApplicationMinAggregateOutputType as f3, type DoctorApplicationMinOrderByAggregateInput as f4, type DoctorApplicationOmit as f5, type DoctorApplicationOrderByRelationAggregateInput as f6, type DoctorApplicationOrderByWithAggregationInput as f7, type DoctorApplicationOrderByWithRelationInput as f8, type DoctorApplicationScalarWhereInput as f9, type DoctorApplicationUpdateManyWithWhereWithoutHospitalInput as fA, type DoctorApplicationUpdateManyWithWhereWithoutUserInput as fB, type DoctorApplicationUpdateManyWithoutHospitalNestedInput as fC, type DoctorApplicationUpdateManyWithoutUserNestedInput as fD, type DoctorApplicationUpdateWithWhereUniqueWithoutHospitalInput as fE, type DoctorApplicationUpdateWithWhereUniqueWithoutUserInput as fF, type DoctorApplicationUpdateWithoutHospitalInput as fG, type DoctorApplicationUpdateWithoutUserInput as fH, type DoctorApplicationUpdatespecializationIdsInput as fI, type DoctorApplicationUpsertArgs as fJ, type DoctorApplicationUpsertWithWhereUniqueWithoutHospitalInput as fK, type DoctorApplicationUpsertWithWhereUniqueWithoutUserInput as fL, type DoctorApplicationUserIdHospitalIdCompoundUniqueInput as fM, type DoctorApplicationWhereInput as fN, type DoctorApplicationWhereUniqueInput as fO, type DoctorAvgAggregateInputType as fP, type DoctorAvgAggregateOutputType as fQ, type DoctorAvgOrderByAggregateInput as fR, type DoctorCountAggregateInputType as fS, type DoctorCountAggregateOutputType as fT, type DoctorCountArgs as fU, type DoctorCountOrderByAggregateInput as fV, type DoctorCountOutputType as fW, type DoctorCountOutputTypeCountAppointmentArgs as fX, type DoctorCountOutputTypeCountDoctorHospitalProfileArgs as fY, type DoctorCountOutputTypeCountDoctorSpecializationArgs as fZ, type DoctorCountOutputTypeCountReviewArgs as f_, type DoctorApplicationScalarWhereWithAggregatesInput as fa, type DoctorApplicationSelect as fb, type DoctorApplicationSelectCreateManyAndReturn as fc, type DoctorApplicationSelectScalar as fd, type DoctorApplicationSelectUpdateManyAndReturn as fe, type DoctorApplicationSumAggregateInputType as ff, type DoctorApplicationSumAggregateOutputType as fg, type DoctorApplicationSumOrderByAggregateInput as fh, type DoctorApplicationUncheckedCreateInput as fi, type DoctorApplicationUncheckedCreateNestedManyWithoutHospitalInput as fj, type DoctorApplicationUncheckedCreateNestedManyWithoutUserInput as fk, type DoctorApplicationUncheckedCreateWithoutHospitalInput as fl, type DoctorApplicationUncheckedCreateWithoutUserInput as fm, type DoctorApplicationUncheckedUpdateInput as fn, type DoctorApplicationUncheckedUpdateManyInput as fo, type DoctorApplicationUncheckedUpdateManyWithoutHospitalInput as fp, type DoctorApplicationUncheckedUpdateManyWithoutHospitalNestedInput as fq, type DoctorApplicationUncheckedUpdateManyWithoutUserInput as fr, type DoctorApplicationUncheckedUpdateManyWithoutUserNestedInput as fs, type DoctorApplicationUncheckedUpdateWithoutHospitalInput as ft, type DoctorApplicationUncheckedUpdateWithoutUserInput as fu, type DoctorApplicationUpdateArgs as fv, type DoctorApplicationUpdateInput as fw, type DoctorApplicationUpdateManyAndReturnArgs as fx, type DoctorApplicationUpdateManyArgs as fy, type DoctorApplicationUpdateManyMutationInput as fz, type SearchLogModel as g, type DoctorHospitalProfileCreateWithoutDoctorInput as g$, type DoctorCountOutputTypeCountScheduleArgs as g0, type DoctorCountOutputTypeDefaultArgs as g1, type DoctorCountOutputTypeSelect as g2, type DoctorCreateArgs as g3, type DoctorCreateInput as g4, type DoctorCreateManyAndReturnArgs as g5, type DoctorCreateManyArgs as g6, type DoctorCreateManyInput as g7, type DoctorCreateNestedOneWithoutAppointmentInput as g8, type DoctorCreateNestedOneWithoutDoctorHospitalProfileInput as g9, type DoctorFindManyArgs as gA, type DoctorFindUniqueArgs as gB, type DoctorFindUniqueOrThrowArgs as gC, type DoctorGetPayload as gD, type DoctorGroupByArgs as gE, type DoctorGroupByOutputType as gF, type DoctorHospitalProfileAggregateArgs as gG, type DoctorHospitalProfileAvgAggregateInputType as gH, type DoctorHospitalProfileAvgAggregateOutputType as gI, type DoctorHospitalProfileAvgOrderByAggregateInput as gJ, type DoctorHospitalProfileCountAggregateInputType as gK, type DoctorHospitalProfileCountAggregateOutputType as gL, type DoctorHospitalProfileCountArgs as gM, type DoctorHospitalProfileCountOrderByAggregateInput as gN, type DoctorHospitalProfileCreateArgs as gO, type DoctorHospitalProfileCreateInput as gP, type DoctorHospitalProfileCreateManyAndReturnArgs as gQ, type DoctorHospitalProfileCreateManyArgs as gR, type DoctorHospitalProfileCreateManyDoctorInput as gS, type DoctorHospitalProfileCreateManyDoctorInputEnvelope as gT, type DoctorHospitalProfileCreateManyHospitalInput as gU, type DoctorHospitalProfileCreateManyHospitalInputEnvelope as gV, type DoctorHospitalProfileCreateManyInput as gW, type DoctorHospitalProfileCreateNestedManyWithoutDoctorInput as gX, type DoctorHospitalProfileCreateNestedManyWithoutHospitalInput as gY, type DoctorHospitalProfileCreateOrConnectWithoutDoctorInput as gZ, type DoctorHospitalProfileCreateOrConnectWithoutHospitalInput as g_, type DoctorCreateNestedOneWithoutDoctorSpecializationInput as ga, type DoctorCreateNestedOneWithoutReviewInput as gb, type DoctorCreateNestedOneWithoutSavedDoctorHospitalInput as gc, type DoctorCreateNestedOneWithoutScheduleInput as gd, type DoctorCreateNestedOneWithoutUserInput as ge, type DoctorCreateOrConnectWithoutAppointmentInput as gf, type DoctorCreateOrConnectWithoutDoctorHospitalProfileInput as gg, type DoctorCreateOrConnectWithoutDoctorSpecializationInput as gh, type DoctorCreateOrConnectWithoutReviewInput as gi, type DoctorCreateOrConnectWithoutSavedDoctorHospitalInput as gj, type DoctorCreateOrConnectWithoutScheduleInput as gk, type DoctorCreateOrConnectWithoutUserInput as gl, type DoctorCreateWithoutAppointmentInput as gm, type DoctorCreateWithoutDoctorHospitalProfileInput as gn, type DoctorCreateWithoutDoctorSpecializationInput as go, type DoctorCreateWithoutReviewInput as gp, type DoctorCreateWithoutSavedDoctorHospitalInput as gq, type DoctorCreateWithoutScheduleInput as gr, type DoctorCreateWithoutUserInput as gs, type DoctorDefaultArgs as gt, type DoctorDelegate as gu, type DoctorDeleteArgs as gv, type DoctorDeleteManyArgs as gw, type DoctorFieldRefs as gx, type DoctorFindFirstArgs as gy, type DoctorFindFirstOrThrowArgs as gz, type SlotModel as h, type DoctorHospitalProfileUpdateWithoutHospitalInput as h$, type DoctorHospitalProfileCreateWithoutHospitalInput as h0, type DoctorHospitalProfileDefaultArgs as h1, type DoctorHospitalProfileDelegate as h2, type DoctorHospitalProfileDeleteArgs as h3, type DoctorHospitalProfileDeleteManyArgs as h4, type DoctorHospitalProfileDoctorIdHospitalIdCompoundUniqueInput as h5, type DoctorHospitalProfileFieldRefs as h6, type DoctorHospitalProfileFindFirstArgs as h7, type DoctorHospitalProfileFindFirstOrThrowArgs as h8, type DoctorHospitalProfileFindManyArgs as h9, type DoctorHospitalProfileSumAggregateOutputType as hA, type DoctorHospitalProfileSumOrderByAggregateInput as hB, type DoctorHospitalProfileUncheckedCreateInput as hC, type DoctorHospitalProfileUncheckedCreateNestedManyWithoutDoctorInput as hD, type DoctorHospitalProfileUncheckedCreateNestedManyWithoutHospitalInput as hE, type DoctorHospitalProfileUncheckedCreateWithoutDoctorInput as hF, type DoctorHospitalProfileUncheckedCreateWithoutHospitalInput as hG, type DoctorHospitalProfileUncheckedUpdateInput as hH, type DoctorHospitalProfileUncheckedUpdateManyInput as hI, type DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorInput as hJ, type DoctorHospitalProfileUncheckedUpdateManyWithoutDoctorNestedInput as hK, type DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalInput as hL, type DoctorHospitalProfileUncheckedUpdateManyWithoutHospitalNestedInput as hM, type DoctorHospitalProfileUncheckedUpdateWithoutDoctorInput as hN, type DoctorHospitalProfileUncheckedUpdateWithoutHospitalInput as hO, type DoctorHospitalProfileUpdateArgs as hP, type DoctorHospitalProfileUpdateInput as hQ, type DoctorHospitalProfileUpdateManyAndReturnArgs as hR, type DoctorHospitalProfileUpdateManyArgs as hS, type DoctorHospitalProfileUpdateManyMutationInput as hT, type DoctorHospitalProfileUpdateManyWithWhereWithoutDoctorInput as hU, type DoctorHospitalProfileUpdateManyWithWhereWithoutHospitalInput as hV, type DoctorHospitalProfileUpdateManyWithoutDoctorNestedInput as hW, type DoctorHospitalProfileUpdateManyWithoutHospitalNestedInput as hX, type DoctorHospitalProfileUpdateWithWhereUniqueWithoutDoctorInput as hY, type DoctorHospitalProfileUpdateWithWhereUniqueWithoutHospitalInput as hZ, type DoctorHospitalProfileUpdateWithoutDoctorInput as h_, type DoctorHospitalProfileFindUniqueArgs as ha, type DoctorHospitalProfileFindUniqueOrThrowArgs as hb, type DoctorHospitalProfileGetPayload as hc, type DoctorHospitalProfileGroupByArgs as hd, type DoctorHospitalProfileGroupByOutputType as he, type DoctorHospitalProfileInclude as hf, type DoctorHospitalProfileIncludeCreateManyAndReturn as hg, type DoctorHospitalProfileIncludeUpdateManyAndReturn as hh, type DoctorHospitalProfileListRelationFilter as hi, type DoctorHospitalProfileMaxAggregateInputType as hj, type DoctorHospitalProfileMaxAggregateOutputType as hk, type DoctorHospitalProfileMaxOrderByAggregateInput as hl, type DoctorHospitalProfileMinAggregateInputType as hm, type DoctorHospitalProfileMinAggregateOutputType as hn, type DoctorHospitalProfileMinOrderByAggregateInput as ho, type DoctorHospitalProfileOmit as hp, type DoctorHospitalProfileOrderByRelationAggregateInput as hq, type DoctorHospitalProfileOrderByWithAggregationInput as hr, type DoctorHospitalProfileOrderByWithRelationInput as hs, type DoctorHospitalProfileScalarWhereInput as ht, type DoctorHospitalProfileScalarWhereWithAggregatesInput as hu, type DoctorHospitalProfileSelect as hv, type DoctorHospitalProfileSelectCreateManyAndReturn as hw, type DoctorHospitalProfileSelectScalar as hx, type DoctorHospitalProfileSelectUpdateManyAndReturn as hy, type DoctorHospitalProfileSumAggregateInputType as hz, type SpecializationModel as i, type DoctorSpecializationListRelationFilter as i$, type DoctorHospitalProfileUpsertArgs as i0, type DoctorHospitalProfileUpsertWithWhereUniqueWithoutDoctorInput as i1, type DoctorHospitalProfileUpsertWithWhereUniqueWithoutHospitalInput as i2, type DoctorHospitalProfileWhereInput as i3, type DoctorHospitalProfileWhereUniqueInput as i4, type DoctorInclude as i5, type DoctorIncludeCreateManyAndReturn as i6, type DoctorIncludeUpdateManyAndReturn as i7, type DoctorMaxAggregateInputType as i8, type DoctorMaxAggregateOutputType as i9, type DoctorSpecializationCreateManyDoctorInputEnvelope as iA, type DoctorSpecializationCreateManyInput as iB, type DoctorSpecializationCreateManySpecializationInput as iC, type DoctorSpecializationCreateManySpecializationInputEnvelope as iD, type DoctorSpecializationCreateNestedManyWithoutDoctorInput as iE, type DoctorSpecializationCreateNestedManyWithoutSpecializationInput as iF, type DoctorSpecializationCreateOrConnectWithoutDoctorInput as iG, type DoctorSpecializationCreateOrConnectWithoutSpecializationInput as iH, type DoctorSpecializationCreateWithoutDoctorInput as iI, type DoctorSpecializationCreateWithoutSpecializationInput as iJ, type DoctorSpecializationDefaultArgs as iK, type DoctorSpecializationDelegate as iL, type DoctorSpecializationDeleteArgs as iM, type DoctorSpecializationDeleteManyArgs as iN, type DoctorSpecializationDoctorIdSpecializationIdCompoundUniqueInput as iO, type DoctorSpecializationFieldRefs as iP, type DoctorSpecializationFindFirstArgs as iQ, type DoctorSpecializationFindFirstOrThrowArgs as iR, type DoctorSpecializationFindManyArgs as iS, type DoctorSpecializationFindUniqueArgs as iT, type DoctorSpecializationFindUniqueOrThrowArgs as iU, type DoctorSpecializationGetPayload as iV, type DoctorSpecializationGroupByArgs as iW, type DoctorSpecializationGroupByOutputType as iX, type DoctorSpecializationInclude as iY, type DoctorSpecializationIncludeCreateManyAndReturn as iZ, type DoctorSpecializationIncludeUpdateManyAndReturn as i_, type DoctorMaxOrderByAggregateInput as ia, type DoctorMinAggregateInputType as ib, type DoctorMinAggregateOutputType as ic, type DoctorMinOrderByAggregateInput as id, type DoctorNullableScalarRelationFilter as ie, type DoctorOmit as ig, type DoctorOrderByWithAggregationInput as ih, type DoctorOrderByWithRelationInput as ii, type DoctorScalarRelationFilter as ij, type DoctorScalarWhereWithAggregatesInput as ik, type DoctorSelect as il, type DoctorSelectCreateManyAndReturn as im, type DoctorSelectScalar as io, type DoctorSelectUpdateManyAndReturn as ip, type DoctorSpecializationAggregateArgs as iq, type DoctorSpecializationCountAggregateInputType as ir, type DoctorSpecializationCountAggregateOutputType as is, type DoctorSpecializationCountArgs as it, type DoctorSpecializationCountOrderByAggregateInput as iu, type DoctorSpecializationCreateArgs as iv, type DoctorSpecializationCreateInput as iw, type DoctorSpecializationCreateManyAndReturnArgs as ix, type DoctorSpecializationCreateManyArgs as iy, type DoctorSpecializationCreateManyDoctorInput as iz, type accountModel as j, type DoctorUncheckedUpdateWithoutDoctorHospitalProfileInput as j$, type DoctorSpecializationMaxAggregateInputType as j0, type DoctorSpecializationMaxAggregateOutputType as j1, type DoctorSpecializationMaxOrderByAggregateInput as j2, type DoctorSpecializationMinAggregateInputType as j3, type DoctorSpecializationMinAggregateOutputType as j4, type DoctorSpecializationMinOrderByAggregateInput as j5, type DoctorSpecializationOmit as j6, type DoctorSpecializationOrderByRelationAggregateInput as j7, type DoctorSpecializationOrderByWithAggregationInput as j8, type DoctorSpecializationOrderByWithRelationInput as j9, type DoctorSpecializationUpdateManyWithoutDoctorNestedInput as jA, type DoctorSpecializationUpdateManyWithoutSpecializationNestedInput as jB, type DoctorSpecializationUpdateWithWhereUniqueWithoutDoctorInput as jC, type DoctorSpecializationUpdateWithWhereUniqueWithoutSpecializationInput as jD, type DoctorSpecializationUpdateWithoutDoctorInput as jE, type DoctorSpecializationUpdateWithoutSpecializationInput as jF, type DoctorSpecializationUpsertArgs as jG, type DoctorSpecializationUpsertWithWhereUniqueWithoutDoctorInput as jH, type DoctorSpecializationUpsertWithWhereUniqueWithoutSpecializationInput as jI, type DoctorSpecializationWhereInput as jJ, type DoctorSpecializationWhereUniqueInput as jK, type DoctorSumAggregateInputType as jL, type DoctorSumAggregateOutputType as jM, type DoctorSumOrderByAggregateInput as jN, type DoctorUncheckedCreateInput as jO, type DoctorUncheckedCreateNestedOneWithoutUserInput as jP, type DoctorUncheckedCreateWithoutAppointmentInput as jQ, type DoctorUncheckedCreateWithoutDoctorHospitalProfileInput as jR, type DoctorUncheckedCreateWithoutDoctorSpecializationInput as jS, type DoctorUncheckedCreateWithoutReviewInput as jT, type DoctorUncheckedCreateWithoutSavedDoctorHospitalInput as jU, type DoctorUncheckedCreateWithoutScheduleInput as jV, type DoctorUncheckedCreateWithoutUserInput as jW, type DoctorUncheckedUpdateInput as jX, type DoctorUncheckedUpdateManyInput as jY, type DoctorUncheckedUpdateOneWithoutUserNestedInput as jZ, type DoctorUncheckedUpdateWithoutAppointmentInput as j_, type DoctorSpecializationScalarWhereInput as ja, type DoctorSpecializationScalarWhereWithAggregatesInput as jb, type DoctorSpecializationSelect as jc, type DoctorSpecializationSelectCreateManyAndReturn as jd, type DoctorSpecializationSelectScalar as je, type DoctorSpecializationSelectUpdateManyAndReturn as jf, type DoctorSpecializationUncheckedCreateInput as jg, type DoctorSpecializationUncheckedCreateNestedManyWithoutDoctorInput as jh, type DoctorSpecializationUncheckedCreateNestedManyWithoutSpecializationInput as ji, type DoctorSpecializationUncheckedCreateWithoutDoctorInput as jj, type DoctorSpecializationUncheckedCreateWithoutSpecializationInput as jk, type DoctorSpecializationUncheckedUpdateInput as jl, type DoctorSpecializationUncheckedUpdateManyInput as jm, type DoctorSpecializationUncheckedUpdateManyWithoutDoctorInput as jn, type DoctorSpecializationUncheckedUpdateManyWithoutDoctorNestedInput as jo, type DoctorSpecializationUncheckedUpdateManyWithoutSpecializationInput as jp, type DoctorSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput as jq, type DoctorSpecializationUncheckedUpdateWithoutDoctorInput as jr, type DoctorSpecializationUncheckedUpdateWithoutSpecializationInput as js, type DoctorSpecializationUpdateArgs as jt, type DoctorSpecializationUpdateInput as ju, type DoctorSpecializationUpdateManyAndReturnArgs as jv, type DoctorSpecializationUpdateManyArgs as jw, type DoctorSpecializationUpdateManyMutationInput as jx, type DoctorSpecializationUpdateManyWithWhereWithoutDoctorInput as jy, type DoctorSpecializationUpdateManyWithWhereWithoutSpecializationInput as jz, type PrismaClientConstructor as k, type EnumSchedulePeriodFieldUpdateOperationsInput as k$, type DoctorUncheckedUpdateWithoutDoctorSpecializationInput as k0, type DoctorUncheckedUpdateWithoutReviewInput as k1, type DoctorUncheckedUpdateWithoutSavedDoctorHospitalInput as k2, type DoctorUncheckedUpdateWithoutScheduleInput as k3, type DoctorUncheckedUpdateWithoutUserInput as k4, type DoctorUpdateArgs as k5, type DoctorUpdateInput as k6, type DoctorUpdateManyAndReturnArgs as k7, type DoctorUpdateManyArgs as k8, type DoctorUpdateManyMutationInput as k9, type DoctorUpsertWithoutSavedDoctorHospitalInput as kA, type DoctorUpsertWithoutScheduleInput as kB, type DoctorUpsertWithoutUserInput as kC, type DoctorWhereInput as kD, type DoctorWhereUniqueInput as kE, type Either as kF, type EnumAppointmentStatusFieldRefInput as kG, type EnumAppointmentStatusFieldUpdateOperationsInput as kH, type EnumAppointmentStatusFilter as kI, type EnumAppointmentStatusWithAggregatesFilter as kJ, type EnumDoctorApplicationStatusFieldRefInput as kK, type EnumDoctorApplicationStatusFieldUpdateOperationsInput as kL, type EnumDoctorApplicationStatusFilter as kM, type EnumDoctorApplicationStatusWithAggregatesFilter as kN, type EnumDoctorTypeFieldRefInput as kO, type EnumDoctorTypeFieldUpdateOperationsInput as kP, type EnumDoctorTypeFilter as kQ, type EnumDoctorTypeWithAggregatesFilter as kR, type EnumHospitalTypeFieldRefInput as kS, type EnumHospitalTypeFieldUpdateOperationsInput as kT, type EnumHospitalTypeFilter as kU, type EnumHospitalTypeWithAggregatesFilter as kV, type EnumQueryModeFieldRefInput as kW, type EnumRoleFieldRefInput as kX, type EnumRoleNullableFilter as kY, type EnumRoleNullableWithAggregatesFilter as kZ, type EnumSchedulePeriodFieldRefInput as k_, type DoctorUpdateOneRequiredWithoutAppointmentNestedInput as ka, type DoctorUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput as kb, type DoctorUpdateOneRequiredWithoutDoctorSpecializationNestedInput as kc, type DoctorUpdateOneRequiredWithoutScheduleNestedInput as kd, type DoctorUpdateOneWithoutReviewNestedInput as ke, type DoctorUpdateOneWithoutSavedDoctorHospitalNestedInput as kf, type DoctorUpdateOneWithoutUserNestedInput as kg, type DoctorUpdateToOneWithWhereWithoutAppointmentInput as kh, type DoctorUpdateToOneWithWhereWithoutDoctorHospitalProfileInput as ki, type DoctorUpdateToOneWithWhereWithoutDoctorSpecializationInput as kj, type DoctorUpdateToOneWithWhereWithoutReviewInput as kk, type DoctorUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as kl, type DoctorUpdateToOneWithWhereWithoutScheduleInput as km, type DoctorUpdateToOneWithWhereWithoutUserInput as kn, type DoctorUpdateWithoutAppointmentInput as ko, type DoctorUpdateWithoutDoctorHospitalProfileInput as kp, type DoctorUpdateWithoutDoctorSpecializationInput as kq, type DoctorUpdateWithoutReviewInput as kr, type DoctorUpdateWithoutSavedDoctorHospitalInput as ks, type DoctorUpdateWithoutScheduleInput as kt, type DoctorUpdateWithoutUserInput as ku, type DoctorUpsertArgs as kv, type DoctorUpsertWithoutAppointmentInput as kw, type DoctorUpsertWithoutDoctorHospitalProfileInput as kx, type DoctorUpsertWithoutDoctorSpecializationInput as ky, type DoctorUpsertWithoutReviewInput as kz, type PrismaClientOptions as l, type HospitalCountOrderByAggregateInput as l$, type EnumSchedulePeriodFilter as l0, type EnumSchedulePeriodWithAggregatesFilter as l1, type EnumScheduleStatusFieldRefInput as l2, type EnumScheduleStatusFieldUpdateOperationsInput as l3, type EnumScheduleStatusFilter as l4, type EnumScheduleStatusWithAggregatesFilter as l5, type EnumScheduleTypeFieldRefInput as l6, type EnumScheduleTypeFieldUpdateOperationsInput as l7, type EnumScheduleTypeFilter as l8, type EnumScheduleTypeWithAggregatesFilter as l9, type GetPaymentAggregateType as lA, type GetReviewAggregateType as lB, type GetSavedDoctorHospitalAggregateType as lC, type GetScalarType as lD, type GetScheduleAggregateType as lE, type GetSearchLogAggregateType as lF, type GetSessionAggregateType as lG, type GetSlotAggregateType as lH, type GetSpecializationAggregateType as lI, type GetUserAggregateType as lJ, type GetVerificationAggregateType as lK, type GlobalOmitConfig as lL, type Has as lM, type Hospital$AppointmentArgs as lN, type Hospital$DoctorApplicationArgs as lO, type Hospital$DoctorHospitalProfileArgs as lP, type Hospital$HospitalSpecializationArgs as lQ, type Hospital$ReviewArgs as lR, type Hospital$SavedDoctorHospitalArgs as lS, type Hospital$ScheduleArgs as lT, type HospitalAggregateArgs as lU, type HospitalAvgAggregateInputType as lV, type HospitalAvgAggregateOutputType as lW, type HospitalAvgOrderByAggregateInput as lX, type HospitalCountAggregateInputType as lY, type HospitalCountAggregateOutputType as lZ, type HospitalCountArgs as l_, type EnumSlotStatusFieldRefInput as la, type EnumSlotStatusFieldUpdateOperationsInput as lb, type EnumSlotStatusFilter as lc, type EnumSlotStatusWithAggregatesFilter as ld, type Enumerable as le, type ErrorFormat as lf, type Exact as lg, type ExcludeUnderscoreKeys as lh, type Extends as li, type Extension as lj, type False as lk, type FieldRef as ll, type FloatFieldRefInput as lm, type GetAccountAggregateType as ln, type GetAppointmentAggregateType as lo, type GetAuditLogAggregateType as lp, type GetDoctorAggregateType as lq, type GetDoctorApplicationAggregateType as lr, type GetDoctorHospitalProfileAggregateType as ls, type GetDoctorSpecializationAggregateType as lt, type GetEvents as lu, type GetHavingFields as lv, type GetHospitalAggregateType as lw, type GetHospitalSpecializationAggregateType as lx, type GetLogType as ly, type GetNotificationAggregateType as lz, type PrismaClient as m, type HospitalOrderByWithAggregationInput as m$, type HospitalCountOutputType as m0, type HospitalCountOutputTypeCountAppointmentArgs as m1, type HospitalCountOutputTypeCountDoctorApplicationArgs as m2, type HospitalCountOutputTypeCountDoctorHospitalProfileArgs as m3, type HospitalCountOutputTypeCountHospitalSpecializationArgs as m4, type HospitalCountOutputTypeCountReviewArgs as m5, type HospitalCountOutputTypeCountSavedDoctorHospitalArgs as m6, type HospitalCountOutputTypeCountScheduleArgs as m7, type HospitalCountOutputTypeDefaultArgs as m8, type HospitalCountOutputTypeSelect as m9, type HospitalCreateWithoutSavedDoctorHospitalInput as mA, type HospitalCreateWithoutScheduleInput as mB, type HospitalCreateWithoutUserInput as mC, type HospitalDefaultArgs as mD, type HospitalDelegate as mE, type HospitalDeleteArgs as mF, type HospitalDeleteManyArgs as mG, type HospitalFieldRefs as mH, type HospitalFindFirstArgs as mI, type HospitalFindFirstOrThrowArgs as mJ, type HospitalFindManyArgs as mK, type HospitalFindUniqueArgs as mL, type HospitalFindUniqueOrThrowArgs as mM, type HospitalGetPayload as mN, type HospitalGroupByArgs as mO, type HospitalGroupByOutputType as mP, type HospitalInclude as mQ, type HospitalIncludeCreateManyAndReturn as mR, type HospitalIncludeUpdateManyAndReturn as mS, type HospitalMaxAggregateInputType as mT, type HospitalMaxAggregateOutputType as mU, type HospitalMaxOrderByAggregateInput as mV, type HospitalMinAggregateInputType as mW, type HospitalMinAggregateOutputType as mX, type HospitalMinOrderByAggregateInput as mY, type HospitalNullableScalarRelationFilter as mZ, type HospitalOmit as m_, type HospitalCreateArgs as ma, type HospitalCreateInput as mb, type HospitalCreateManyAndReturnArgs as mc, type HospitalCreateManyArgs as md, type HospitalCreateManyInput as me, type HospitalCreateNestedOneWithoutAppointmentInput as mf, type HospitalCreateNestedOneWithoutDoctorApplicationInput as mg, type HospitalCreateNestedOneWithoutDoctorHospitalProfileInput as mh, type HospitalCreateNestedOneWithoutHospitalSpecializationInput as mi, type HospitalCreateNestedOneWithoutReviewInput as mj, type HospitalCreateNestedOneWithoutSavedDoctorHospitalInput as mk, type HospitalCreateNestedOneWithoutScheduleInput as ml, type HospitalCreateNestedOneWithoutUserInput as mm, type HospitalCreateOrConnectWithoutAppointmentInput as mn, type HospitalCreateOrConnectWithoutDoctorApplicationInput as mo, type HospitalCreateOrConnectWithoutDoctorHospitalProfileInput as mp, type HospitalCreateOrConnectWithoutHospitalSpecializationInput as mq, type HospitalCreateOrConnectWithoutReviewInput as mr, type HospitalCreateOrConnectWithoutSavedDoctorHospitalInput as ms, type HospitalCreateOrConnectWithoutScheduleInput as mt, type HospitalCreateOrConnectWithoutUserInput as mu, type HospitalCreateWithoutAppointmentInput as mv, type HospitalCreateWithoutDoctorApplicationInput as mw, type HospitalCreateWithoutDoctorHospitalProfileInput as mx, type HospitalCreateWithoutHospitalSpecializationInput as my, type HospitalCreateWithoutReviewInput as mz, type $AuditLogPayload as n, type HospitalSpecializationUncheckedCreateNestedManyWithoutSpecializationInput as n$, type HospitalOrderByWithRelationInput as n0, type HospitalScalarRelationFilter as n1, type HospitalScalarWhereWithAggregatesInput as n2, type HospitalSelect as n3, type HospitalSelectCreateManyAndReturn as n4, type HospitalSelectScalar as n5, type HospitalSelectUpdateManyAndReturn as n6, type HospitalSpecializationAggregateArgs as n7, type HospitalSpecializationCountAggregateInputType as n8, type HospitalSpecializationCountAggregateOutputType as n9, type HospitalSpecializationFindUniqueOrThrowArgs as nA, type HospitalSpecializationGetPayload as nB, type HospitalSpecializationGroupByArgs as nC, type HospitalSpecializationGroupByOutputType as nD, type HospitalSpecializationHospitalIdSpecializationIdCompoundUniqueInput as nE, type HospitalSpecializationInclude as nF, type HospitalSpecializationIncludeCreateManyAndReturn as nG, type HospitalSpecializationIncludeUpdateManyAndReturn as nH, type HospitalSpecializationListRelationFilter as nI, type HospitalSpecializationMaxAggregateInputType as nJ, type HospitalSpecializationMaxAggregateOutputType as nK, type HospitalSpecializationMaxOrderByAggregateInput as nL, type HospitalSpecializationMinAggregateInputType as nM, type HospitalSpecializationMinAggregateOutputType as nN, type HospitalSpecializationMinOrderByAggregateInput as nO, type HospitalSpecializationOmit as nP, type HospitalSpecializationOrderByRelationAggregateInput as nQ, type HospitalSpecializationOrderByWithAggregationInput as nR, type HospitalSpecializationOrderByWithRelationInput as nS, type HospitalSpecializationScalarWhereInput as nT, type HospitalSpecializationScalarWhereWithAggregatesInput as nU, type HospitalSpecializationSelect as nV, type HospitalSpecializationSelectCreateManyAndReturn as nW, type HospitalSpecializationSelectScalar as nX, type HospitalSpecializationSelectUpdateManyAndReturn as nY, type HospitalSpecializationUncheckedCreateInput as nZ, type HospitalSpecializationUncheckedCreateNestedManyWithoutHospitalInput as n_, type HospitalSpecializationCountArgs as na, type HospitalSpecializationCountOrderByAggregateInput as nb, type HospitalSpecializationCreateArgs as nc, type HospitalSpecializationCreateInput as nd, type HospitalSpecializationCreateManyAndReturnArgs as ne, type HospitalSpecializationCreateManyArgs as nf, type HospitalSpecializationCreateManyHospitalInput as ng, type HospitalSpecializationCreateManyHospitalInputEnvelope as nh, type HospitalSpecializationCreateManyInput as ni, type HospitalSpecializationCreateManySpecializationInput as nj, type HospitalSpecializationCreateManySpecializationInputEnvelope as nk, type HospitalSpecializationCreateNestedManyWithoutHospitalInput as nl, type HospitalSpecializationCreateNestedManyWithoutSpecializationInput as nm, type HospitalSpecializationCreateOrConnectWithoutHospitalInput as nn, type HospitalSpecializationCreateOrConnectWithoutSpecializationInput as no, type HospitalSpecializationCreateWithoutHospitalInput as np, type HospitalSpecializationCreateWithoutSpecializationInput as nq, type HospitalSpecializationDefaultArgs as nr, type HospitalSpecializationDelegate as ns, type HospitalSpecializationDeleteArgs as nt, type HospitalSpecializationDeleteManyArgs as nu, type HospitalSpecializationFieldRefs as nv, type HospitalSpecializationFindFirstArgs as nw, type HospitalSpecializationFindFirstOrThrowArgs as nx, type HospitalSpecializationFindManyArgs as ny, type HospitalSpecializationFindUniqueArgs as nz, type $DoctorApplicationPayload as o, type HospitalUpdateOneWithoutSavedDoctorHospitalNestedInput as o$, type HospitalSpecializationUncheckedCreateWithoutHospitalInput as o0, type HospitalSpecializationUncheckedCreateWithoutSpecializationInput as o1, type HospitalSpecializationUncheckedUpdateInput as o2, type HospitalSpecializationUncheckedUpdateManyInput as o3, type HospitalSpecializationUncheckedUpdateManyWithoutHospitalInput as o4, type HospitalSpecializationUncheckedUpdateManyWithoutHospitalNestedInput as o5, type HospitalSpecializationUncheckedUpdateManyWithoutSpecializationInput as o6, type HospitalSpecializationUncheckedUpdateManyWithoutSpecializationNestedInput as o7, type HospitalSpecializationUncheckedUpdateWithoutHospitalInput as o8, type HospitalSpecializationUncheckedUpdateWithoutSpecializationInput as o9, type HospitalUncheckedCreateWithoutHospitalSpecializationInput as oA, type HospitalUncheckedCreateWithoutReviewInput as oB, type HospitalUncheckedCreateWithoutSavedDoctorHospitalInput as oC, type HospitalUncheckedCreateWithoutScheduleInput as oD, type HospitalUncheckedCreateWithoutUserInput as oE, type HospitalUncheckedUpdateInput as oF, type HospitalUncheckedUpdateManyInput as oG, type HospitalUncheckedUpdateOneWithoutUserNestedInput as oH, type HospitalUncheckedUpdateWithoutAppointmentInput as oI, type HospitalUncheckedUpdateWithoutDoctorApplicationInput as oJ, type HospitalUncheckedUpdateWithoutDoctorHospitalProfileInput as oK, type HospitalUncheckedUpdateWithoutHospitalSpecializationInput as oL, type HospitalUncheckedUpdateWithoutReviewInput as oM, type HospitalUncheckedUpdateWithoutSavedDoctorHospitalInput as oN, type HospitalUncheckedUpdateWithoutScheduleInput as oO, type HospitalUncheckedUpdateWithoutUserInput as oP, type HospitalUpdateArgs as oQ, type HospitalUpdateInput as oR, type HospitalUpdateManyAndReturnArgs as oS, type HospitalUpdateManyArgs as oT, type HospitalUpdateManyMutationInput as oU, type HospitalUpdateOneRequiredWithoutAppointmentNestedInput as oV, type HospitalUpdateOneRequiredWithoutDoctorApplicationNestedInput as oW, type HospitalUpdateOneRequiredWithoutDoctorHospitalProfileNestedInput as oX, type HospitalUpdateOneRequiredWithoutHospitalSpecializationNestedInput as oY, type HospitalUpdateOneRequiredWithoutScheduleNestedInput as oZ, type HospitalUpdateOneWithoutReviewNestedInput as o_, type HospitalSpecializationUpdateArgs as oa, type HospitalSpecializationUpdateInput as ob, type HospitalSpecializationUpdateManyAndReturnArgs as oc, type HospitalSpecializationUpdateManyArgs as od, type HospitalSpecializationUpdateManyMutationInput as oe, type HospitalSpecializationUpdateManyWithWhereWithoutHospitalInput as of, type HospitalSpecializationUpdateManyWithWhereWithoutSpecializationInput as og, type HospitalSpecializationUpdateManyWithoutHospitalNestedInput as oh, type HospitalSpecializationUpdateManyWithoutSpecializationNestedInput as oi, type HospitalSpecializationUpdateWithWhereUniqueWithoutHospitalInput as oj, type HospitalSpecializationUpdateWithWhereUniqueWithoutSpecializationInput as ok, type HospitalSpecializationUpdateWithoutHospitalInput as ol, type HospitalSpecializationUpdateWithoutSpecializationInput as om, type HospitalSpecializationUpsertArgs as on, type HospitalSpecializationUpsertWithWhereUniqueWithoutHospitalInput as oo, type HospitalSpecializationUpsertWithWhereUniqueWithoutSpecializationInput as op, type HospitalSpecializationWhereInput as oq, type HospitalSpecializationWhereUniqueInput as or, type HospitalSumAggregateInputType as os, type HospitalSumAggregateOutputType as ot, type HospitalSumOrderByAggregateInput as ou, type HospitalUncheckedCreateInput as ov, type HospitalUncheckedCreateNestedOneWithoutUserInput as ow, type HospitalUncheckedCreateWithoutAppointmentInput as ox, type HospitalUncheckedCreateWithoutDoctorApplicationInput as oy, type HospitalUncheckedCreateWithoutDoctorHospitalProfileInput as oz, prismaNamespace as p, type LogEvent as p$, type HospitalUpdateOneWithoutUserNestedInput as p0, type HospitalUpdateToOneWithWhereWithoutAppointmentInput as p1, type HospitalUpdateToOneWithWhereWithoutDoctorApplicationInput as p2, type HospitalUpdateToOneWithWhereWithoutDoctorHospitalProfileInput as p3, type HospitalUpdateToOneWithWhereWithoutHospitalSpecializationInput as p4, type HospitalUpdateToOneWithWhereWithoutReviewInput as p5, type HospitalUpdateToOneWithWhereWithoutSavedDoctorHospitalInput as p6, type HospitalUpdateToOneWithWhereWithoutScheduleInput as p7, type HospitalUpdateToOneWithWhereWithoutUserInput as p8, type HospitalUpdateWithoutAppointmentInput as p9, type IntNullableWithAggregatesFilter as pA, type IntWithAggregatesFilter as pB, type IntersectOf as pC, type JsonArray as pD, type JsonFieldRefInput as pE, type JsonNullableFilter as pF, type JsonNullableFilterBase as pG, type JsonNullableWithAggregatesFilter as pH, type JsonNullableWithAggregatesFilterBase as pI, type JsonObject as pJ, type JsonValue as pK, type Keys as pL, type ListDateTimeFieldRefInput as pM, type ListDecimalFieldRefInput as pN, type ListEnumAppointmentStatusFieldRefInput as pO, type ListEnumDoctorApplicationStatusFieldRefInput as pP, type ListEnumDoctorTypeFieldRefInput as pQ, type ListEnumHospitalTypeFieldRefInput as pR, type ListEnumRoleFieldRefInput as pS, type ListEnumSchedulePeriodFieldRefInput as pT, type ListEnumScheduleStatusFieldRefInput as pU, type ListEnumScheduleTypeFieldRefInput as pV, type ListEnumSlotStatusFieldRefInput as pW, type ListFloatFieldRefInput as pX, type ListIntFieldRefInput as pY, type ListStringFieldRefInput as pZ, type LogDefinition as p_, type HospitalUpdateWithoutDoctorApplicationInput as pa, type HospitalUpdateWithoutDoctorHospitalProfileInput as pb, type HospitalUpdateWithoutHospitalSpecializationInput as pc, type HospitalUpdateWithoutReviewInput as pd, type HospitalUpdateWithoutSavedDoctorHospitalInput as pe, type HospitalUpdateWithoutScheduleInput as pf, type HospitalUpdateWithoutUserInput as pg, type HospitalUpsertArgs as ph, type HospitalUpsertWithoutAppointmentInput as pi, type HospitalUpsertWithoutDoctorApplicationInput as pj, type HospitalUpsertWithoutDoctorHospitalProfileInput as pk, type HospitalUpsertWithoutHospitalSpecializationInput as pl, type HospitalUpsertWithoutReviewInput as pm, type HospitalUpsertWithoutSavedDoctorHospitalInput as pn, type HospitalUpsertWithoutScheduleInput as po, type HospitalUpsertWithoutUserInput as pp, type HospitalWhereInput as pq, type HospitalWhereUniqueInput as pr, type InputJsonArray as ps, type InputJsonObject as pt, type InputJsonValue as pu, type IntFieldRefInput as pv, type IntFieldUpdateOperationsInput as pw, type IntFilter as px, type IntNullableFilter as py, type IntNullableListFilter as pz, type $DoctorHospitalProfilePayload as q, type NotificationDeleteManyArgs as q$, type MaybeTupleToUnion as q0, type Merge as q1, type NestedBoolFilter as q2, type NestedBoolNullableFilter as q3, type NestedBoolNullableWithAggregatesFilter as q4, type NestedBoolWithAggregatesFilter as q5, type NestedDateTimeFilter as q6, type NestedDateTimeNullableFilter as q7, type NestedDateTimeNullableWithAggregatesFilter as q8, type NestedDateTimeWithAggregatesFilter as q9, type NestedIntNullableWithAggregatesFilter as qA, type NestedIntWithAggregatesFilter as qB, type NestedJsonNullableFilter as qC, type NestedJsonNullableFilterBase as qD, type NestedStringFilter as qE, type NestedStringNullableFilter as qF, type NestedStringNullableWithAggregatesFilter as qG, type NestedStringWithAggregatesFilter as qH, type Not as qI, type NotificationAggregateArgs as qJ, type NotificationCountAggregateInputType as qK, type NotificationCountAggregateOutputType as qL, type NotificationCountArgs as qM, type NotificationCountOrderByAggregateInput as qN, type NotificationCreateArgs as qO, type NotificationCreateInput as qP, type NotificationCreateManyAndReturnArgs as qQ, type NotificationCreateManyArgs as qR, type NotificationCreateManyInput as qS, type NotificationCreateManyUserInput as qT, type NotificationCreateManyUserInputEnvelope as qU, type NotificationCreateNestedManyWithoutUserInput as qV, type NotificationCreateOrConnectWithoutUserInput as qW, type NotificationCreateWithoutUserInput as qX, type NotificationDefaultArgs as qY, type NotificationDelegate as qZ, type NotificationDeleteArgs as q_, type NestedDecimalFilter as qa, type NestedDecimalNullableFilter as qb, type NestedDecimalNullableWithAggregatesFilter as qc, type NestedDecimalWithAggregatesFilter as qd, type NestedEnumAppointmentStatusFilter as qe, type NestedEnumAppointmentStatusWithAggregatesFilter as qf, type NestedEnumDoctorApplicationStatusFilter as qg, type NestedEnumDoctorApplicationStatusWithAggregatesFilter as qh, type NestedEnumDoctorTypeFilter as qi, type NestedEnumDoctorTypeWithAggregatesFilter as qj, type NestedEnumHospitalTypeFilter as qk, type NestedEnumHospitalTypeWithAggregatesFilter as ql, type NestedEnumRoleNullableFilter as qm, type NestedEnumRoleNullableWithAggregatesFilter as qn, type NestedEnumSchedulePeriodFilter as qo, type NestedEnumSchedulePeriodWithAggregatesFilter as qp, type NestedEnumScheduleStatusFilter as qq, type NestedEnumScheduleStatusWithAggregatesFilter as qr, type NestedEnumScheduleTypeFilter as qs, type NestedEnumScheduleTypeWithAggregatesFilter as qt, type NestedEnumSlotStatusFilter as qu, type NestedEnumSlotStatusWithAggregatesFilter as qv, type NestedFloatFilter as qw, type NestedFloatNullableFilter as qx, type NestedIntFilter as qy, type NestedIntNullableFilter as qz, type $DoctorPayload as r, type PaymentAvgAggregateOutputType as r$, type NotificationFieldRefs as r0, type NotificationFindFirstArgs as r1, type NotificationFindFirstOrThrowArgs as r2, type NotificationFindManyArgs as r3, type NotificationFindUniqueArgs as r4, type NotificationFindUniqueOrThrowArgs as r5, type NotificationGetPayload as r6, type NotificationGroupByArgs as r7, type NotificationGroupByOutputType as r8, type NotificationInclude as r9, type NotificationUncheckedUpdateWithoutUserInput as rA, type NotificationUpdateArgs as rB, type NotificationUpdateInput as rC, type NotificationUpdateManyAndReturnArgs as rD, type NotificationUpdateManyArgs as rE, type NotificationUpdateManyMutationInput as rF, type NotificationUpdateManyWithWhereWithoutUserInput as rG, type NotificationUpdateManyWithoutUserNestedInput as rH, type NotificationUpdateWithWhereUniqueWithoutUserInput as rI, type NotificationUpdateWithoutUserInput as rJ, type NotificationUpsertArgs as rK, type NotificationUpsertWithWhereUniqueWithoutUserInput as rL, type NotificationWhereInput as rM, type NotificationWhereUniqueInput as rN, type NullableBoolFieldUpdateOperationsInput as rO, type NullableDateTimeFieldUpdateOperationsInput as rP, type NullableDecimalFieldUpdateOperationsInput as rQ, type NullableEnumRoleFieldUpdateOperationsInput as rR, type NullableIntFieldUpdateOperationsInput as rS, type NullableStringFieldUpdateOperationsInput as rT, type OptionalFlat as rU, type Or as rV, type Overwrite as rW, type PatchUndefined as rX, type Payload as rY, type PaymentAggregateArgs as rZ, type PaymentAvgAggregateInputType as r_, type NotificationIncludeCreateManyAndReturn as ra, type NotificationIncludeUpdateManyAndReturn as rb, type NotificationListRelationFilter as rc, type NotificationMaxAggregateInputType as rd, type NotificationMaxAggregateOutputType as re, type NotificationMaxOrderByAggregateInput as rf, type NotificationMinAggregateInputType as rg, type NotificationMinAggregateOutputType as rh, type NotificationMinOrderByAggregateInput as ri, type NotificationOmit as rj, type NotificationOrderByRelationAggregateInput as rk, type NotificationOrderByWithAggregationInput as rl, type NotificationOrderByWithRelationInput as rm, type NotificationScalarWhereInput as rn, type NotificationScalarWhereWithAggregatesInput as ro, type NotificationSelect as rp, type NotificationSelectCreateManyAndReturn as rq, type NotificationSelectScalar as rr, type NotificationSelectUpdateManyAndReturn as rs, type NotificationUncheckedCreateInput as rt, type NotificationUncheckedCreateNestedManyWithoutUserInput as ru, type NotificationUncheckedCreateWithoutUserInput as rv, type NotificationUncheckedUpdateInput as rw, type NotificationUncheckedUpdateManyInput as rx, type NotificationUncheckedUpdateManyWithoutUserInput as ry, type NotificationUncheckedUpdateManyWithoutUserNestedInput as rz, type sessionModel as s, type PaymentUncheckedUpdateManyWithoutUserNestedInput as s$, type PaymentAvgOrderByAggregateInput as s0, type PaymentCountAggregateInputType as s1, type PaymentCountAggregateOutputType as s2, type PaymentCountArgs as s3, type PaymentCountOrderByAggregateInput as s4, type PaymentCreateArgs as s5, type PaymentCreateInput as s6, type PaymentCreateManyAndReturnArgs as s7, type PaymentCreateManyArgs as s8, type PaymentCreateManyInput as s9, type PaymentMaxAggregateOutputType as sA, type PaymentMaxOrderByAggregateInput as sB, type PaymentMinAggregateInputType as sC, type PaymentMinAggregateOutputType as sD, type PaymentMinOrderByAggregateInput as sE, type PaymentNullableScalarRelationFilter as sF, type PaymentOmit as sG, type PaymentOrderByRelationAggregateInput as sH, type PaymentOrderByWithAggregationInput as sI, type PaymentOrderByWithRelationInput as sJ, type PaymentScalarWhereInput as sK, type PaymentScalarWhereWithAggregatesInput as sL, type PaymentSelect as sM, type PaymentSelectCreateManyAndReturn as sN, type PaymentSelectScalar as sO, type PaymentSelectUpdateManyAndReturn as sP, type PaymentSumAggregateInputType as sQ, type PaymentSumAggregateOutputType as sR, type PaymentSumOrderByAggregateInput as sS, type PaymentUncheckedCreateInput as sT, type PaymentUncheckedCreateNestedManyWithoutUserInput as sU, type PaymentUncheckedCreateNestedOneWithoutAppointmentInput as sV, type PaymentUncheckedCreateWithoutAppointmentInput as sW, type PaymentUncheckedCreateWithoutUserInput as sX, type PaymentUncheckedUpdateInput as sY, type PaymentUncheckedUpdateManyInput as sZ, type PaymentUncheckedUpdateManyWithoutUserInput as s_, type PaymentCreateManyUserInput as sa, type PaymentCreateManyUserInputEnvelope as sb, type PaymentCreateNestedManyWithoutUserInput as sc, type PaymentCreateNestedOneWithoutAppointmentInput as sd, type PaymentCreateOrConnectWithoutAppointmentInput as se, type PaymentCreateOrConnectWithoutUserInput as sf, type PaymentCreateWithoutAppointmentInput as sg, type PaymentCreateWithoutUserInput as sh, type PaymentDefaultArgs as si, type PaymentDelegate as sj, type PaymentDeleteArgs as sk, type PaymentDeleteManyArgs as sl, type PaymentFieldRefs as sm, type PaymentFindFirstArgs as sn, type PaymentFindFirstOrThrowArgs as so, type PaymentFindManyArgs as sp, type PaymentFindUniqueArgs as sq, type PaymentFindUniqueOrThrowArgs as sr, type PaymentGetPayload as ss, type PaymentGroupByArgs as st, type PaymentGroupByOutputType as su, type PaymentInclude as sv, type PaymentIncludeCreateManyAndReturn as sw, type PaymentIncludeUpdateManyAndReturn as sx, type PaymentListRelationFilter as sy, type PaymentMaxAggregateInputType as sz, type $DoctorSpecializationPayload as t, type ReviewCreateManyAndReturnArgs as t$, type PaymentUncheckedUpdateOneWithoutAppointmentNestedInput as t0, type PaymentUncheckedUpdateWithoutAppointmentInput as t1, type PaymentUncheckedUpdateWithoutUserInput as t2, type PaymentUpdateArgs as t3, type PaymentUpdateInput as t4, type PaymentUpdateManyAndReturnArgs as t5, type PaymentUpdateManyArgs as t6, type PaymentUpdateManyMutationInput as t7, type PaymentUpdateManyWithWhereWithoutUserInput as t8, type PaymentUpdateManyWithoutUserNestedInput as t9, type Prisma__HospitalSpecializationClient as tA, type Prisma__NotificationClient as tB, type Prisma__PaymentClient as tC, type Prisma__ReviewClient as tD, type Prisma__SavedDoctorHospitalClient as tE, type Prisma__ScheduleClient as tF, type Prisma__SearchLogClient as tG, type Prisma__SlotClient as tH, type Prisma__SpecializationClient as tI, type Prisma__UserClient as tJ, type Prisma__accountClient as tK, type Prisma__sessionClient as tL, type Prisma__verificationClient as tM, type QueryEvent as tN, type Result as tO, type Review$DoctorArgs as tP, type Review$HospitalArgs as tQ, type ReviewAggregateArgs as tR, type ReviewAvgAggregateInputType as tS, type ReviewAvgAggregateOutputType as tT, type ReviewAvgOrderByAggregateInput as tU, type ReviewCountAggregateInputType as tV, type ReviewCountAggregateOutputType as tW, type ReviewCountArgs as tX, type ReviewCountOrderByAggregateInput as tY, type ReviewCreateArgs as tZ, type ReviewCreateInput as t_, type PaymentUpdateOneWithoutAppointmentNestedInput as ta, type PaymentUpdateToOneWithWhereWithoutAppointmentInput as tb, type PaymentUpdateWithWhereUniqueWithoutUserInput as tc, type PaymentUpdateWithoutAppointmentInput as td, type PaymentUpdateWithoutUserInput as te, type PaymentUpsertArgs as tf, type PaymentUpsertWithWhereUniqueWithoutUserInput as tg, type PaymentUpsertWithoutAppointmentInput as th, type PaymentWhereInput as ti, type PaymentWhereUniqueInput as tj, type PickEnumerable as tk, type PrismaAction as tl, PrismaClientInitializationError as tm, PrismaClientKnownRequestError as tn, PrismaClientRustPanicError as to, PrismaClientUnknownRequestError as tp, PrismaClientValidationError as tq, type PrismaPromise as tr, type PrismaVersion as ts, type Prisma__AppointmentClient as tt, type Prisma__AuditLogClient as tu, type Prisma__DoctorApplicationClient as tv, type Prisma__DoctorClient as tw, type Prisma__DoctorHospitalProfileClient as tx, type Prisma__DoctorSpecializationClient as ty, type Prisma__HospitalClient as tz, type $HospitalPayload as u, type ReviewUncheckedUpdateManyWithoutDoctorNestedInput as u$, type ReviewCreateManyArgs as u0, type ReviewCreateManyDoctorInput as u1, type ReviewCreateManyDoctorInputEnvelope as u2, type ReviewCreateManyHospitalInput as u3, type ReviewCreateManyHospitalInputEnvelope as u4, type ReviewCreateManyInput as u5, type ReviewCreateManyUserInput as u6, type ReviewCreateManyUserInputEnvelope as u7, type ReviewCreateNestedManyWithoutDoctorInput as u8, type ReviewCreateNestedManyWithoutHospitalInput as u9, type ReviewMaxOrderByAggregateInput as uA, type ReviewMinAggregateInputType as uB, type ReviewMinAggregateOutputType as uC, type ReviewMinOrderByAggregateInput as uD, type ReviewOmit as uE, type ReviewOrderByRelationAggregateInput as uF, type ReviewOrderByWithAggregationInput as uG, type ReviewOrderByWithRelationInput as uH, type ReviewScalarWhereInput as uI, type ReviewScalarWhereWithAggregatesInput as uJ, type ReviewSelect as uK, type ReviewSelectCreateManyAndReturn as uL, type ReviewSelectScalar as uM, type ReviewSelectUpdateManyAndReturn as uN, type ReviewSumAggregateInputType as uO, type ReviewSumAggregateOutputType as uP, type ReviewSumOrderByAggregateInput as uQ, type ReviewUncheckedCreateInput as uR, type ReviewUncheckedCreateNestedManyWithoutDoctorInput as uS, type ReviewUncheckedCreateNestedManyWithoutHospitalInput as uT, type ReviewUncheckedCreateNestedManyWithoutUserInput as uU, type ReviewUncheckedCreateWithoutDoctorInput as uV, type ReviewUncheckedCreateWithoutHospitalInput as uW, type ReviewUncheckedCreateWithoutUserInput as uX, type ReviewUncheckedUpdateInput as uY, type ReviewUncheckedUpdateManyInput as uZ, type ReviewUncheckedUpdateManyWithoutDoctorInput as u_, type ReviewCreateNestedManyWithoutUserInput as ua, type ReviewCreateOrConnectWithoutDoctorInput as ub, type ReviewCreateOrConnectWithoutHospitalInput as uc, type ReviewCreateOrConnectWithoutUserInput as ud, type ReviewCreateWithoutDoctorInput as ue, type ReviewCreateWithoutHospitalInput as uf, type ReviewCreateWithoutUserInput as ug, type ReviewDefaultArgs as uh, type ReviewDelegate as ui, type ReviewDeleteArgs as uj, type ReviewDeleteManyArgs as uk, type ReviewFieldRefs as ul, type ReviewFindFirstArgs as um, type ReviewFindFirstOrThrowArgs as un, type ReviewFindManyArgs as uo, type ReviewFindUniqueArgs as up, type ReviewFindUniqueOrThrowArgs as uq, type ReviewGetPayload as ur, type ReviewGroupByArgs as us, type ReviewGroupByOutputType as ut, type ReviewInclude as uu, type ReviewIncludeCreateManyAndReturn as uv, type ReviewIncludeUpdateManyAndReturn as uw, type ReviewListRelationFilter as ux, type ReviewMaxAggregateInputType as uy, type ReviewMaxAggregateOutputType as uz, type verificationModel as v, type SavedDoctorHospitalFindFirstOrThrowArgs as v$, type ReviewUncheckedUpdateManyWithoutHospitalInput as v0, type ReviewUncheckedUpdateManyWithoutHospitalNestedInput as v1, type ReviewUncheckedUpdateManyWithoutUserInput as v2, type ReviewUncheckedUpdateManyWithoutUserNestedInput as v3, type ReviewUncheckedUpdateWithoutDoctorInput as v4, type ReviewUncheckedUpdateWithoutHospitalInput as v5, type ReviewUncheckedUpdateWithoutUserInput as v6, type ReviewUpdateArgs as v7, type ReviewUpdateInput as v8, type ReviewUpdateManyAndReturnArgs as v9, type SavedDoctorHospitalCountOrderByAggregateInput as vA, type SavedDoctorHospitalCreateArgs as vB, type SavedDoctorHospitalCreateInput as vC, type SavedDoctorHospitalCreateManyAndReturnArgs as vD, type SavedDoctorHospitalCreateManyArgs as vE, type SavedDoctorHospitalCreateManyDoctorInput as vF, type SavedDoctorHospitalCreateManyDoctorInputEnvelope as vG, type SavedDoctorHospitalCreateManyHospitalInput as vH, type SavedDoctorHospitalCreateManyHospitalInputEnvelope as vI, type SavedDoctorHospitalCreateManyInput as vJ, type SavedDoctorHospitalCreateManyUserInput as vK, type SavedDoctorHospitalCreateManyUserInputEnvelope as vL, type SavedDoctorHospitalCreateNestedManyWithoutDoctorInput as vM, type SavedDoctorHospitalCreateNestedManyWithoutHospitalInput as vN, type SavedDoctorHospitalCreateNestedManyWithoutUserInput as vO, type SavedDoctorHospitalCreateOrConnectWithoutDoctorInput as vP, type SavedDoctorHospitalCreateOrConnectWithoutHospitalInput as vQ, type SavedDoctorHospitalCreateOrConnectWithoutUserInput as vR, type SavedDoctorHospitalCreateWithoutDoctorInput as vS, type SavedDoctorHospitalCreateWithoutHospitalInput as vT, type SavedDoctorHospitalCreateWithoutUserInput as vU, type SavedDoctorHospitalDefaultArgs as vV, type SavedDoctorHospitalDelegate as vW, type SavedDoctorHospitalDeleteArgs as vX, type SavedDoctorHospitalDeleteManyArgs as vY, type SavedDoctorHospitalFieldRefs as vZ, type SavedDoctorHospitalFindFirstArgs as v_, type ReviewUpdateManyArgs as va, type ReviewUpdateManyMutationInput as vb, type ReviewUpdateManyWithWhereWithoutDoctorInput as vc, type ReviewUpdateManyWithWhereWithoutHospitalInput as vd, type ReviewUpdateManyWithWhereWithoutUserInput as ve, type ReviewUpdateManyWithoutDoctorNestedInput as vf, type ReviewUpdateManyWithoutHospitalNestedInput as vg, type ReviewUpdateManyWithoutUserNestedInput as vh, type ReviewUpdateWithWhereUniqueWithoutDoctorInput as vi, type ReviewUpdateWithWhereUniqueWithoutHospitalInput as vj, type ReviewUpdateWithWhereUniqueWithoutUserInput as vk, type ReviewUpdateWithoutDoctorInput as vl, type ReviewUpdateWithoutHospitalInput as vm, type ReviewUpdateWithoutUserInput as vn, type ReviewUpsertArgs as vo, type ReviewUpsertWithWhereUniqueWithoutDoctorInput as vp, type ReviewUpsertWithWhereUniqueWithoutHospitalInput as vq, type ReviewUpsertWithWhereUniqueWithoutUserInput as vr, type ReviewWhereInput as vs, type ReviewWhereUniqueInput as vt, type SavedDoctorHospital$DoctorArgs as vu, type SavedDoctorHospital$HospitalArgs as vv, type SavedDoctorHospitalAggregateArgs as vw, type SavedDoctorHospitalCountAggregateInputType as vx, type SavedDoctorHospitalCountAggregateOutputType as vy, type SavedDoctorHospitalCountArgs as vz, type $HospitalSpecializationPayload as w, type SavedDoctorHospitalUpsertWithWhereUniqueWithoutHospitalInput as w$, type SavedDoctorHospitalFindManyArgs as w0, type SavedDoctorHospitalFindUniqueArgs as w1, type SavedDoctorHospitalFindUniqueOrThrowArgs as w2, type SavedDoctorHospitalGetPayload as w3, type SavedDoctorHospitalGroupByArgs as w4, type SavedDoctorHospitalGroupByOutputType as w5, type SavedDoctorHospitalInclude as w6, type SavedDoctorHospitalIncludeCreateManyAndReturn as w7, type SavedDoctorHospitalIncludeUpdateManyAndReturn as w8, type SavedDoctorHospitalListRelationFilter as w9, type SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorNestedInput as wA, type SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalInput as wB, type SavedDoctorHospitalUncheckedUpdateManyWithoutHospitalNestedInput as wC, type SavedDoctorHospitalUncheckedUpdateManyWithoutUserInput as wD, type SavedDoctorHospitalUncheckedUpdateManyWithoutUserNestedInput as wE, type SavedDoctorHospitalUncheckedUpdateWithoutDoctorInput as wF, type SavedDoctorHospitalUncheckedUpdateWithoutHospitalInput as wG, type SavedDoctorHospitalUncheckedUpdateWithoutUserInput as wH, type SavedDoctorHospitalUpdateArgs as wI, type SavedDoctorHospitalUpdateInput as wJ, type SavedDoctorHospitalUpdateManyAndReturnArgs as wK, type SavedDoctorHospitalUpdateManyArgs as wL, type SavedDoctorHospitalUpdateManyMutationInput as wM, type SavedDoctorHospitalUpdateManyWithWhereWithoutDoctorInput as wN, type SavedDoctorHospitalUpdateManyWithWhereWithoutHospitalInput as wO, type SavedDoctorHospitalUpdateManyWithWhereWithoutUserInput as wP, type SavedDoctorHospitalUpdateManyWithoutDoctorNestedInput as wQ, type SavedDoctorHospitalUpdateManyWithoutHospitalNestedInput as wR, type SavedDoctorHospitalUpdateManyWithoutUserNestedInput as wS, type SavedDoctorHospitalUpdateWithWhereUniqueWithoutDoctorInput as wT, type SavedDoctorHospitalUpdateWithWhereUniqueWithoutHospitalInput as wU, type SavedDoctorHospitalUpdateWithWhereUniqueWithoutUserInput as wV, type SavedDoctorHospitalUpdateWithoutDoctorInput as wW, type SavedDoctorHospitalUpdateWithoutHospitalInput as wX, type SavedDoctorHospitalUpdateWithoutUserInput as wY, type SavedDoctorHospitalUpsertArgs as wZ, type SavedDoctorHospitalUpsertWithWhereUniqueWithoutDoctorInput as w_, type SavedDoctorHospitalMaxAggregateInputType as wa, type SavedDoctorHospitalMaxAggregateOutputType as wb, type SavedDoctorHospitalMaxOrderByAggregateInput as wc, type SavedDoctorHospitalMinAggregateInputType as wd, type SavedDoctorHospitalMinAggregateOutputType as we, type SavedDoctorHospitalMinOrderByAggregateInput as wf, type SavedDoctorHospitalOmit as wg, type SavedDoctorHospitalOrderByRelationAggregateInput as wh, type SavedDoctorHospitalOrderByWithAggregationInput as wi, type SavedDoctorHospitalOrderByWithRelationInput as wj, type SavedDoctorHospitalScalarWhereInput as wk, type SavedDoctorHospitalScalarWhereWithAggregatesInput as wl, type SavedDoctorHospitalSelect as wm, type SavedDoctorHospitalSelectCreateManyAndReturn as wn, type SavedDoctorHospitalSelectScalar as wo, type SavedDoctorHospitalSelectUpdateManyAndReturn as wp, type SavedDoctorHospitalUncheckedCreateInput as wq, type SavedDoctorHospitalUncheckedCreateNestedManyWithoutDoctorInput as wr, type SavedDoctorHospitalUncheckedCreateNestedManyWithoutHospitalInput as ws, type SavedDoctorHospitalUncheckedCreateNestedManyWithoutUserInput as wt, type SavedDoctorHospitalUncheckedCreateWithoutDoctorInput as wu, type SavedDoctorHospitalUncheckedCreateWithoutHospitalInput as wv, type SavedDoctorHospitalUncheckedCreateWithoutUserInput as ww, type SavedDoctorHospitalUncheckedUpdateInput as wx, type SavedDoctorHospitalUncheckedUpdateManyInput as wy, type SavedDoctorHospitalUncheckedUpdateManyWithoutDoctorInput as wz, type $NotificationPayload as x, type ScheduleMaxAggregateOutputType as x$, type SavedDoctorHospitalUpsertWithWhereUniqueWithoutUserInput as x0, type SavedDoctorHospitalWhereInput as x1, type SavedDoctorHospitalWhereUniqueInput as x2, type Schedule$AppointmentArgs as x3, type Schedule$SlotArgs as x4, type ScheduleAggregateArgs as x5, type ScheduleAvgAggregateInputType as x6, type ScheduleAvgAggregateOutputType as x7, type ScheduleAvgOrderByAggregateInput as x8, type ScheduleCountAggregateInputType as x9, type ScheduleCreateOrConnectWithoutHospitalInput as xA, type ScheduleCreateOrConnectWithoutSlotInput as xB, type ScheduleCreateOrConnectWithoutUserInput as xC, type ScheduleCreateWithoutAppointmentInput as xD, type ScheduleCreateWithoutDoctorInput as xE, type ScheduleCreateWithoutHospitalInput as xF, type ScheduleCreateWithoutSlotInput as xG, type ScheduleCreateWithoutUserInput as xH, type ScheduleCreatedayOfWeekInput as xI, type ScheduleDefaultArgs as xJ, type ScheduleDelegate as xK, type ScheduleDeleteArgs as xL, type ScheduleDeleteManyArgs as xM, type ScheduleFieldRefs as xN, type ScheduleFindFirstArgs as xO, type ScheduleFindFirstOrThrowArgs as xP, type ScheduleFindManyArgs as xQ, type ScheduleFindUniqueArgs as xR, type ScheduleFindUniqueOrThrowArgs as xS, type ScheduleGetPayload as xT, type ScheduleGroupByArgs as xU, type ScheduleGroupByOutputType as xV, type ScheduleInclude as xW, type ScheduleIncludeCreateManyAndReturn as xX, type ScheduleIncludeUpdateManyAndReturn as xY, type ScheduleListRelationFilter as xZ, type ScheduleMaxAggregateInputType as x_, type ScheduleCountAggregateOutputType as xa, type ScheduleCountArgs as xb, type ScheduleCountOrderByAggregateInput as xc, type ScheduleCountOutputType as xd, type ScheduleCountOutputTypeCountAppointmentArgs as xe, type ScheduleCountOutputTypeCountSlotArgs as xf, type ScheduleCountOutputTypeDefaultArgs as xg, type ScheduleCountOutputTypeSelect as xh, type ScheduleCreateArgs as xi, type ScheduleCreateInput as xj, type ScheduleCreateManyAndReturnArgs as xk, type ScheduleCreateManyArgs as xl, type ScheduleCreateManyDoctorInput as xm, type ScheduleCreateManyDoctorInputEnvelope as xn, type ScheduleCreateManyHospitalInput as xo, type ScheduleCreateManyHospitalInputEnvelope as xp, type ScheduleCreateManyInput as xq, type ScheduleCreateManyUserInput as xr, type ScheduleCreateManyUserInputEnvelope as xs, type ScheduleCreateNestedManyWithoutDoctorInput as xt, type ScheduleCreateNestedManyWithoutHospitalInput as xu, type ScheduleCreateNestedManyWithoutUserInput as xv, type ScheduleCreateNestedOneWithoutAppointmentInput as xw, type ScheduleCreateNestedOneWithoutSlotInput as xx, type ScheduleCreateOrConnectWithoutAppointmentInput as xy, type ScheduleCreateOrConnectWithoutDoctorInput as xz, type $PaymentPayload as y, type ScheduleUpdatedayOfWeekInput as y$, type ScheduleMaxOrderByAggregateInput as y0, type ScheduleMinAggregateInputType as y1, type ScheduleMinAggregateOutputType as y2, type ScheduleMinOrderByAggregateInput as y3, type ScheduleOmit as y4, type ScheduleOrderByRelationAggregateInput as y5, type ScheduleOrderByWithAggregationInput as y6, type ScheduleOrderByWithRelationInput as y7, type ScheduleScalarRelationFilter as y8, type ScheduleScalarWhereInput as y9, type ScheduleUncheckedUpdateWithoutDoctorInput as yA, type ScheduleUncheckedUpdateWithoutHospitalInput as yB, type ScheduleUncheckedUpdateWithoutSlotInput as yC, type ScheduleUncheckedUpdateWithoutUserInput as yD, type ScheduleUpdateArgs as yE, type ScheduleUpdateInput as yF, type ScheduleUpdateManyAndReturnArgs as yG, type ScheduleUpdateManyArgs as yH, type ScheduleUpdateManyMutationInput as yI, type ScheduleUpdateManyWithWhereWithoutDoctorInput as yJ, type ScheduleUpdateManyWithWhereWithoutHospitalInput as yK, type ScheduleUpdateManyWithWhereWithoutUserInput as yL, type ScheduleUpdateManyWithoutDoctorNestedInput as yM, type ScheduleUpdateManyWithoutHospitalNestedInput as yN, type ScheduleUpdateManyWithoutUserNestedInput as yO, type ScheduleUpdateOneRequiredWithoutAppointmentNestedInput as yP, type ScheduleUpdateOneRequiredWithoutSlotNestedInput as yQ, type ScheduleUpdateToOneWithWhereWithoutAppointmentInput as yR, type ScheduleUpdateToOneWithWhereWithoutSlotInput as yS, type ScheduleUpdateWithWhereUniqueWithoutDoctorInput as yT, type ScheduleUpdateWithWhereUniqueWithoutHospitalInput as yU, type ScheduleUpdateWithWhereUniqueWithoutUserInput as yV, type ScheduleUpdateWithoutAppointmentInput as yW, type ScheduleUpdateWithoutDoctorInput as yX, type ScheduleUpdateWithoutHospitalInput as yY, type ScheduleUpdateWithoutSlotInput as yZ, type ScheduleUpdateWithoutUserInput as y_, type ScheduleScalarWhereWithAggregatesInput as ya, type ScheduleSelect as yb, type ScheduleSelectCreateManyAndReturn as yc, type ScheduleSelectScalar as yd, type ScheduleSelectUpdateManyAndReturn as ye, type ScheduleSumAggregateInputType as yf, type ScheduleSumAggregateOutputType as yg, type ScheduleSumOrderByAggregateInput as yh, type ScheduleUncheckedCreateInput as yi, type ScheduleUncheckedCreateNestedManyWithoutDoctorInput as yj, type ScheduleUncheckedCreateNestedManyWithoutHospitalInput as yk, type ScheduleUncheckedCreateNestedManyWithoutUserInput as yl, type ScheduleUncheckedCreateWithoutAppointmentInput as ym, type ScheduleUncheckedCreateWithoutDoctorInput as yn, type ScheduleUncheckedCreateWithoutHospitalInput as yo, type ScheduleUncheckedCreateWithoutSlotInput as yp, type ScheduleUncheckedCreateWithoutUserInput as yq, type ScheduleUncheckedUpdateInput as yr, type ScheduleUncheckedUpdateManyInput as ys, type ScheduleUncheckedUpdateManyWithoutDoctorInput as yt, type ScheduleUncheckedUpdateManyWithoutDoctorNestedInput as yu, type ScheduleUncheckedUpdateManyWithoutHospitalInput as yv, type ScheduleUncheckedUpdateManyWithoutHospitalNestedInput as yw, type ScheduleUncheckedUpdateManyWithoutUserInput as yx, type ScheduleUncheckedUpdateManyWithoutUserNestedInput as yy, type ScheduleUncheckedUpdateWithoutAppointmentInput as yz, type $ReviewPayload as z, type SearchLogUncheckedUpdateWithoutUserInput as z$, type ScheduleUpsertArgs as z0, type ScheduleUpsertWithWhereUniqueWithoutDoctorInput as z1, type ScheduleUpsertWithWhereUniqueWithoutHospitalInput as z2, type ScheduleUpsertWithWhereUniqueWithoutUserInput as z3, type ScheduleUpsertWithoutAppointmentInput as z4, type ScheduleUpsertWithoutSlotInput as z5, type ScheduleWhereInput as z6, type ScheduleWhereUniqueInput as z7, type SearchLogAggregateArgs as z8, type SearchLogCountAggregateInputType as z9, type SearchLogInclude as zA, type SearchLogIncludeCreateManyAndReturn as zB, type SearchLogIncludeUpdateManyAndReturn as zC, type SearchLogListRelationFilter as zD, type SearchLogMaxAggregateInputType as zE, type SearchLogMaxAggregateOutputType as zF, type SearchLogMaxOrderByAggregateInput as zG, type SearchLogMinAggregateInputType as zH, type SearchLogMinAggregateOutputType as zI, type SearchLogMinOrderByAggregateInput as zJ, type SearchLogOmit as zK, type SearchLogOrderByRelationAggregateInput as zL, type SearchLogOrderByWithAggregationInput as zM, type SearchLogOrderByWithRelationInput as zN, type SearchLogScalarWhereInput as zO, type SearchLogScalarWhereWithAggregatesInput as zP, type SearchLogSelect as zQ, type SearchLogSelectCreateManyAndReturn as zR, type SearchLogSelectScalar as zS, type SearchLogSelectUpdateManyAndReturn as zT, type SearchLogUncheckedCreateInput as zU, type SearchLogUncheckedCreateNestedManyWithoutUserInput as zV, type SearchLogUncheckedCreateWithoutUserInput as zW, type SearchLogUncheckedUpdateInput as zX, type SearchLogUncheckedUpdateManyInput as zY, type SearchLogUncheckedUpdateManyWithoutUserInput as zZ, type SearchLogUncheckedUpdateManyWithoutUserNestedInput as z_, type SearchLogCountAggregateOutputType as za, type SearchLogCountArgs as zb, type SearchLogCountOrderByAggregateInput as zc, type SearchLogCreateArgs as zd, type SearchLogCreateInput as ze, type SearchLogCreateManyAndReturnArgs as zf, type SearchLogCreateManyArgs as zg, type SearchLogCreateManyInput as zh, type SearchLogCreateManyUserInput as zi, type SearchLogCreateManyUserInputEnvelope as zj, type SearchLogCreateNestedManyWithoutUserInput as zk, type SearchLogCreateOrConnectWithoutUserInput as zl, type SearchLogCreateWithoutUserInput as zm, type SearchLogDefaultArgs as zn, type SearchLogDelegate as zo, type SearchLogDeleteArgs as zp, type SearchLogDeleteManyArgs as zq, type SearchLogFieldRefs as zr, type SearchLogFindFirstArgs as zs, type SearchLogFindFirstOrThrowArgs as zt, type SearchLogFindManyArgs as zu, type SearchLogFindUniqueArgs as zv, type SearchLogFindUniqueOrThrowArgs as zw, type SearchLogGetPayload as zx, type SearchLogGroupByArgs as zy, type SearchLogGroupByOutputType as zz };
